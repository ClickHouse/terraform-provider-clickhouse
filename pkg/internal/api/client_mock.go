// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package api

//go:generate minimock -i github.com/ClickHouse/terraform-provider-clickhouse/pkg/internal/api.Client -o client_mock.go -n ClientMock -p api

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangeClickPipeState          func(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error)
	funcChangeClickPipeStateOrigin    string
	inspectFuncChangeClickPipeState   func(ctx context.Context, serviceId string, clickPipeId string, command string)
	afterChangeClickPipeStateCounter  uint64
	beforeChangeClickPipeStateCounter uint64
	ChangeClickPipeStateMock          mClientMockChangeClickPipeState

	funcCreateClickPipe          func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)
	funcCreateClickPipeOrigin    string
	inspectFuncCreateClickPipe   func(ctx context.Context, serviceId string, clickPipe ClickPipe)
	afterCreateClickPipeCounter  uint64
	beforeCreateClickPipeCounter uint64
	CreateClickPipeMock          mClientMockCreateClickPipe

	funcCreateQueryEndpoint          func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error)
	funcCreateQueryEndpointOrigin    string
	inspectFuncCreateQueryEndpoint   func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint)
	afterCreateQueryEndpointCounter  uint64
	beforeCreateQueryEndpointCounter uint64
	CreateQueryEndpointMock          mClientMockCreateQueryEndpoint

	funcCreateReversePrivateEndpoint          func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) (rp1 *ReversePrivateEndpoint, err error)
	funcCreateReversePrivateEndpointOrigin    string
	inspectFuncCreateReversePrivateEndpoint   func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint)
	afterCreateReversePrivateEndpointCounter  uint64
	beforeCreateReversePrivateEndpointCounter uint64
	CreateReversePrivateEndpointMock          mClientMockCreateReversePrivateEndpoint

	funcCreateService          func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)
	funcCreateServiceOrigin    string
	inspectFuncCreateService   func(ctx context.Context, s Service)
	afterCreateServiceCounter  uint64
	beforeCreateServiceCounter uint64
	CreateServiceMock          mClientMockCreateService

	funcDeleteClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (err error)
	funcDeleteClickPipeOrigin    string
	inspectFuncDeleteClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterDeleteClickPipeCounter  uint64
	beforeDeleteClickPipeCounter uint64
	DeleteClickPipeMock          mClientMockDeleteClickPipe

	funcDeleteQueryEndpoint          func(ctx context.Context, serviceID string) (err error)
	funcDeleteQueryEndpointOrigin    string
	inspectFuncDeleteQueryEndpoint   func(ctx context.Context, serviceID string)
	afterDeleteQueryEndpointCounter  uint64
	beforeDeleteQueryEndpointCounter uint64
	DeleteQueryEndpointMock          mClientMockDeleteQueryEndpoint

	funcDeleteReversePrivateEndpoint          func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (err error)
	funcDeleteReversePrivateEndpointOrigin    string
	inspectFuncDeleteReversePrivateEndpoint   func(ctx context.Context, serviceId string, reversePrivateEndpointId string)
	afterDeleteReversePrivateEndpointCounter  uint64
	beforeDeleteReversePrivateEndpointCounter uint64
	DeleteReversePrivateEndpointMock          mClientMockDeleteReversePrivateEndpoint

	funcDeleteService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	funcDeleteServiceOrigin    string
	inspectFuncDeleteService   func(ctx context.Context, serviceId string)
	afterDeleteServiceCounter  uint64
	beforeDeleteServiceCounter uint64
	DeleteServiceMock          mClientMockDeleteService

	funcGetApiKeyID          func(ctx context.Context, name *string) (ap1 *ApiKey, err error)
	funcGetApiKeyIDOrigin    string
	inspectFuncGetApiKeyID   func(ctx context.Context, name *string)
	afterGetApiKeyIDCounter  uint64
	beforeGetApiKeyIDCounter uint64
	GetApiKeyIDMock          mClientMockGetApiKeyID

	funcGetBackupConfiguration          func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)
	funcGetBackupConfigurationOrigin    string
	inspectFuncGetBackupConfiguration   func(ctx context.Context, serviceId string)
	afterGetBackupConfigurationCounter  uint64
	beforeGetBackupConfigurationCounter uint64
	GetBackupConfigurationMock          mClientMockGetBackupConfiguration

	funcGetClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)
	funcGetClickPipeOrigin    string
	inspectFuncGetClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterGetClickPipeCounter  uint64
	beforeGetClickPipeCounter uint64
	GetClickPipeMock          mClientMockGetClickPipe

	funcGetOrgPrivateEndpointConfig          func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)
	funcGetOrgPrivateEndpointConfigOrigin    string
	inspectFuncGetOrgPrivateEndpointConfig   func(ctx context.Context, cloudProvider string, region string)
	afterGetOrgPrivateEndpointConfigCounter  uint64
	beforeGetOrgPrivateEndpointConfigCounter uint64
	GetOrgPrivateEndpointConfigMock          mClientMockGetOrgPrivateEndpointConfig

	funcGetOrganizationPrivateEndpoints          func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)
	funcGetOrganizationPrivateEndpointsOrigin    string
	inspectFuncGetOrganizationPrivateEndpoints   func(ctx context.Context)
	afterGetOrganizationPrivateEndpointsCounter  uint64
	beforeGetOrganizationPrivateEndpointsCounter uint64
	GetOrganizationPrivateEndpointsMock          mClientMockGetOrganizationPrivateEndpoints

	funcGetQueryEndpoint          func(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error)
	funcGetQueryEndpointOrigin    string
	inspectFuncGetQueryEndpoint   func(ctx context.Context, serviceID string)
	afterGetQueryEndpointCounter  uint64
	beforeGetQueryEndpointCounter uint64
	GetQueryEndpointMock          mClientMockGetQueryEndpoint

	funcGetReversePrivateEndpoint          func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (rp1 *ReversePrivateEndpoint, err error)
	funcGetReversePrivateEndpointOrigin    string
	inspectFuncGetReversePrivateEndpoint   func(ctx context.Context, serviceId string, reversePrivateEndpointId string)
	afterGetReversePrivateEndpointCounter  uint64
	beforeGetReversePrivateEndpointCounter uint64
	GetReversePrivateEndpointMock          mClientMockGetReversePrivateEndpoint

	funcGetReversePrivateEndpointPath          func(serviceId string, reversePrivateEndpointId string) (s1 string)
	funcGetReversePrivateEndpointPathOrigin    string
	inspectFuncGetReversePrivateEndpointPath   func(serviceId string, reversePrivateEndpointId string)
	afterGetReversePrivateEndpointPathCounter  uint64
	beforeGetReversePrivateEndpointPathCounter uint64
	GetReversePrivateEndpointPathMock          mClientMockGetReversePrivateEndpointPath

	funcGetService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	funcGetServiceOrigin    string
	inspectFuncGetService   func(ctx context.Context, serviceId string)
	afterGetServiceCounter  uint64
	beforeGetServiceCounter uint64
	GetServiceMock          mClientMockGetService

	funcListReversePrivateEndpoints          func(ctx context.Context, serviceId string) (rpa1 []*ReversePrivateEndpoint, err error)
	funcListReversePrivateEndpointsOrigin    string
	inspectFuncListReversePrivateEndpoints   func(ctx context.Context, serviceId string)
	afterListReversePrivateEndpointsCounter  uint64
	beforeListReversePrivateEndpointsCounter uint64
	ListReversePrivateEndpointsMock          mClientMockListReversePrivateEndpoints

	funcRotateTDEKey          func(ctx context.Context, serviceId string, keyId string) (err error)
	funcRotateTDEKeyOrigin    string
	inspectFuncRotateTDEKey   func(ctx context.Context, serviceId string, keyId string)
	afterRotateTDEKeyCounter  uint64
	beforeRotateTDEKeyCounter uint64
	RotateTDEKeyMock          mClientMockRotateTDEKey

	funcScalingClickPipe          func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest) (cp1 *ClickPipe, err error)
	funcScalingClickPipeOrigin    string
	inspectFuncScalingClickPipe   func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest)
	afterScalingClickPipeCounter  uint64
	beforeScalingClickPipeCounter uint64
	ScalingClickPipeMock          mClientMockScalingClickPipe

	funcUpdateBackupConfiguration          func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)
	funcUpdateBackupConfigurationOrigin    string
	inspectFuncUpdateBackupConfiguration   func(ctx context.Context, serviceId string, b BackupConfiguration)
	afterUpdateBackupConfigurationCounter  uint64
	beforeUpdateBackupConfigurationCounter uint64
	UpdateBackupConfigurationMock          mClientMockUpdateBackupConfiguration

	funcUpdateClickPipe          func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) (cp1 *ClickPipe, err error)
	funcUpdateClickPipeOrigin    string
	inspectFuncUpdateClickPipe   func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate)
	afterUpdateClickPipeCounter  uint64
	beforeUpdateClickPipeCounter uint64
	UpdateClickPipeMock          mClientMockUpdateClickPipe

	funcUpdateOrganizationPrivateEndpoints          func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)
	funcUpdateOrganizationPrivateEndpointsOrigin    string
	inspectFuncUpdateOrganizationPrivateEndpoints   func(ctx context.Context, orgUpdate OrganizationUpdate)
	afterUpdateOrganizationPrivateEndpointsCounter  uint64
	beforeUpdateOrganizationPrivateEndpointsCounter uint64
	UpdateOrganizationPrivateEndpointsMock          mClientMockUpdateOrganizationPrivateEndpoints

	funcUpdateReplicaScaling          func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)
	funcUpdateReplicaScalingOrigin    string
	inspectFuncUpdateReplicaScaling   func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)
	afterUpdateReplicaScalingCounter  uint64
	beforeUpdateReplicaScalingCounter uint64
	UpdateReplicaScalingMock          mClientMockUpdateReplicaScaling

	funcUpdateService          func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)
	funcUpdateServiceOrigin    string
	inspectFuncUpdateService   func(ctx context.Context, serviceId string, s ServiceUpdate)
	afterUpdateServiceCounter  uint64
	beforeUpdateServiceCounter uint64
	UpdateServiceMock          mClientMockUpdateService

	funcUpdateServicePassword          func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)
	funcUpdateServicePasswordOrigin    string
	inspectFuncUpdateServicePassword   func(ctx context.Context, serviceId string, u ServicePasswordUpdate)
	afterUpdateServicePasswordCounter  uint64
	beforeUpdateServicePasswordCounter uint64
	UpdateServicePasswordMock          mClientMockUpdateServicePassword

	funcWaitForClickPipeState          func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error)
	funcWaitForClickPipeStateOrigin    string
	inspectFuncWaitForClickPipeState   func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64)
	afterWaitForClickPipeStateCounter  uint64
	beforeWaitForClickPipeStateCounter uint64
	WaitForClickPipeStateMock          mClientMockWaitForClickPipeState

	funcWaitForReversePrivateEndpointState          func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) (rp1 *ReversePrivateEndpoint, err error)
	funcWaitForReversePrivateEndpointStateOrigin    string
	inspectFuncWaitForReversePrivateEndpointState   func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64)
	afterWaitForReversePrivateEndpointStateCounter  uint64
	beforeWaitForReversePrivateEndpointStateCounter uint64
	WaitForReversePrivateEndpointStateMock          mClientMockWaitForReversePrivateEndpointState

	funcWaitForServiceState          func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)
	funcWaitForServiceStateOrigin    string
	inspectFuncWaitForServiceState   func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)
	afterWaitForServiceStateCounter  uint64
	beforeWaitForServiceStateCounter uint64
	WaitForServiceStateMock          mClientMockWaitForServiceState
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangeClickPipeStateMock = mClientMockChangeClickPipeState{mock: m}
	m.ChangeClickPipeStateMock.callArgs = []*ClientMockChangeClickPipeStateParams{}

	m.CreateClickPipeMock = mClientMockCreateClickPipe{mock: m}
	m.CreateClickPipeMock.callArgs = []*ClientMockCreateClickPipeParams{}

	m.CreateQueryEndpointMock = mClientMockCreateQueryEndpoint{mock: m}
	m.CreateQueryEndpointMock.callArgs = []*ClientMockCreateQueryEndpointParams{}

	m.CreateReversePrivateEndpointMock = mClientMockCreateReversePrivateEndpoint{mock: m}
	m.CreateReversePrivateEndpointMock.callArgs = []*ClientMockCreateReversePrivateEndpointParams{}

	m.CreateServiceMock = mClientMockCreateService{mock: m}
	m.CreateServiceMock.callArgs = []*ClientMockCreateServiceParams{}

	m.DeleteClickPipeMock = mClientMockDeleteClickPipe{mock: m}
	m.DeleteClickPipeMock.callArgs = []*ClientMockDeleteClickPipeParams{}

	m.DeleteQueryEndpointMock = mClientMockDeleteQueryEndpoint{mock: m}
	m.DeleteQueryEndpointMock.callArgs = []*ClientMockDeleteQueryEndpointParams{}

	m.DeleteReversePrivateEndpointMock = mClientMockDeleteReversePrivateEndpoint{mock: m}
	m.DeleteReversePrivateEndpointMock.callArgs = []*ClientMockDeleteReversePrivateEndpointParams{}

	m.DeleteServiceMock = mClientMockDeleteService{mock: m}
	m.DeleteServiceMock.callArgs = []*ClientMockDeleteServiceParams{}

	m.GetApiKeyIDMock = mClientMockGetApiKeyID{mock: m}
	m.GetApiKeyIDMock.callArgs = []*ClientMockGetApiKeyIDParams{}

	m.GetBackupConfigurationMock = mClientMockGetBackupConfiguration{mock: m}
	m.GetBackupConfigurationMock.callArgs = []*ClientMockGetBackupConfigurationParams{}

	m.GetClickPipeMock = mClientMockGetClickPipe{mock: m}
	m.GetClickPipeMock.callArgs = []*ClientMockGetClickPipeParams{}

	m.GetOrgPrivateEndpointConfigMock = mClientMockGetOrgPrivateEndpointConfig{mock: m}
	m.GetOrgPrivateEndpointConfigMock.callArgs = []*ClientMockGetOrgPrivateEndpointConfigParams{}

	m.GetOrganizationPrivateEndpointsMock = mClientMockGetOrganizationPrivateEndpoints{mock: m}
	m.GetOrganizationPrivateEndpointsMock.callArgs = []*ClientMockGetOrganizationPrivateEndpointsParams{}

	m.GetQueryEndpointMock = mClientMockGetQueryEndpoint{mock: m}
	m.GetQueryEndpointMock.callArgs = []*ClientMockGetQueryEndpointParams{}

	m.GetReversePrivateEndpointMock = mClientMockGetReversePrivateEndpoint{mock: m}
	m.GetReversePrivateEndpointMock.callArgs = []*ClientMockGetReversePrivateEndpointParams{}

	m.GetReversePrivateEndpointPathMock = mClientMockGetReversePrivateEndpointPath{mock: m}
	m.GetReversePrivateEndpointPathMock.callArgs = []*ClientMockGetReversePrivateEndpointPathParams{}

	m.GetServiceMock = mClientMockGetService{mock: m}
	m.GetServiceMock.callArgs = []*ClientMockGetServiceParams{}

	m.ListReversePrivateEndpointsMock = mClientMockListReversePrivateEndpoints{mock: m}
	m.ListReversePrivateEndpointsMock.callArgs = []*ClientMockListReversePrivateEndpointsParams{}

	m.RotateTDEKeyMock = mClientMockRotateTDEKey{mock: m}
	m.RotateTDEKeyMock.callArgs = []*ClientMockRotateTDEKeyParams{}

	m.ScalingClickPipeMock = mClientMockScalingClickPipe{mock: m}
	m.ScalingClickPipeMock.callArgs = []*ClientMockScalingClickPipeParams{}

	m.UpdateBackupConfigurationMock = mClientMockUpdateBackupConfiguration{mock: m}
	m.UpdateBackupConfigurationMock.callArgs = []*ClientMockUpdateBackupConfigurationParams{}

	m.UpdateClickPipeMock = mClientMockUpdateClickPipe{mock: m}
	m.UpdateClickPipeMock.callArgs = []*ClientMockUpdateClickPipeParams{}

	m.UpdateOrganizationPrivateEndpointsMock = mClientMockUpdateOrganizationPrivateEndpoints{mock: m}
	m.UpdateOrganizationPrivateEndpointsMock.callArgs = []*ClientMockUpdateOrganizationPrivateEndpointsParams{}

	m.UpdateReplicaScalingMock = mClientMockUpdateReplicaScaling{mock: m}
	m.UpdateReplicaScalingMock.callArgs = []*ClientMockUpdateReplicaScalingParams{}

	m.UpdateServiceMock = mClientMockUpdateService{mock: m}
	m.UpdateServiceMock.callArgs = []*ClientMockUpdateServiceParams{}

	m.UpdateServicePasswordMock = mClientMockUpdateServicePassword{mock: m}
	m.UpdateServicePasswordMock.callArgs = []*ClientMockUpdateServicePasswordParams{}

	m.WaitForClickPipeStateMock = mClientMockWaitForClickPipeState{mock: m}
	m.WaitForClickPipeStateMock.callArgs = []*ClientMockWaitForClickPipeStateParams{}

	m.WaitForReversePrivateEndpointStateMock = mClientMockWaitForReversePrivateEndpointState{mock: m}
	m.WaitForReversePrivateEndpointStateMock.callArgs = []*ClientMockWaitForReversePrivateEndpointStateParams{}

	m.WaitForServiceStateMock = mClientMockWaitForServiceState{mock: m}
	m.WaitForServiceStateMock.callArgs = []*ClientMockWaitForServiceStateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockChangeClickPipeState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockChangeClickPipeStateExpectation
	expectations       []*ClientMockChangeClickPipeStateExpectation

	callArgs []*ClientMockChangeClickPipeStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockChangeClickPipeStateExpectation specifies expectation struct of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateExpectation struct {
	mock               *ClientMock
	params             *ClientMockChangeClickPipeStateParams
	paramPtrs          *ClientMockChangeClickPipeStateParamPtrs
	expectationOrigins ClientMockChangeClickPipeStateExpectationOrigins
	results            *ClientMockChangeClickPipeStateResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockChangeClickPipeStateParams contains parameters of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	command     string
}

// ClientMockChangeClickPipeStateParamPtrs contains pointers to parameters of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	command     *string
}

// ClientMockChangeClickPipeStateResults contains results of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockChangeClickPipeStateOrigins contains origins of expectations of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
	originCommand     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Optional() *mClientMockChangeClickPipeState {
	mmChangeClickPipeState.optional = true
	return mmChangeClickPipeState
}

// Expect sets up expected params for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Expect(ctx context.Context, serviceId string, clickPipeId string, command string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by ExpectParams functions")
	}

	mmChangeClickPipeState.defaultExpectation.params = &ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}
	mmChangeClickPipeState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChangeClickPipeState.expectations {
		if minimock.Equal(e.params, mmChangeClickPipeState.defaultExpectation.params) {
			mmChangeClickPipeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeClickPipeState.defaultExpectation.params)
		}
	}

	return mmChangeClickPipeState
}

// ExpectCtxParam1 sets up expected param ctx for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectCtxParam1(ctx context.Context) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.ctx = &ctx
	mmChangeClickPipeState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChangeClickPipeState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectServiceIdParam2(serviceId string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmChangeClickPipeState.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmChangeClickPipeState
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmChangeClickPipeState.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmChangeClickPipeState
}

// ExpectCommandParam4 sets up expected param command for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectCommandParam4(command string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.command = &command
	mmChangeClickPipeState.defaultExpectation.expectationOrigins.originCommand = minimock.CallerInfo(1)

	return mmChangeClickPipeState
}

// Inspect accepts an inspector function that has same arguments as the Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, command string)) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.inspectFuncChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("Inspect function is already set for ClientMock.ChangeClickPipeState")
	}

	mmChangeClickPipeState.mock.inspectFuncChangeClickPipeState = f

	return mmChangeClickPipeState
}

// Return sets up results that will be returned by Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{mock: mmChangeClickPipeState.mock}
	}
	mmChangeClickPipeState.defaultExpectation.results = &ClientMockChangeClickPipeStateResults{cp1, err}
	mmChangeClickPipeState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChangeClickPipeState.mock
}

// Set uses given function f to mock the Client.ChangeClickPipeState method
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Set(f func(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmChangeClickPipeState.defaultExpectation != nil {
		mmChangeClickPipeState.mock.t.Fatalf("Default expectation is already set for the Client.ChangeClickPipeState method")
	}

	if len(mmChangeClickPipeState.expectations) > 0 {
		mmChangeClickPipeState.mock.t.Fatalf("Some expectations are already set for the Client.ChangeClickPipeState method")
	}

	mmChangeClickPipeState.mock.funcChangeClickPipeState = f
	mmChangeClickPipeState.mock.funcChangeClickPipeStateOrigin = minimock.CallerInfo(1)
	return mmChangeClickPipeState.mock
}

// When sets expectation for the Client.ChangeClickPipeState which will trigger the result defined by the following
// Then helper
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) When(ctx context.Context, serviceId string, clickPipeId string, command string) *ClientMockChangeClickPipeStateExpectation {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockChangeClickPipeStateExpectation{
		mock:               mmChangeClickPipeState.mock,
		params:             &ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command},
		expectationOrigins: ClientMockChangeClickPipeStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChangeClickPipeState.expectations = append(mmChangeClickPipeState.expectations, expectation)
	return expectation
}

// Then sets up Client.ChangeClickPipeState return parameters for the expectation previously defined by the When method
func (e *ClientMockChangeClickPipeStateExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockChangeClickPipeStateResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ChangeClickPipeState should be invoked
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Times(n uint64) *mClientMockChangeClickPipeState {
	if n == 0 {
		mmChangeClickPipeState.mock.t.Fatalf("Times of ClientMock.ChangeClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangeClickPipeState.expectedInvocations, n)
	mmChangeClickPipeState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChangeClickPipeState
}

func (mmChangeClickPipeState *mClientMockChangeClickPipeState) invocationsDone() bool {
	if len(mmChangeClickPipeState.expectations) == 0 && mmChangeClickPipeState.defaultExpectation == nil && mmChangeClickPipeState.mock.funcChangeClickPipeState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangeClickPipeState.mock.afterChangeClickPipeStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangeClickPipeState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangeClickPipeState implements Client
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeState(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmChangeClickPipeState.beforeChangeClickPipeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeClickPipeState.afterChangeClickPipeStateCounter, 1)

	mmChangeClickPipeState.t.Helper()

	if mmChangeClickPipeState.inspectFuncChangeClickPipeState != nil {
		mmChangeClickPipeState.inspectFuncChangeClickPipeState(ctx, serviceId, clickPipeId, command)
	}

	mm_params := ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}

	// Record call args
	mmChangeClickPipeState.ChangeClickPipeStateMock.mutex.Lock()
	mmChangeClickPipeState.ChangeClickPipeStateMock.callArgs = append(mmChangeClickPipeState.ChangeClickPipeStateMock.callArgs, &mm_params)
	mmChangeClickPipeState.ChangeClickPipeStateMock.mutex.Unlock()

	for _, e := range mmChangeClickPipeState.ChangeClickPipeStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.params
		mm_want_ptrs := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.command != nil && !minimock.Equal(*mm_want_ptrs.command, mm_got.command) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter command, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.expectationOrigins.originCommand, *mm_want_ptrs.command, mm_got.command, minimock.Diff(*mm_want_ptrs.command, mm_got.command))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeClickPipeState.t.Fatal("No results are set for the ClientMock.ChangeClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChangeClickPipeState.funcChangeClickPipeState != nil {
		return mmChangeClickPipeState.funcChangeClickPipeState(ctx, serviceId, clickPipeId, command)
	}
	mmChangeClickPipeState.t.Fatalf("Unexpected call to ClientMock.ChangeClickPipeState. %v %v %v %v", ctx, serviceId, clickPipeId, command)
	return
}

// ChangeClickPipeStateAfterCounter returns a count of finished ClientMock.ChangeClickPipeState invocations
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeClickPipeState.afterChangeClickPipeStateCounter)
}

// ChangeClickPipeStateBeforeCounter returns a count of ClientMock.ChangeClickPipeState invocations
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeClickPipeState.beforeChangeClickPipeStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ChangeClickPipeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Calls() []*ClientMockChangeClickPipeStateParams {
	mmChangeClickPipeState.mutex.RLock()

	argCopy := make([]*ClientMockChangeClickPipeStateParams, len(mmChangeClickPipeState.callArgs))
	copy(argCopy, mmChangeClickPipeState.callArgs)

	mmChangeClickPipeState.mutex.RUnlock()

	return argCopy
}

// MinimockChangeClickPipeStateDone returns true if the count of the ChangeClickPipeState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockChangeClickPipeStateDone() bool {
	if m.ChangeClickPipeStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangeClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangeClickPipeStateMock.invocationsDone()
}

// MinimockChangeClickPipeStateInspect logs each unmet expectation
func (m *ClientMock) MinimockChangeClickPipeStateInspect() {
	for _, e := range m.ChangeClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChangeClickPipeStateCounter := mm_atomic.LoadUint64(&m.afterChangeClickPipeStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeClickPipeStateMock.defaultExpectation != nil && afterChangeClickPipeStateCounter < 1 {
		if m.ChangeClickPipeStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s", m.ChangeClickPipeStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s with params: %#v", m.ChangeClickPipeStateMock.defaultExpectation.expectationOrigins.origin, *m.ChangeClickPipeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeClickPipeState != nil && afterChangeClickPipeStateCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s", m.funcChangeClickPipeStateOrigin)
	}

	if !m.ChangeClickPipeStateMock.invocationsDone() && afterChangeClickPipeStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ChangeClickPipeState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChangeClickPipeStateMock.expectedInvocations), m.ChangeClickPipeStateMock.expectedInvocationsOrigin, afterChangeClickPipeStateCounter)
	}
}

type mClientMockCreateClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateClickPipeExpectation
	expectations       []*ClientMockCreateClickPipeExpectation

	callArgs []*ClientMockCreateClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateClickPipeExpectation specifies expectation struct of the Client.CreateClickPipe
type ClientMockCreateClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateClickPipeParams
	paramPtrs          *ClientMockCreateClickPipeParamPtrs
	expectationOrigins ClientMockCreateClickPipeExpectationOrigins
	results            *ClientMockCreateClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateClickPipeParams contains parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParams struct {
	ctx       context.Context
	serviceId string
	clickPipe ClickPipe
}

// ClientMockCreateClickPipeParamPtrs contains pointers to parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	clickPipe *ClickPipe
}

// ClientMockCreateClickPipeResults contains results of the Client.CreateClickPipe
type ClientMockCreateClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockCreateClickPipeOrigins contains origins of expectations of the Client.CreateClickPipe
type ClientMockCreateClickPipeExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originClickPipe string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateClickPipe *mClientMockCreateClickPipe) Optional() *mClientMockCreateClickPipe {
	mmCreateClickPipe.optional = true
	return mmCreateClickPipe
}

// Expect sets up expected params for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Expect(ctx context.Context, serviceId string, clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by ExpectParams functions")
	}

	mmCreateClickPipe.defaultExpectation.params = &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}
	mmCreateClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateClickPipe.expectations {
		if minimock.Equal(e.params, mmCreateClickPipe.defaultExpectation.params) {
			mmCreateClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClickPipe.defaultExpectation.params)
		}
	}

	return mmCreateClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmCreateClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmCreateClickPipe
}

// ExpectClickPipeParam3 sets up expected param clickPipe for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectClickPipeParam3(clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.clickPipe = &clickPipe
	mmCreateClickPipe.defaultExpectation.expectationOrigins.originClickPipe = minimock.CallerInfo(1)

	return mmCreateClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipe ClickPipe)) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateClickPipe")
	}

	mmCreateClickPipe.mock.inspectFuncCreateClickPipe = f

	return mmCreateClickPipe
}

// Return sets up results that will be returned by Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{mock: mmCreateClickPipe.mock}
	}
	mmCreateClickPipe.defaultExpectation.results = &ClientMockCreateClickPipeResults{cp1, err}
	mmCreateClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateClickPipe.mock
}

// Set uses given function f to mock the Client.CreateClickPipe method
func (mmCreateClickPipe *mClientMockCreateClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmCreateClickPipe.defaultExpectation != nil {
		mmCreateClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.CreateClickPipe method")
	}

	if len(mmCreateClickPipe.expectations) > 0 {
		mmCreateClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.CreateClickPipe method")
	}

	mmCreateClickPipe.mock.funcCreateClickPipe = f
	mmCreateClickPipe.mock.funcCreateClickPipeOrigin = minimock.CallerInfo(1)
	return mmCreateClickPipe.mock
}

// When sets expectation for the Client.CreateClickPipe which will trigger the result defined by the following
// Then helper
func (mmCreateClickPipe *mClientMockCreateClickPipe) When(ctx context.Context, serviceId string, clickPipe ClickPipe) *ClientMockCreateClickPipeExpectation {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	expectation := &ClientMockCreateClickPipeExpectation{
		mock:               mmCreateClickPipe.mock,
		params:             &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe},
		expectationOrigins: ClientMockCreateClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateClickPipe.expectations = append(mmCreateClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockCreateClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.CreateClickPipe should be invoked
func (mmCreateClickPipe *mClientMockCreateClickPipe) Times(n uint64) *mClientMockCreateClickPipe {
	if n == 0 {
		mmCreateClickPipe.mock.t.Fatalf("Times of ClientMock.CreateClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateClickPipe.expectedInvocations, n)
	mmCreateClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateClickPipe
}

func (mmCreateClickPipe *mClientMockCreateClickPipe) invocationsDone() bool {
	if len(mmCreateClickPipe.expectations) == 0 && mmCreateClickPipe.defaultExpectation == nil && mmCreateClickPipe.mock.funcCreateClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.mock.afterCreateClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateClickPipe implements Client
func (mmCreateClickPipe *ClientMock) CreateClickPipe(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClickPipe.afterCreateClickPipeCounter, 1)

	mmCreateClickPipe.t.Helper()

	if mmCreateClickPipe.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.inspectFuncCreateClickPipe(ctx, serviceId, clickPipe)
	}

	mm_params := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

	// Record call args
	mmCreateClickPipe.CreateClickPipeMock.mutex.Lock()
	mmCreateClickPipe.CreateClickPipeMock.callArgs = append(mmCreateClickPipe.CreateClickPipeMock.callArgs, &mm_params)
	mmCreateClickPipe.CreateClickPipeMock.mutex.Unlock()

	for _, e := range mmCreateClickPipe.CreateClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateClickPipe.CreateClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipe != nil && !minimock.Equal(*mm_want_ptrs.clickPipe, mm_got.clickPipe) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter clickPipe, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.originClickPipe, *mm_want_ptrs.clickPipe, mm_got.clickPipe, minimock.Diff(*mm_want_ptrs.clickPipe, mm_got.clickPipe))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClickPipe.t.Fatal("No results are set for the ClientMock.CreateClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateClickPipe.funcCreateClickPipe != nil {
		return mmCreateClickPipe.funcCreateClickPipe(ctx, serviceId, clickPipe)
	}
	mmCreateClickPipe.t.Fatalf("Unexpected call to ClientMock.CreateClickPipe. %v %v %v", ctx, serviceId, clickPipe)
	return
}

// CreateClickPipeAfterCounter returns a count of finished ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.afterCreateClickPipeCounter)
}

// CreateClickPipeBeforeCounter returns a count of ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClickPipe *mClientMockCreateClickPipe) Calls() []*ClientMockCreateClickPipeParams {
	mmCreateClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockCreateClickPipeParams, len(mmCreateClickPipe.callArgs))
	copy(argCopy, mmCreateClickPipe.callArgs)

	mmCreateClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClickPipeDone returns true if the count of the CreateClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateClickPipeDone() bool {
	if m.CreateClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateClickPipeMock.invocationsDone()
}

// MinimockCreateClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateClickPipeInspect() {
	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateClickPipeCounter := mm_atomic.LoadUint64(&m.afterCreateClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClickPipeMock.defaultExpectation != nil && afterCreateClickPipeCounter < 1 {
		if m.CreateClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s", m.CreateClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s with params: %#v", m.CreateClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.CreateClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClickPipe != nil && afterCreateClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s", m.funcCreateClickPipeOrigin)
	}

	if !m.CreateClickPipeMock.invocationsDone() && afterCreateClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateClickPipeMock.expectedInvocations), m.CreateClickPipeMock.expectedInvocationsOrigin, afterCreateClickPipeCounter)
	}
}

type mClientMockCreateQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateQueryEndpointExpectation
	expectations       []*ClientMockCreateQueryEndpointExpectation

	callArgs []*ClientMockCreateQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateQueryEndpointExpectation specifies expectation struct of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateQueryEndpointParams
	paramPtrs          *ClientMockCreateQueryEndpointParamPtrs
	expectationOrigins ClientMockCreateQueryEndpointExpectationOrigins
	results            *ClientMockCreateQueryEndpointResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateQueryEndpointParams contains parameters of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
	endpoint  ServiceQueryEndpoint
}

// ClientMockCreateQueryEndpointParamPtrs contains pointers to parameters of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	endpoint  *ServiceQueryEndpoint
}

// ClientMockCreateQueryEndpointResults contains results of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointResults struct {
	sp1 *ServiceQueryEndpoint
	err error
}

// ClientMockCreateQueryEndpointOrigins contains origins of expectations of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceID string
	originEndpoint  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Optional() *mClientMockCreateQueryEndpoint {
	mmCreateQueryEndpoint.optional = true
	return mmCreateQueryEndpoint
}

// Expect sets up expected params for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Expect(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmCreateQueryEndpoint.defaultExpectation.params = &ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}
	mmCreateQueryEndpoint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmCreateQueryEndpoint.defaultExpectation.params) {
			mmCreateQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmCreateQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateQueryEndpoint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID
	mmCreateQueryEndpoint.defaultExpectation.expectationOrigins.originServiceID = minimock.CallerInfo(1)

	return mmCreateQueryEndpoint
}

// ExpectEndpointParam3 sets up expected param endpoint for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectEndpointParam3(endpoint ServiceQueryEndpoint) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.endpoint = &endpoint
	mmCreateQueryEndpoint.defaultExpectation.expectationOrigins.originEndpoint = minimock.CallerInfo(1)

	return mmCreateQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint)) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.inspectFuncCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateQueryEndpoint")
	}

	mmCreateQueryEndpoint.mock.inspectFuncCreateQueryEndpoint = f

	return mmCreateQueryEndpoint
}

// Return sets up results that will be returned by Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Return(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{mock: mmCreateQueryEndpoint.mock}
	}
	mmCreateQueryEndpoint.defaultExpectation.results = &ClientMockCreateQueryEndpointResults{sp1, err}
	mmCreateQueryEndpoint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateQueryEndpoint.mock
}

// Set uses given function f to mock the Client.CreateQueryEndpoint method
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Set(f func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error)) *ClientMock {
	if mmCreateQueryEndpoint.defaultExpectation != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.CreateQueryEndpoint method")
	}

	if len(mmCreateQueryEndpoint.expectations) > 0 {
		mmCreateQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.CreateQueryEndpoint method")
	}

	mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint = f
	mmCreateQueryEndpoint.mock.funcCreateQueryEndpointOrigin = minimock.CallerInfo(1)
	return mmCreateQueryEndpoint.mock
}

// When sets expectation for the Client.CreateQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) When(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) *ClientMockCreateQueryEndpointExpectation {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockCreateQueryEndpointExpectation{
		mock:               mmCreateQueryEndpoint.mock,
		params:             &ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint},
		expectationOrigins: ClientMockCreateQueryEndpointExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateQueryEndpoint.expectations = append(mmCreateQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateQueryEndpointExpectation) Then(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	e.results = &ClientMockCreateQueryEndpointResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.CreateQueryEndpoint should be invoked
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Times(n uint64) *mClientMockCreateQueryEndpoint {
	if n == 0 {
		mmCreateQueryEndpoint.mock.t.Fatalf("Times of ClientMock.CreateQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateQueryEndpoint.expectedInvocations, n)
	mmCreateQueryEndpoint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateQueryEndpoint
}

func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) invocationsDone() bool {
	if len(mmCreateQueryEndpoint.expectations) == 0 && mmCreateQueryEndpoint.defaultExpectation == nil && mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateQueryEndpoint.mock.afterCreateQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateQueryEndpoint implements Client
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpoint(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error) {
	mm_atomic.AddUint64(&mmCreateQueryEndpoint.beforeCreateQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateQueryEndpoint.afterCreateQueryEndpointCounter, 1)

	mmCreateQueryEndpoint.t.Helper()

	if mmCreateQueryEndpoint.inspectFuncCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.inspectFuncCreateQueryEndpoint(ctx, serviceID, endpoint)
	}

	mm_params := ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}

	// Record call args
	mmCreateQueryEndpoint.CreateQueryEndpointMock.mutex.Lock()
	mmCreateQueryEndpoint.CreateQueryEndpointMock.callArgs = append(mmCreateQueryEndpoint.CreateQueryEndpointMock.callArgs, &mm_params)
	mmCreateQueryEndpoint.CreateQueryEndpointMock.mutex.Unlock()

	for _, e := range mmCreateQueryEndpoint.CreateQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter serviceID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.expectationOrigins.originServiceID, *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.endpoint != nil && !minimock.Equal(*mm_want_ptrs.endpoint, mm_got.endpoint) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter endpoint, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.expectationOrigins.originEndpoint, *mm_want_ptrs.endpoint, mm_got.endpoint, minimock.Diff(*mm_want_ptrs.endpoint, mm_got.endpoint))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateQueryEndpoint.t.Fatal("No results are set for the ClientMock.CreateQueryEndpoint")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmCreateQueryEndpoint.funcCreateQueryEndpoint != nil {
		return mmCreateQueryEndpoint.funcCreateQueryEndpoint(ctx, serviceID, endpoint)
	}
	mmCreateQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.CreateQueryEndpoint. %v %v %v", ctx, serviceID, endpoint)
	return
}

// CreateQueryEndpointAfterCounter returns a count of finished ClientMock.CreateQueryEndpoint invocations
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateQueryEndpoint.afterCreateQueryEndpointCounter)
}

// CreateQueryEndpointBeforeCounter returns a count of ClientMock.CreateQueryEndpoint invocations
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateQueryEndpoint.beforeCreateQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Calls() []*ClientMockCreateQueryEndpointParams {
	mmCreateQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockCreateQueryEndpointParams, len(mmCreateQueryEndpoint.callArgs))
	copy(argCopy, mmCreateQueryEndpoint.callArgs)

	mmCreateQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockCreateQueryEndpointDone returns true if the count of the CreateQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateQueryEndpointDone() bool {
	if m.CreateQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateQueryEndpointMock.invocationsDone()
}

// MinimockCreateQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateQueryEndpointInspect() {
	for _, e := range m.CreateQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterCreateQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateQueryEndpointMock.defaultExpectation != nil && afterCreateQueryEndpointCounter < 1 {
		if m.CreateQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint at\n%s", m.CreateQueryEndpointMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint at\n%s with params: %#v", m.CreateQueryEndpointMock.defaultExpectation.expectationOrigins.origin, *m.CreateQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateQueryEndpoint != nil && afterCreateQueryEndpointCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint at\n%s", m.funcCreateQueryEndpointOrigin)
	}

	if !m.CreateQueryEndpointMock.invocationsDone() && afterCreateQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateQueryEndpoint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateQueryEndpointMock.expectedInvocations), m.CreateQueryEndpointMock.expectedInvocationsOrigin, afterCreateQueryEndpointCounter)
	}
}

type mClientMockCreateReversePrivateEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateReversePrivateEndpointExpectation
	expectations       []*ClientMockCreateReversePrivateEndpointExpectation

	callArgs []*ClientMockCreateReversePrivateEndpointParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateReversePrivateEndpointExpectation specifies expectation struct of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateReversePrivateEndpointParams
	paramPtrs          *ClientMockCreateReversePrivateEndpointParamPtrs
	expectationOrigins ClientMockCreateReversePrivateEndpointExpectationOrigins
	results            *ClientMockCreateReversePrivateEndpointResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateReversePrivateEndpointParams contains parameters of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointParams struct {
	ctx       context.Context
	serviceId string
	request   CreateReversePrivateEndpoint
}

// ClientMockCreateReversePrivateEndpointParamPtrs contains pointers to parameters of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	request   *CreateReversePrivateEndpoint
}

// ClientMockCreateReversePrivateEndpointResults contains results of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointResults struct {
	rp1 *ReversePrivateEndpoint
	err error
}

// ClientMockCreateReversePrivateEndpointOrigins contains origins of expectations of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originRequest   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Optional() *mClientMockCreateReversePrivateEndpoint {
	mmCreateReversePrivateEndpoint.optional = true
	return mmCreateReversePrivateEndpoint
}

// Expect sets up expected params for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Expect(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by ExpectParams functions")
	}

	mmCreateReversePrivateEndpoint.defaultExpectation.params = &ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request}
	mmCreateReversePrivateEndpoint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateReversePrivateEndpoint.expectations {
		if minimock.Equal(e.params, mmCreateReversePrivateEndpoint.defaultExpectation.params) {
			mmCreateReversePrivateEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReversePrivateEndpoint.defaultExpectation.params)
		}
	}

	return mmCreateReversePrivateEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.params != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Expect")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateReversePrivateEndpointParamPtrs{}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateReversePrivateEndpoint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateReversePrivateEndpoint
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) ExpectServiceIdParam2(serviceId string) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.params != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Expect")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateReversePrivateEndpointParamPtrs{}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmCreateReversePrivateEndpoint.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmCreateReversePrivateEndpoint
}

// ExpectRequestParam3 sets up expected param request for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) ExpectRequestParam3(request CreateReversePrivateEndpoint) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.params != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Expect")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateReversePrivateEndpointParamPtrs{}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs.request = &request
	mmCreateReversePrivateEndpoint.defaultExpectation.expectationOrigins.originRequest = minimock.CallerInfo(1)

	return mmCreateReversePrivateEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Inspect(f func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint)) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.inspectFuncCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateReversePrivateEndpoint")
	}

	mmCreateReversePrivateEndpoint.mock.inspectFuncCreateReversePrivateEndpoint = f

	return mmCreateReversePrivateEndpoint
}

// Return sets up results that will be returned by Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Return(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{mock: mmCreateReversePrivateEndpoint.mock}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.results = &ClientMockCreateReversePrivateEndpointResults{rp1, err}
	mmCreateReversePrivateEndpoint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateReversePrivateEndpoint.mock
}

// Set uses given function f to mock the Client.CreateReversePrivateEndpoint method
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Set(f func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) (rp1 *ReversePrivateEndpoint, err error)) *ClientMock {
	if mmCreateReversePrivateEndpoint.defaultExpectation != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.CreateReversePrivateEndpoint method")
	}

	if len(mmCreateReversePrivateEndpoint.expectations) > 0 {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.CreateReversePrivateEndpoint method")
	}

	mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint = f
	mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpointOrigin = minimock.CallerInfo(1)
	return mmCreateReversePrivateEndpoint.mock
}

// When sets expectation for the Client.CreateReversePrivateEndpoint which will trigger the result defined by the following
// Then helper
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) When(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) *ClientMockCreateReversePrivateEndpointExpectation {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	expectation := &ClientMockCreateReversePrivateEndpointExpectation{
		mock:               mmCreateReversePrivateEndpoint.mock,
		params:             &ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request},
		expectationOrigins: ClientMockCreateReversePrivateEndpointExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateReversePrivateEndpoint.expectations = append(mmCreateReversePrivateEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateReversePrivateEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateReversePrivateEndpointExpectation) Then(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockCreateReversePrivateEndpointResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.CreateReversePrivateEndpoint should be invoked
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Times(n uint64) *mClientMockCreateReversePrivateEndpoint {
	if n == 0 {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Times of ClientMock.CreateReversePrivateEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReversePrivateEndpoint.expectedInvocations, n)
	mmCreateReversePrivateEndpoint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateReversePrivateEndpoint
}

func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) invocationsDone() bool {
	if len(mmCreateReversePrivateEndpoint.expectations) == 0 && mmCreateReversePrivateEndpoint.defaultExpectation == nil && mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.mock.afterCreateReversePrivateEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReversePrivateEndpoint implements Client
func (mmCreateReversePrivateEndpoint *ClientMock) CreateReversePrivateEndpoint(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) (rp1 *ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmCreateReversePrivateEndpoint.beforeCreateReversePrivateEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReversePrivateEndpoint.afterCreateReversePrivateEndpointCounter, 1)

	mmCreateReversePrivateEndpoint.t.Helper()

	if mmCreateReversePrivateEndpoint.inspectFuncCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.inspectFuncCreateReversePrivateEndpoint(ctx, serviceId, request)
	}

	mm_params := ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request}

	// Record call args
	mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.mutex.Lock()
	mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.callArgs = append(mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.callArgs, &mm_params)
	mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.mutex.Unlock()

	for _, e := range mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameter request, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originRequest, *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReversePrivateEndpoint.t.Fatal("No results are set for the ClientMock.CreateReversePrivateEndpoint")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateReversePrivateEndpoint.funcCreateReversePrivateEndpoint != nil {
		return mmCreateReversePrivateEndpoint.funcCreateReversePrivateEndpoint(ctx, serviceId, request)
	}
	mmCreateReversePrivateEndpoint.t.Fatalf("Unexpected call to ClientMock.CreateReversePrivateEndpoint. %v %v %v", ctx, serviceId, request)
	return
}

// CreateReversePrivateEndpointAfterCounter returns a count of finished ClientMock.CreateReversePrivateEndpoint invocations
func (mmCreateReversePrivateEndpoint *ClientMock) CreateReversePrivateEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.afterCreateReversePrivateEndpointCounter)
}

// CreateReversePrivateEndpointBeforeCounter returns a count of ClientMock.CreateReversePrivateEndpoint invocations
func (mmCreateReversePrivateEndpoint *ClientMock) CreateReversePrivateEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.beforeCreateReversePrivateEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateReversePrivateEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Calls() []*ClientMockCreateReversePrivateEndpointParams {
	mmCreateReversePrivateEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockCreateReversePrivateEndpointParams, len(mmCreateReversePrivateEndpoint.callArgs))
	copy(argCopy, mmCreateReversePrivateEndpoint.callArgs)

	mmCreateReversePrivateEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReversePrivateEndpointDone returns true if the count of the CreateReversePrivateEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateReversePrivateEndpointDone() bool {
	if m.CreateReversePrivateEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReversePrivateEndpointMock.invocationsDone()
}

// MinimockCreateReversePrivateEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateReversePrivateEndpointInspect() {
	for _, e := range m.CreateReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateReversePrivateEndpoint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateReversePrivateEndpointCounter := mm_atomic.LoadUint64(&m.afterCreateReversePrivateEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReversePrivateEndpointMock.defaultExpectation != nil && afterCreateReversePrivateEndpointCounter < 1 {
		if m.CreateReversePrivateEndpointMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateReversePrivateEndpoint at\n%s", m.CreateReversePrivateEndpointMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateReversePrivateEndpoint at\n%s with params: %#v", m.CreateReversePrivateEndpointMock.defaultExpectation.expectationOrigins.origin, *m.CreateReversePrivateEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReversePrivateEndpoint != nil && afterCreateReversePrivateEndpointCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateReversePrivateEndpoint at\n%s", m.funcCreateReversePrivateEndpointOrigin)
	}

	if !m.CreateReversePrivateEndpointMock.invocationsDone() && afterCreateReversePrivateEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateReversePrivateEndpoint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReversePrivateEndpointMock.expectedInvocations), m.CreateReversePrivateEndpointMock.expectedInvocationsOrigin, afterCreateReversePrivateEndpointCounter)
	}
}

type mClientMockCreateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateServiceExpectation
	expectations       []*ClientMockCreateServiceExpectation

	callArgs []*ClientMockCreateServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateServiceExpectation specifies expectation struct of the Client.CreateService
type ClientMockCreateServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateServiceParams
	paramPtrs          *ClientMockCreateServiceParamPtrs
	expectationOrigins ClientMockCreateServiceExpectationOrigins
	results            *ClientMockCreateServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateServiceParams contains parameters of the Client.CreateService
type ClientMockCreateServiceParams struct {
	ctx context.Context
	s   Service
}

// ClientMockCreateServiceParamPtrs contains pointers to parameters of the Client.CreateService
type ClientMockCreateServiceParamPtrs struct {
	ctx *context.Context
	s   *Service
}

// ClientMockCreateServiceResults contains results of the Client.CreateService
type ClientMockCreateServiceResults struct {
	sp1 *Service
	s1  string
	err error
}

// ClientMockCreateServiceOrigins contains origins of expectations of the Client.CreateService
type ClientMockCreateServiceExpectationOrigins struct {
	origin    string
	originCtx string
	originS   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateService *mClientMockCreateService) Optional() *mClientMockCreateService {
	mmCreateService.optional = true
	return mmCreateService
}

// Expect sets up expected params for Client.CreateService
func (mmCreateService *mClientMockCreateService) Expect(ctx context.Context, s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.paramPtrs != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by ExpectParams functions")
	}

	mmCreateService.defaultExpectation.params = &ClientMockCreateServiceParams{ctx, s}
	mmCreateService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateService.expectations {
		if minimock.Equal(e.params, mmCreateService.defaultExpectation.params) {
			mmCreateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateService.defaultExpectation.params)
		}
	}

	return mmCreateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectCtxParam1(ctx context.Context) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateService
}

// ExpectSParam2 sets up expected param s for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectSParam2(s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.s = &s
	mmCreateService.defaultExpectation.expectationOrigins.originS = minimock.CallerInfo(1)

	return mmCreateService
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateService
func (mmCreateService *mClientMockCreateService) Inspect(f func(ctx context.Context, s Service)) *mClientMockCreateService {
	if mmCreateService.mock.inspectFuncCreateService != nil {
		mmCreateService.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateService")
	}

	mmCreateService.mock.inspectFuncCreateService = f

	return mmCreateService
}

// Return sets up results that will be returned by Client.CreateService
func (mmCreateService *mClientMockCreateService) Return(sp1 *Service, s1 string, err error) *ClientMock {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{mock: mmCreateService.mock}
	}
	mmCreateService.defaultExpectation.results = &ClientMockCreateServiceResults{sp1, s1, err}
	mmCreateService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateService.mock
}

// Set uses given function f to mock the Client.CreateService method
func (mmCreateService *mClientMockCreateService) Set(f func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)) *ClientMock {
	if mmCreateService.defaultExpectation != nil {
		mmCreateService.mock.t.Fatalf("Default expectation is already set for the Client.CreateService method")
	}

	if len(mmCreateService.expectations) > 0 {
		mmCreateService.mock.t.Fatalf("Some expectations are already set for the Client.CreateService method")
	}

	mmCreateService.mock.funcCreateService = f
	mmCreateService.mock.funcCreateServiceOrigin = minimock.CallerInfo(1)
	return mmCreateService.mock
}

// When sets expectation for the Client.CreateService which will trigger the result defined by the following
// Then helper
func (mmCreateService *mClientMockCreateService) When(ctx context.Context, s Service) *ClientMockCreateServiceExpectation {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	expectation := &ClientMockCreateServiceExpectation{
		mock:               mmCreateService.mock,
		params:             &ClientMockCreateServiceParams{ctx, s},
		expectationOrigins: ClientMockCreateServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateService.expectations = append(mmCreateService.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateService return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateServiceExpectation) Then(sp1 *Service, s1 string, err error) *ClientMock {
	e.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return e.mock
}

// Times sets number of times Client.CreateService should be invoked
func (mmCreateService *mClientMockCreateService) Times(n uint64) *mClientMockCreateService {
	if n == 0 {
		mmCreateService.mock.t.Fatalf("Times of ClientMock.CreateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateService.expectedInvocations, n)
	mmCreateService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateService
}

func (mmCreateService *mClientMockCreateService) invocationsDone() bool {
	if len(mmCreateService.expectations) == 0 && mmCreateService.defaultExpectation == nil && mmCreateService.mock.funcCreateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateService.mock.afterCreateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateService implements Client
func (mmCreateService *ClientMock) CreateService(ctx context.Context, s Service) (sp1 *Service, s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateService.beforeCreateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateService.afterCreateServiceCounter, 1)

	mmCreateService.t.Helper()

	if mmCreateService.inspectFuncCreateService != nil {
		mmCreateService.inspectFuncCreateService(ctx, s)
	}

	mm_params := ClientMockCreateServiceParams{ctx, s}

	// Record call args
	mmCreateService.CreateServiceMock.mutex.Lock()
	mmCreateService.CreateServiceMock.callArgs = append(mmCreateService.CreateServiceMock.callArgs, &mm_params)
	mmCreateService.CreateServiceMock.mutex.Unlock()

	for _, e := range mmCreateService.CreateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.err
		}
	}

	if mmCreateService.CreateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateService.CreateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateService.CreateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmCreateService.CreateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateServiceParams{ctx, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateService.CreateServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter s, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateService.CreateServiceMock.defaultExpectation.expectationOrigins.originS, *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateService.CreateServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateService.CreateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateService.t.Fatal("No results are set for the ClientMock.CreateService")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).err
	}
	if mmCreateService.funcCreateService != nil {
		return mmCreateService.funcCreateService(ctx, s)
	}
	mmCreateService.t.Fatalf("Unexpected call to ClientMock.CreateService. %v %v", ctx, s)
	return
}

// CreateServiceAfterCounter returns a count of finished ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.afterCreateServiceCounter)
}

// CreateServiceBeforeCounter returns a count of ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.beforeCreateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateService *mClientMockCreateService) Calls() []*ClientMockCreateServiceParams {
	mmCreateService.mutex.RLock()

	argCopy := make([]*ClientMockCreateServiceParams, len(mmCreateService.callArgs))
	copy(argCopy, mmCreateService.callArgs)

	mmCreateService.mutex.RUnlock()

	return argCopy
}

// MinimockCreateServiceDone returns true if the count of the CreateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateServiceDone() bool {
	if m.CreateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateServiceMock.invocationsDone()
}

// MinimockCreateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateServiceInspect() {
	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateServiceCounter := mm_atomic.LoadUint64(&m.afterCreateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceMock.defaultExpectation != nil && afterCreateServiceCounter < 1 {
		if m.CreateServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateService at\n%s", m.CreateServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateService at\n%s with params: %#v", m.CreateServiceMock.defaultExpectation.expectationOrigins.origin, *m.CreateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateService != nil && afterCreateServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateService at\n%s", m.funcCreateServiceOrigin)
	}

	if !m.CreateServiceMock.invocationsDone() && afterCreateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateServiceMock.expectedInvocations), m.CreateServiceMock.expectedInvocationsOrigin, afterCreateServiceCounter)
	}
}

type mClientMockDeleteClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteClickPipeExpectation
	expectations       []*ClientMockDeleteClickPipeExpectation

	callArgs []*ClientMockDeleteClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteClickPipeExpectation specifies expectation struct of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteClickPipeParams
	paramPtrs          *ClientMockDeleteClickPipeParamPtrs
	expectationOrigins ClientMockDeleteClickPipeExpectationOrigins
	results            *ClientMockDeleteClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteClickPipeParams contains parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockDeleteClickPipeParamPtrs contains pointers to parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockDeleteClickPipeResults contains results of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeResults struct {
	err error
}

// ClientMockDeleteClickPipeOrigins contains origins of expectations of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Optional() *mClientMockDeleteClickPipe {
	mmDeleteClickPipe.optional = true
	return mmDeleteClickPipe
}

// Expect sets up expected params for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by ExpectParams functions")
	}

	mmDeleteClickPipe.defaultExpectation.params = &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteClickPipe.expectations {
		if minimock.Equal(e.params, mmDeleteClickPipe.defaultExpectation.params) {
			mmDeleteClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteClickPipe.defaultExpectation.params)
		}
	}

	return mmDeleteClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmDeleteClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmDeleteClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteClickPipe")
	}

	mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe = f

	return mmDeleteClickPipe
}

// Return sets up results that will be returned by Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Return(err error) *ClientMock {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{mock: mmDeleteClickPipe.mock}
	}
	mmDeleteClickPipe.defaultExpectation.results = &ClientMockDeleteClickPipeResults{err}
	mmDeleteClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteClickPipe.mock
}

// Set uses given function f to mock the Client.DeleteClickPipe method
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (err error)) *ClientMock {
	if mmDeleteClickPipe.defaultExpectation != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.DeleteClickPipe method")
	}

	if len(mmDeleteClickPipe.expectations) > 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.DeleteClickPipe method")
	}

	mmDeleteClickPipe.mock.funcDeleteClickPipe = f
	mmDeleteClickPipe.mock.funcDeleteClickPipeOrigin = minimock.CallerInfo(1)
	return mmDeleteClickPipe.mock
}

// When sets expectation for the Client.DeleteClickPipe which will trigger the result defined by the following
// Then helper
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockDeleteClickPipeExpectation {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	expectation := &ClientMockDeleteClickPipeExpectation{
		mock:               mmDeleteClickPipe.mock,
		params:             &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId},
		expectationOrigins: ClientMockDeleteClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteClickPipe.expectations = append(mmDeleteClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteClickPipeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteClickPipeResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteClickPipe should be invoked
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Times(n uint64) *mClientMockDeleteClickPipe {
	if n == 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Times of ClientMock.DeleteClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteClickPipe.expectedInvocations, n)
	mmDeleteClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteClickPipe
}

func (mmDeleteClickPipe *mClientMockDeleteClickPipe) invocationsDone() bool {
	if len(mmDeleteClickPipe.expectations) == 0 && mmDeleteClickPipe.defaultExpectation == nil && mmDeleteClickPipe.mock.funcDeleteClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.mock.afterDeleteClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteClickPipe implements Client
func (mmDeleteClickPipe *ClientMock) DeleteClickPipe(ctx context.Context, serviceId string, clickPipeId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter, 1)

	mmDeleteClickPipe.t.Helper()

	if mmDeleteClickPipe.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.inspectFuncDeleteClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Lock()
	mmDeleteClickPipe.DeleteClickPipeMock.callArgs = append(mmDeleteClickPipe.DeleteClickPipeMock.callArgs, &mm_params)
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Unlock()

	for _, e := range mmDeleteClickPipe.DeleteClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteClickPipe.t.Fatal("No results are set for the ClientMock.DeleteClickPipe")
		}
		return (*mm_results).err
	}
	if mmDeleteClickPipe.funcDeleteClickPipe != nil {
		return mmDeleteClickPipe.funcDeleteClickPipe(ctx, serviceId, clickPipeId)
	}
	mmDeleteClickPipe.t.Fatalf("Unexpected call to ClientMock.DeleteClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// DeleteClickPipeAfterCounter returns a count of finished ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter)
}

// DeleteClickPipeBeforeCounter returns a count of ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Calls() []*ClientMockDeleteClickPipeParams {
	mmDeleteClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockDeleteClickPipeParams, len(mmDeleteClickPipe.callArgs))
	copy(argCopy, mmDeleteClickPipe.callArgs)

	mmDeleteClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteClickPipeDone returns true if the count of the DeleteClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteClickPipeDone() bool {
	if m.DeleteClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteClickPipeMock.invocationsDone()
}

// MinimockDeleteClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteClickPipeInspect() {
	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteClickPipeCounter := mm_atomic.LoadUint64(&m.afterDeleteClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClickPipeMock.defaultExpectation != nil && afterDeleteClickPipeCounter < 1 {
		if m.DeleteClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s", m.DeleteClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s with params: %#v", m.DeleteClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.DeleteClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClickPipe != nil && afterDeleteClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s", m.funcDeleteClickPipeOrigin)
	}

	if !m.DeleteClickPipeMock.invocationsDone() && afterDeleteClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteClickPipeMock.expectedInvocations), m.DeleteClickPipeMock.expectedInvocationsOrigin, afterDeleteClickPipeCounter)
	}
}

type mClientMockDeleteQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteQueryEndpointExpectation
	expectations       []*ClientMockDeleteQueryEndpointExpectation

	callArgs []*ClientMockDeleteQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteQueryEndpointExpectation specifies expectation struct of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteQueryEndpointParams
	paramPtrs          *ClientMockDeleteQueryEndpointParamPtrs
	expectationOrigins ClientMockDeleteQueryEndpointExpectationOrigins
	results            *ClientMockDeleteQueryEndpointResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteQueryEndpointParams contains parameters of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
}

// ClientMockDeleteQueryEndpointParamPtrs contains pointers to parameters of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
}

// ClientMockDeleteQueryEndpointResults contains results of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointResults struct {
	err error
}

// ClientMockDeleteQueryEndpointOrigins contains origins of expectations of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Optional() *mClientMockDeleteQueryEndpoint {
	mmDeleteQueryEndpoint.optional = true
	return mmDeleteQueryEndpoint
}

// Expect sets up expected params for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Expect(ctx context.Context, serviceID string) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmDeleteQueryEndpoint.defaultExpectation.params = &ClientMockDeleteQueryEndpointParams{ctx, serviceID}
	mmDeleteQueryEndpoint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmDeleteQueryEndpoint.defaultExpectation.params) {
			mmDeleteQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmDeleteQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.params != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Expect")
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteQueryEndpointParamPtrs{}
	}
	mmDeleteQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteQueryEndpoint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.params != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Expect")
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteQueryEndpointParamPtrs{}
	}
	mmDeleteQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID
	mmDeleteQueryEndpoint.defaultExpectation.expectationOrigins.originServiceID = minimock.CallerInfo(1)

	return mmDeleteQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string)) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.inspectFuncDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteQueryEndpoint")
	}

	mmDeleteQueryEndpoint.mock.inspectFuncDeleteQueryEndpoint = f

	return mmDeleteQueryEndpoint
}

// Return sets up results that will be returned by Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Return(err error) *ClientMock {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{mock: mmDeleteQueryEndpoint.mock}
	}
	mmDeleteQueryEndpoint.defaultExpectation.results = &ClientMockDeleteQueryEndpointResults{err}
	mmDeleteQueryEndpoint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteQueryEndpoint.mock
}

// Set uses given function f to mock the Client.DeleteQueryEndpoint method
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Set(f func(ctx context.Context, serviceID string) (err error)) *ClientMock {
	if mmDeleteQueryEndpoint.defaultExpectation != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.DeleteQueryEndpoint method")
	}

	if len(mmDeleteQueryEndpoint.expectations) > 0 {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.DeleteQueryEndpoint method")
	}

	mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint = f
	mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpointOrigin = minimock.CallerInfo(1)
	return mmDeleteQueryEndpoint.mock
}

// When sets expectation for the Client.DeleteQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) When(ctx context.Context, serviceID string) *ClientMockDeleteQueryEndpointExpectation {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockDeleteQueryEndpointExpectation{
		mock:               mmDeleteQueryEndpoint.mock,
		params:             &ClientMockDeleteQueryEndpointParams{ctx, serviceID},
		expectationOrigins: ClientMockDeleteQueryEndpointExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteQueryEndpoint.expectations = append(mmDeleteQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteQueryEndpointExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteQueryEndpointResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteQueryEndpoint should be invoked
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Times(n uint64) *mClientMockDeleteQueryEndpoint {
	if n == 0 {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Times of ClientMock.DeleteQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteQueryEndpoint.expectedInvocations, n)
	mmDeleteQueryEndpoint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteQueryEndpoint
}

func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) invocationsDone() bool {
	if len(mmDeleteQueryEndpoint.expectations) == 0 && mmDeleteQueryEndpoint.defaultExpectation == nil && mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.mock.afterDeleteQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteQueryEndpoint implements Client
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpoint(ctx context.Context, serviceID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteQueryEndpoint.beforeDeleteQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteQueryEndpoint.afterDeleteQueryEndpointCounter, 1)

	mmDeleteQueryEndpoint.t.Helper()

	if mmDeleteQueryEndpoint.inspectFuncDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.inspectFuncDeleteQueryEndpoint(ctx, serviceID)
	}

	mm_params := ClientMockDeleteQueryEndpointParams{ctx, serviceID}

	// Record call args
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.mutex.Lock()
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.callArgs = append(mmDeleteQueryEndpoint.DeleteQueryEndpointMock.callArgs, &mm_params)
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.mutex.Unlock()

	for _, e := range mmDeleteQueryEndpoint.DeleteQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteQueryEndpointParams{ctx, serviceID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameter serviceID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.expectationOrigins.originServiceID, *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteQueryEndpoint.t.Fatal("No results are set for the ClientMock.DeleteQueryEndpoint")
		}
		return (*mm_results).err
	}
	if mmDeleteQueryEndpoint.funcDeleteQueryEndpoint != nil {
		return mmDeleteQueryEndpoint.funcDeleteQueryEndpoint(ctx, serviceID)
	}
	mmDeleteQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.DeleteQueryEndpoint. %v %v", ctx, serviceID)
	return
}

// DeleteQueryEndpointAfterCounter returns a count of finished ClientMock.DeleteQueryEndpoint invocations
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.afterDeleteQueryEndpointCounter)
}

// DeleteQueryEndpointBeforeCounter returns a count of ClientMock.DeleteQueryEndpoint invocations
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.beforeDeleteQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Calls() []*ClientMockDeleteQueryEndpointParams {
	mmDeleteQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockDeleteQueryEndpointParams, len(mmDeleteQueryEndpoint.callArgs))
	copy(argCopy, mmDeleteQueryEndpoint.callArgs)

	mmDeleteQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteQueryEndpointDone returns true if the count of the DeleteQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteQueryEndpointDone() bool {
	if m.DeleteQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteQueryEndpointMock.invocationsDone()
}

// MinimockDeleteQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteQueryEndpointInspect() {
	for _, e := range m.DeleteQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterDeleteQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteQueryEndpointMock.defaultExpectation != nil && afterDeleteQueryEndpointCounter < 1 {
		if m.DeleteQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint at\n%s", m.DeleteQueryEndpointMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint at\n%s with params: %#v", m.DeleteQueryEndpointMock.defaultExpectation.expectationOrigins.origin, *m.DeleteQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteQueryEndpoint != nil && afterDeleteQueryEndpointCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint at\n%s", m.funcDeleteQueryEndpointOrigin)
	}

	if !m.DeleteQueryEndpointMock.invocationsDone() && afterDeleteQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteQueryEndpoint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteQueryEndpointMock.expectedInvocations), m.DeleteQueryEndpointMock.expectedInvocationsOrigin, afterDeleteQueryEndpointCounter)
	}
}

type mClientMockDeleteReversePrivateEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteReversePrivateEndpointExpectation
	expectations       []*ClientMockDeleteReversePrivateEndpointExpectation

	callArgs []*ClientMockDeleteReversePrivateEndpointParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteReversePrivateEndpointExpectation specifies expectation struct of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteReversePrivateEndpointParams
	paramPtrs          *ClientMockDeleteReversePrivateEndpointParamPtrs
	expectationOrigins ClientMockDeleteReversePrivateEndpointExpectationOrigins
	results            *ClientMockDeleteReversePrivateEndpointResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteReversePrivateEndpointParams contains parameters of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointParams struct {
	ctx                      context.Context
	serviceId                string
	reversePrivateEndpointId string
}

// ClientMockDeleteReversePrivateEndpointParamPtrs contains pointers to parameters of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointParamPtrs struct {
	ctx                      *context.Context
	serviceId                *string
	reversePrivateEndpointId *string
}

// ClientMockDeleteReversePrivateEndpointResults contains results of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointResults struct {
	err error
}

// ClientMockDeleteReversePrivateEndpointOrigins contains origins of expectations of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointExpectationOrigins struct {
	origin                         string
	originCtx                      string
	originServiceId                string
	originReversePrivateEndpointId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Optional() *mClientMockDeleteReversePrivateEndpoint {
	mmDeleteReversePrivateEndpoint.optional = true
	return mmDeleteReversePrivateEndpoint
}

// Expect sets up expected params for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Expect(ctx context.Context, serviceId string, reversePrivateEndpointId string) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by ExpectParams functions")
	}

	mmDeleteReversePrivateEndpoint.defaultExpectation.params = &ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}
	mmDeleteReversePrivateEndpoint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteReversePrivateEndpoint.expectations {
		if minimock.Equal(e.params, mmDeleteReversePrivateEndpoint.defaultExpectation.params) {
			mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReversePrivateEndpoint.defaultExpectation.params)
		}
	}

	return mmDeleteReversePrivateEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.params != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Expect")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteReversePrivateEndpointParamPtrs{}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteReversePrivateEndpoint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteReversePrivateEndpoint
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.params != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Expect")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteReversePrivateEndpointParamPtrs{}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmDeleteReversePrivateEndpoint.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmDeleteReversePrivateEndpoint
}

// ExpectReversePrivateEndpointIdParam3 sets up expected param reversePrivateEndpointId for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) ExpectReversePrivateEndpointIdParam3(reversePrivateEndpointId string) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.params != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Expect")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteReversePrivateEndpointParamPtrs{}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId
	mmDeleteReversePrivateEndpoint.defaultExpectation.expectationOrigins.originReversePrivateEndpointId = minimock.CallerInfo(1)

	return mmDeleteReversePrivateEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Inspect(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string)) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.inspectFuncDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteReversePrivateEndpoint")
	}

	mmDeleteReversePrivateEndpoint.mock.inspectFuncDeleteReversePrivateEndpoint = f

	return mmDeleteReversePrivateEndpoint
}

// Return sets up results that will be returned by Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Return(err error) *ClientMock {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{mock: mmDeleteReversePrivateEndpoint.mock}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.results = &ClientMockDeleteReversePrivateEndpointResults{err}
	mmDeleteReversePrivateEndpoint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteReversePrivateEndpoint.mock
}

// Set uses given function f to mock the Client.DeleteReversePrivateEndpoint method
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Set(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (err error)) *ClientMock {
	if mmDeleteReversePrivateEndpoint.defaultExpectation != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.DeleteReversePrivateEndpoint method")
	}

	if len(mmDeleteReversePrivateEndpoint.expectations) > 0 {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.DeleteReversePrivateEndpoint method")
	}

	mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint = f
	mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpointOrigin = minimock.CallerInfo(1)
	return mmDeleteReversePrivateEndpoint.mock
}

// When sets expectation for the Client.DeleteReversePrivateEndpoint which will trigger the result defined by the following
// Then helper
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) When(ctx context.Context, serviceId string, reversePrivateEndpointId string) *ClientMockDeleteReversePrivateEndpointExpectation {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	expectation := &ClientMockDeleteReversePrivateEndpointExpectation{
		mock:               mmDeleteReversePrivateEndpoint.mock,
		params:             &ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId},
		expectationOrigins: ClientMockDeleteReversePrivateEndpointExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteReversePrivateEndpoint.expectations = append(mmDeleteReversePrivateEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteReversePrivateEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteReversePrivateEndpointExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteReversePrivateEndpointResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteReversePrivateEndpoint should be invoked
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Times(n uint64) *mClientMockDeleteReversePrivateEndpoint {
	if n == 0 {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Times of ClientMock.DeleteReversePrivateEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteReversePrivateEndpoint.expectedInvocations, n)
	mmDeleteReversePrivateEndpoint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteReversePrivateEndpoint
}

func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) invocationsDone() bool {
	if len(mmDeleteReversePrivateEndpoint.expectations) == 0 && mmDeleteReversePrivateEndpoint.defaultExpectation == nil && mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.mock.afterDeleteReversePrivateEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteReversePrivateEndpoint implements Client
func (mmDeleteReversePrivateEndpoint *ClientMock) DeleteReversePrivateEndpoint(ctx context.Context, serviceId string, reversePrivateEndpointId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteReversePrivateEndpoint.beforeDeleteReversePrivateEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteReversePrivateEndpoint.afterDeleteReversePrivateEndpointCounter, 1)

	mmDeleteReversePrivateEndpoint.t.Helper()

	if mmDeleteReversePrivateEndpoint.inspectFuncDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.inspectFuncDeleteReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}

	mm_params := ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

	// Record call args
	mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.mutex.Lock()
	mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.callArgs = append(mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.callArgs, &mm_params)
	mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.mutex.Unlock()

	for _, e := range mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameter reversePrivateEndpointId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originReversePrivateEndpointId, *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteReversePrivateEndpoint.t.Fatal("No results are set for the ClientMock.DeleteReversePrivateEndpoint")
		}
		return (*mm_results).err
	}
	if mmDeleteReversePrivateEndpoint.funcDeleteReversePrivateEndpoint != nil {
		return mmDeleteReversePrivateEndpoint.funcDeleteReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}
	mmDeleteReversePrivateEndpoint.t.Fatalf("Unexpected call to ClientMock.DeleteReversePrivateEndpoint. %v %v %v", ctx, serviceId, reversePrivateEndpointId)
	return
}

// DeleteReversePrivateEndpointAfterCounter returns a count of finished ClientMock.DeleteReversePrivateEndpoint invocations
func (mmDeleteReversePrivateEndpoint *ClientMock) DeleteReversePrivateEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.afterDeleteReversePrivateEndpointCounter)
}

// DeleteReversePrivateEndpointBeforeCounter returns a count of ClientMock.DeleteReversePrivateEndpoint invocations
func (mmDeleteReversePrivateEndpoint *ClientMock) DeleteReversePrivateEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.beforeDeleteReversePrivateEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteReversePrivateEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Calls() []*ClientMockDeleteReversePrivateEndpointParams {
	mmDeleteReversePrivateEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockDeleteReversePrivateEndpointParams, len(mmDeleteReversePrivateEndpoint.callArgs))
	copy(argCopy, mmDeleteReversePrivateEndpoint.callArgs)

	mmDeleteReversePrivateEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteReversePrivateEndpointDone returns true if the count of the DeleteReversePrivateEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteReversePrivateEndpointDone() bool {
	if m.DeleteReversePrivateEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteReversePrivateEndpointMock.invocationsDone()
}

// MinimockDeleteReversePrivateEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteReversePrivateEndpointInspect() {
	for _, e := range m.DeleteReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteReversePrivateEndpoint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteReversePrivateEndpointCounter := mm_atomic.LoadUint64(&m.afterDeleteReversePrivateEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReversePrivateEndpointMock.defaultExpectation != nil && afterDeleteReversePrivateEndpointCounter < 1 {
		if m.DeleteReversePrivateEndpointMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteReversePrivateEndpoint at\n%s", m.DeleteReversePrivateEndpointMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteReversePrivateEndpoint at\n%s with params: %#v", m.DeleteReversePrivateEndpointMock.defaultExpectation.expectationOrigins.origin, *m.DeleteReversePrivateEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReversePrivateEndpoint != nil && afterDeleteReversePrivateEndpointCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteReversePrivateEndpoint at\n%s", m.funcDeleteReversePrivateEndpointOrigin)
	}

	if !m.DeleteReversePrivateEndpointMock.invocationsDone() && afterDeleteReversePrivateEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteReversePrivateEndpoint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteReversePrivateEndpointMock.expectedInvocations), m.DeleteReversePrivateEndpointMock.expectedInvocationsOrigin, afterDeleteReversePrivateEndpointCounter)
	}
}

type mClientMockDeleteService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteServiceExpectation
	expectations       []*ClientMockDeleteServiceExpectation

	callArgs []*ClientMockDeleteServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteServiceExpectation specifies expectation struct of the Client.DeleteService
type ClientMockDeleteServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteServiceParams
	paramPtrs          *ClientMockDeleteServiceParamPtrs
	expectationOrigins ClientMockDeleteServiceExpectationOrigins
	results            *ClientMockDeleteServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteServiceParams contains parameters of the Client.DeleteService
type ClientMockDeleteServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockDeleteServiceParamPtrs contains pointers to parameters of the Client.DeleteService
type ClientMockDeleteServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockDeleteServiceResults contains results of the Client.DeleteService
type ClientMockDeleteServiceResults struct {
	sp1 *Service
	err error
}

// ClientMockDeleteServiceOrigins contains origins of expectations of the Client.DeleteService
type ClientMockDeleteServiceExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteService *mClientMockDeleteService) Optional() *mClientMockDeleteService {
	mmDeleteService.optional = true
	return mmDeleteService
}

// Expect sets up expected params for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Expect(ctx context.Context, serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.paramPtrs != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by ExpectParams functions")
	}

	mmDeleteService.defaultExpectation.params = &ClientMockDeleteServiceParams{ctx, serviceId}
	mmDeleteService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteService.expectations {
		if minimock.Equal(e.params, mmDeleteService.defaultExpectation.params) {
			mmDeleteService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteService.defaultExpectation.params)
		}
	}

	return mmDeleteService
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmDeleteService.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmDeleteService
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockDeleteService {
	if mmDeleteService.mock.inspectFuncDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteService")
	}

	mmDeleteService.mock.inspectFuncDeleteService = f

	return mmDeleteService
}

// Return sets up results that will be returned by Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Return(sp1 *Service, err error) *ClientMock {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{mock: mmDeleteService.mock}
	}
	mmDeleteService.defaultExpectation.results = &ClientMockDeleteServiceResults{sp1, err}
	mmDeleteService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteService.mock
}

// Set uses given function f to mock the Client.DeleteService method
func (mmDeleteService *mClientMockDeleteService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmDeleteService.defaultExpectation != nil {
		mmDeleteService.mock.t.Fatalf("Default expectation is already set for the Client.DeleteService method")
	}

	if len(mmDeleteService.expectations) > 0 {
		mmDeleteService.mock.t.Fatalf("Some expectations are already set for the Client.DeleteService method")
	}

	mmDeleteService.mock.funcDeleteService = f
	mmDeleteService.mock.funcDeleteServiceOrigin = minimock.CallerInfo(1)
	return mmDeleteService.mock
}

// When sets expectation for the Client.DeleteService which will trigger the result defined by the following
// Then helper
func (mmDeleteService *mClientMockDeleteService) When(ctx context.Context, serviceId string) *ClientMockDeleteServiceExpectation {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	expectation := &ClientMockDeleteServiceExpectation{
		mock:               mmDeleteService.mock,
		params:             &ClientMockDeleteServiceParams{ctx, serviceId},
		expectationOrigins: ClientMockDeleteServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteService.expectations = append(mmDeleteService.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteService return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockDeleteServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.DeleteService should be invoked
func (mmDeleteService *mClientMockDeleteService) Times(n uint64) *mClientMockDeleteService {
	if n == 0 {
		mmDeleteService.mock.t.Fatalf("Times of ClientMock.DeleteService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteService.expectedInvocations, n)
	mmDeleteService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteService
}

func (mmDeleteService *mClientMockDeleteService) invocationsDone() bool {
	if len(mmDeleteService.expectations) == 0 && mmDeleteService.defaultExpectation == nil && mmDeleteService.mock.funcDeleteService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteService.mock.afterDeleteServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteService implements Client
func (mmDeleteService *ClientMock) DeleteService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmDeleteService.beforeDeleteServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteService.afterDeleteServiceCounter, 1)

	mmDeleteService.t.Helper()

	if mmDeleteService.inspectFuncDeleteService != nil {
		mmDeleteService.inspectFuncDeleteService(ctx, serviceId)
	}

	mm_params := ClientMockDeleteServiceParams{ctx, serviceId}

	// Record call args
	mmDeleteService.DeleteServiceMock.mutex.Lock()
	mmDeleteService.DeleteServiceMock.callArgs = append(mmDeleteService.DeleteServiceMock.callArgs, &mm_params)
	mmDeleteService.DeleteServiceMock.mutex.Unlock()

	for _, e := range mmDeleteService.DeleteServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDeleteService.DeleteServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteService.DeleteServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteService.DeleteServiceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteService.DeleteServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteService.DeleteServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteService.DeleteServiceMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteService.DeleteServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteService.DeleteServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteService.t.Fatal("No results are set for the ClientMock.DeleteService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDeleteService.funcDeleteService != nil {
		return mmDeleteService.funcDeleteService(ctx, serviceId)
	}
	mmDeleteService.t.Fatalf("Unexpected call to ClientMock.DeleteService. %v %v", ctx, serviceId)
	return
}

// DeleteServiceAfterCounter returns a count of finished ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.afterDeleteServiceCounter)
}

// DeleteServiceBeforeCounter returns a count of ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.beforeDeleteServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteService *mClientMockDeleteService) Calls() []*ClientMockDeleteServiceParams {
	mmDeleteService.mutex.RLock()

	argCopy := make([]*ClientMockDeleteServiceParams, len(mmDeleteService.callArgs))
	copy(argCopy, mmDeleteService.callArgs)

	mmDeleteService.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteServiceDone returns true if the count of the DeleteService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteServiceDone() bool {
	if m.DeleteServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteServiceMock.invocationsDone()
}

// MinimockDeleteServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteServiceInspect() {
	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteServiceCounter := mm_atomic.LoadUint64(&m.afterDeleteServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteServiceMock.defaultExpectation != nil && afterDeleteServiceCounter < 1 {
		if m.DeleteServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s", m.DeleteServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s with params: %#v", m.DeleteServiceMock.defaultExpectation.expectationOrigins.origin, *m.DeleteServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteService != nil && afterDeleteServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s", m.funcDeleteServiceOrigin)
	}

	if !m.DeleteServiceMock.invocationsDone() && afterDeleteServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteServiceMock.expectedInvocations), m.DeleteServiceMock.expectedInvocationsOrigin, afterDeleteServiceCounter)
	}
}

type mClientMockGetApiKeyID struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetApiKeyIDExpectation
	expectations       []*ClientMockGetApiKeyIDExpectation

	callArgs []*ClientMockGetApiKeyIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetApiKeyIDExpectation specifies expectation struct of the Client.GetApiKeyID
type ClientMockGetApiKeyIDExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetApiKeyIDParams
	paramPtrs          *ClientMockGetApiKeyIDParamPtrs
	expectationOrigins ClientMockGetApiKeyIDExpectationOrigins
	results            *ClientMockGetApiKeyIDResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetApiKeyIDParams contains parameters of the Client.GetApiKeyID
type ClientMockGetApiKeyIDParams struct {
	ctx  context.Context
	name *string
}

// ClientMockGetApiKeyIDParamPtrs contains pointers to parameters of the Client.GetApiKeyID
type ClientMockGetApiKeyIDParamPtrs struct {
	ctx  *context.Context
	name **string
}

// ClientMockGetApiKeyIDResults contains results of the Client.GetApiKeyID
type ClientMockGetApiKeyIDResults struct {
	ap1 *ApiKey
	err error
}

// ClientMockGetApiKeyIDOrigins contains origins of expectations of the Client.GetApiKeyID
type ClientMockGetApiKeyIDExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApiKeyID *mClientMockGetApiKeyID) Optional() *mClientMockGetApiKeyID {
	mmGetApiKeyID.optional = true
	return mmGetApiKeyID
}

// Expect sets up expected params for Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) Expect(ctx context.Context, name *string) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{}
	}

	if mmGetApiKeyID.defaultExpectation.paramPtrs != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by ExpectParams functions")
	}

	mmGetApiKeyID.defaultExpectation.params = &ClientMockGetApiKeyIDParams{ctx, name}
	mmGetApiKeyID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetApiKeyID.expectations {
		if minimock.Equal(e.params, mmGetApiKeyID.defaultExpectation.params) {
			mmGetApiKeyID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApiKeyID.defaultExpectation.params)
		}
	}

	return mmGetApiKeyID
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) ExpectCtxParam1(ctx context.Context) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{}
	}

	if mmGetApiKeyID.defaultExpectation.params != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Expect")
	}

	if mmGetApiKeyID.defaultExpectation.paramPtrs == nil {
		mmGetApiKeyID.defaultExpectation.paramPtrs = &ClientMockGetApiKeyIDParamPtrs{}
	}
	mmGetApiKeyID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetApiKeyID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetApiKeyID
}

// ExpectNameParam2 sets up expected param name for Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) ExpectNameParam2(name *string) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{}
	}

	if mmGetApiKeyID.defaultExpectation.params != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Expect")
	}

	if mmGetApiKeyID.defaultExpectation.paramPtrs == nil {
		mmGetApiKeyID.defaultExpectation.paramPtrs = &ClientMockGetApiKeyIDParamPtrs{}
	}
	mmGetApiKeyID.defaultExpectation.paramPtrs.name = &name
	mmGetApiKeyID.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetApiKeyID
}

// Inspect accepts an inspector function that has same arguments as the Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) Inspect(f func(ctx context.Context, name *string)) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.inspectFuncGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("Inspect function is already set for ClientMock.GetApiKeyID")
	}

	mmGetApiKeyID.mock.inspectFuncGetApiKeyID = f

	return mmGetApiKeyID
}

// Return sets up results that will be returned by Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) Return(ap1 *ApiKey, err error) *ClientMock {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{mock: mmGetApiKeyID.mock}
	}
	mmGetApiKeyID.defaultExpectation.results = &ClientMockGetApiKeyIDResults{ap1, err}
	mmGetApiKeyID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetApiKeyID.mock
}

// Set uses given function f to mock the Client.GetApiKeyID method
func (mmGetApiKeyID *mClientMockGetApiKeyID) Set(f func(ctx context.Context, name *string) (ap1 *ApiKey, err error)) *ClientMock {
	if mmGetApiKeyID.defaultExpectation != nil {
		mmGetApiKeyID.mock.t.Fatalf("Default expectation is already set for the Client.GetApiKeyID method")
	}

	if len(mmGetApiKeyID.expectations) > 0 {
		mmGetApiKeyID.mock.t.Fatalf("Some expectations are already set for the Client.GetApiKeyID method")
	}

	mmGetApiKeyID.mock.funcGetApiKeyID = f
	mmGetApiKeyID.mock.funcGetApiKeyIDOrigin = minimock.CallerInfo(1)
	return mmGetApiKeyID.mock
}

// When sets expectation for the Client.GetApiKeyID which will trigger the result defined by the following
// Then helper
func (mmGetApiKeyID *mClientMockGetApiKeyID) When(ctx context.Context, name *string) *ClientMockGetApiKeyIDExpectation {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	expectation := &ClientMockGetApiKeyIDExpectation{
		mock:               mmGetApiKeyID.mock,
		params:             &ClientMockGetApiKeyIDParams{ctx, name},
		expectationOrigins: ClientMockGetApiKeyIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetApiKeyID.expectations = append(mmGetApiKeyID.expectations, expectation)
	return expectation
}

// Then sets up Client.GetApiKeyID return parameters for the expectation previously defined by the When method
func (e *ClientMockGetApiKeyIDExpectation) Then(ap1 *ApiKey, err error) *ClientMock {
	e.results = &ClientMockGetApiKeyIDResults{ap1, err}
	return e.mock
}

// Times sets number of times Client.GetApiKeyID should be invoked
func (mmGetApiKeyID *mClientMockGetApiKeyID) Times(n uint64) *mClientMockGetApiKeyID {
	if n == 0 {
		mmGetApiKeyID.mock.t.Fatalf("Times of ClientMock.GetApiKeyID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApiKeyID.expectedInvocations, n)
	mmGetApiKeyID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetApiKeyID
}

func (mmGetApiKeyID *mClientMockGetApiKeyID) invocationsDone() bool {
	if len(mmGetApiKeyID.expectations) == 0 && mmGetApiKeyID.defaultExpectation == nil && mmGetApiKeyID.mock.funcGetApiKeyID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApiKeyID.mock.afterGetApiKeyIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApiKeyID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApiKeyID implements Client
func (mmGetApiKeyID *ClientMock) GetApiKeyID(ctx context.Context, name *string) (ap1 *ApiKey, err error) {
	mm_atomic.AddUint64(&mmGetApiKeyID.beforeGetApiKeyIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApiKeyID.afterGetApiKeyIDCounter, 1)

	mmGetApiKeyID.t.Helper()

	if mmGetApiKeyID.inspectFuncGetApiKeyID != nil {
		mmGetApiKeyID.inspectFuncGetApiKeyID(ctx, name)
	}

	mm_params := ClientMockGetApiKeyIDParams{ctx, name}

	// Record call args
	mmGetApiKeyID.GetApiKeyIDMock.mutex.Lock()
	mmGetApiKeyID.GetApiKeyIDMock.callArgs = append(mmGetApiKeyID.GetApiKeyIDMock.callArgs, &mm_params)
	mmGetApiKeyID.GetApiKeyIDMock.mutex.Unlock()

	for _, e := range mmGetApiKeyID.GetApiKeyIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetApiKeyIDParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApiKeyID.t.Errorf("ClientMock.GetApiKeyID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetApiKeyID.t.Errorf("ClientMock.GetApiKeyID got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApiKeyID.t.Errorf("ClientMock.GetApiKeyID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApiKeyID.t.Fatal("No results are set for the ClientMock.GetApiKeyID")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApiKeyID.funcGetApiKeyID != nil {
		return mmGetApiKeyID.funcGetApiKeyID(ctx, name)
	}
	mmGetApiKeyID.t.Fatalf("Unexpected call to ClientMock.GetApiKeyID. %v %v", ctx, name)
	return
}

// GetApiKeyIDAfterCounter returns a count of finished ClientMock.GetApiKeyID invocations
func (mmGetApiKeyID *ClientMock) GetApiKeyIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApiKeyID.afterGetApiKeyIDCounter)
}

// GetApiKeyIDBeforeCounter returns a count of ClientMock.GetApiKeyID invocations
func (mmGetApiKeyID *ClientMock) GetApiKeyIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApiKeyID.beforeGetApiKeyIDCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetApiKeyID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApiKeyID *mClientMockGetApiKeyID) Calls() []*ClientMockGetApiKeyIDParams {
	mmGetApiKeyID.mutex.RLock()

	argCopy := make([]*ClientMockGetApiKeyIDParams, len(mmGetApiKeyID.callArgs))
	copy(argCopy, mmGetApiKeyID.callArgs)

	mmGetApiKeyID.mutex.RUnlock()

	return argCopy
}

// MinimockGetApiKeyIDDone returns true if the count of the GetApiKeyID invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetApiKeyIDDone() bool {
	if m.GetApiKeyIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApiKeyIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApiKeyIDMock.invocationsDone()
}

// MinimockGetApiKeyIDInspect logs each unmet expectation
func (m *ClientMock) MinimockGetApiKeyIDInspect() {
	for _, e := range m.GetApiKeyIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetApiKeyID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetApiKeyIDCounter := mm_atomic.LoadUint64(&m.afterGetApiKeyIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApiKeyIDMock.defaultExpectation != nil && afterGetApiKeyIDCounter < 1 {
		if m.GetApiKeyIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetApiKeyID at\n%s", m.GetApiKeyIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetApiKeyID at\n%s with params: %#v", m.GetApiKeyIDMock.defaultExpectation.expectationOrigins.origin, *m.GetApiKeyIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApiKeyID != nil && afterGetApiKeyIDCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetApiKeyID at\n%s", m.funcGetApiKeyIDOrigin)
	}

	if !m.GetApiKeyIDMock.invocationsDone() && afterGetApiKeyIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetApiKeyID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetApiKeyIDMock.expectedInvocations), m.GetApiKeyIDMock.expectedInvocationsOrigin, afterGetApiKeyIDCounter)
	}
}

type mClientMockGetBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetBackupConfigurationExpectation
	expectations       []*ClientMockGetBackupConfigurationExpectation

	callArgs []*ClientMockGetBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetBackupConfigurationExpectation specifies expectation struct of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetBackupConfigurationParams
	paramPtrs          *ClientMockGetBackupConfigurationParamPtrs
	expectationOrigins ClientMockGetBackupConfigurationExpectationOrigins
	results            *ClientMockGetBackupConfigurationResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetBackupConfigurationParams contains parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetBackupConfigurationParamPtrs contains pointers to parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetBackupConfigurationResults contains results of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// ClientMockGetBackupConfigurationOrigins contains origins of expectations of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Optional() *mClientMockGetBackupConfiguration {
	mmGetBackupConfiguration.optional = true
	return mmGetBackupConfiguration
}

// Expect sets up expected params for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Expect(ctx context.Context, serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmGetBackupConfiguration.defaultExpectation.params = &ClientMockGetBackupConfigurationParams{ctx, serviceId}
	mmGetBackupConfiguration.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmGetBackupConfiguration.defaultExpectation.params) {
			mmGetBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmGetBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBackupConfiguration.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetBackupConfiguration.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.GetBackupConfiguration")
	}

	mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration = f

	return mmGetBackupConfiguration
}

// Return sets up results that will be returned by Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{mock: mmGetBackupConfiguration.mock}
	}
	mmGetBackupConfiguration.defaultExpectation.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	mmGetBackupConfiguration.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBackupConfiguration.mock
}

// Set uses given function f to mock the Client.GetBackupConfiguration method
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Set(f func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmGetBackupConfiguration.defaultExpectation != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.GetBackupConfiguration method")
	}

	if len(mmGetBackupConfiguration.expectations) > 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.GetBackupConfiguration method")
	}

	mmGetBackupConfiguration.mock.funcGetBackupConfiguration = f
	mmGetBackupConfiguration.mock.funcGetBackupConfigurationOrigin = minimock.CallerInfo(1)
	return mmGetBackupConfiguration.mock
}

// When sets expectation for the Client.GetBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) When(ctx context.Context, serviceId string) *ClientMockGetBackupConfigurationExpectation {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockGetBackupConfigurationExpectation{
		mock:               mmGetBackupConfiguration.mock,
		params:             &ClientMockGetBackupConfigurationParams{ctx, serviceId},
		expectationOrigins: ClientMockGetBackupConfigurationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBackupConfiguration.expectations = append(mmGetBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.GetBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockGetBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.GetBackupConfiguration should be invoked
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Times(n uint64) *mClientMockGetBackupConfiguration {
	if n == 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Times of ClientMock.GetBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBackupConfiguration.expectedInvocations, n)
	mmGetBackupConfiguration.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBackupConfiguration
}

func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) invocationsDone() bool {
	if len(mmGetBackupConfiguration.expectations) == 0 && mmGetBackupConfiguration.defaultExpectation == nil && mmGetBackupConfiguration.mock.funcGetBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.mock.afterGetBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBackupConfiguration implements Client
func (mmGetBackupConfiguration *ClientMock) GetBackupConfiguration(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter, 1)

	mmGetBackupConfiguration.t.Helper()

	if mmGetBackupConfiguration.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.inspectFuncGetBackupConfiguration(ctx, serviceId)
	}

	mm_params := ClientMockGetBackupConfigurationParams{ctx, serviceId}

	// Record call args
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Lock()
	mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs = append(mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs, &mm_params)
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmGetBackupConfiguration.GetBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetBackupConfigurationParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBackupConfiguration.t.Fatal("No results are set for the ClientMock.GetBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBackupConfiguration.funcGetBackupConfiguration != nil {
		return mmGetBackupConfiguration.funcGetBackupConfiguration(ctx, serviceId)
	}
	mmGetBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.GetBackupConfiguration. %v %v", ctx, serviceId)
	return
}

// GetBackupConfigurationAfterCounter returns a count of finished ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter)
}

// GetBackupConfigurationBeforeCounter returns a count of ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Calls() []*ClientMockGetBackupConfigurationParams {
	mmGetBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockGetBackupConfigurationParams, len(mmGetBackupConfiguration.callArgs))
	copy(argCopy, mmGetBackupConfiguration.callArgs)

	mmGetBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockGetBackupConfigurationDone returns true if the count of the GetBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetBackupConfigurationDone() bool {
	if m.GetBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBackupConfigurationMock.invocationsDone()
}

// MinimockGetBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockGetBackupConfigurationInspect() {
	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterGetBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBackupConfigurationMock.defaultExpectation != nil && afterGetBackupConfigurationCounter < 1 {
		if m.GetBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s", m.GetBackupConfigurationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s with params: %#v", m.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *m.GetBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBackupConfiguration != nil && afterGetBackupConfigurationCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s", m.funcGetBackupConfigurationOrigin)
	}

	if !m.GetBackupConfigurationMock.invocationsDone() && afterGetBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetBackupConfiguration at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBackupConfigurationMock.expectedInvocations), m.GetBackupConfigurationMock.expectedInvocationsOrigin, afterGetBackupConfigurationCounter)
	}
}

type mClientMockGetClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetClickPipeExpectation
	expectations       []*ClientMockGetClickPipeExpectation

	callArgs []*ClientMockGetClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetClickPipeExpectation specifies expectation struct of the Client.GetClickPipe
type ClientMockGetClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetClickPipeParams
	paramPtrs          *ClientMockGetClickPipeParamPtrs
	expectationOrigins ClientMockGetClickPipeExpectationOrigins
	results            *ClientMockGetClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetClickPipeParams contains parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockGetClickPipeParamPtrs contains pointers to parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockGetClickPipeResults contains results of the Client.GetClickPipe
type ClientMockGetClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockGetClickPipeOrigins contains origins of expectations of the Client.GetClickPipe
type ClientMockGetClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClickPipe *mClientMockGetClickPipe) Optional() *mClientMockGetClickPipe {
	mmGetClickPipe.optional = true
	return mmGetClickPipe
}

// Expect sets up expected params for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by ExpectParams functions")
	}

	mmGetClickPipe.defaultExpectation.params = &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}
	mmGetClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClickPipe.expectations {
		if minimock.Equal(e.params, mmGetClickPipe.defaultExpectation.params) {
			mmGetClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClickPipe.defaultExpectation.params)
		}
	}

	return mmGetClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmGetClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmGetClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.GetClickPipe")
	}

	mmGetClickPipe.mock.inspectFuncGetClickPipe = f

	return mmGetClickPipe
}

// Return sets up results that will be returned by Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{mock: mmGetClickPipe.mock}
	}
	mmGetClickPipe.defaultExpectation.results = &ClientMockGetClickPipeResults{cp1, err}
	mmGetClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClickPipe.mock
}

// Set uses given function f to mock the Client.GetClickPipe method
func (mmGetClickPipe *mClientMockGetClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmGetClickPipe.defaultExpectation != nil {
		mmGetClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.GetClickPipe method")
	}

	if len(mmGetClickPipe.expectations) > 0 {
		mmGetClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.GetClickPipe method")
	}

	mmGetClickPipe.mock.funcGetClickPipe = f
	mmGetClickPipe.mock.funcGetClickPipeOrigin = minimock.CallerInfo(1)
	return mmGetClickPipe.mock
}

// When sets expectation for the Client.GetClickPipe which will trigger the result defined by the following
// Then helper
func (mmGetClickPipe *mClientMockGetClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockGetClickPipeExpectation {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	expectation := &ClientMockGetClickPipeExpectation{
		mock:               mmGetClickPipe.mock,
		params:             &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId},
		expectationOrigins: ClientMockGetClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClickPipe.expectations = append(mmGetClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.GetClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockGetClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockGetClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.GetClickPipe should be invoked
func (mmGetClickPipe *mClientMockGetClickPipe) Times(n uint64) *mClientMockGetClickPipe {
	if n == 0 {
		mmGetClickPipe.mock.t.Fatalf("Times of ClientMock.GetClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClickPipe.expectedInvocations, n)
	mmGetClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClickPipe
}

func (mmGetClickPipe *mClientMockGetClickPipe) invocationsDone() bool {
	if len(mmGetClickPipe.expectations) == 0 && mmGetClickPipe.defaultExpectation == nil && mmGetClickPipe.mock.funcGetClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.mock.afterGetClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClickPipe implements Client
func (mmGetClickPipe *ClientMock) GetClickPipe(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmGetClickPipe.beforeGetClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClickPipe.afterGetClickPipeCounter, 1)

	mmGetClickPipe.t.Helper()

	if mmGetClickPipe.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.inspectFuncGetClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmGetClickPipe.GetClickPipeMock.mutex.Lock()
	mmGetClickPipe.GetClickPipeMock.callArgs = append(mmGetClickPipe.GetClickPipeMock.callArgs, &mm_params)
	mmGetClickPipe.GetClickPipeMock.mutex.Unlock()

	for _, e := range mmGetClickPipe.GetClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetClickPipe.GetClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClickPipe.GetClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClickPipe.GetClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmGetClickPipe.GetClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClickPipe.GetClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClickPipe.t.Fatal("No results are set for the ClientMock.GetClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetClickPipe.funcGetClickPipe != nil {
		return mmGetClickPipe.funcGetClickPipe(ctx, serviceId, clickPipeId)
	}
	mmGetClickPipe.t.Fatalf("Unexpected call to ClientMock.GetClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// GetClickPipeAfterCounter returns a count of finished ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.afterGetClickPipeCounter)
}

// GetClickPipeBeforeCounter returns a count of ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.beforeGetClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClickPipe *mClientMockGetClickPipe) Calls() []*ClientMockGetClickPipeParams {
	mmGetClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockGetClickPipeParams, len(mmGetClickPipe.callArgs))
	copy(argCopy, mmGetClickPipe.callArgs)

	mmGetClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockGetClickPipeDone returns true if the count of the GetClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetClickPipeDone() bool {
	if m.GetClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClickPipeMock.invocationsDone()
}

// MinimockGetClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetClickPipeInspect() {
	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClickPipeCounter := mm_atomic.LoadUint64(&m.afterGetClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClickPipeMock.defaultExpectation != nil && afterGetClickPipeCounter < 1 {
		if m.GetClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s", m.GetClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s with params: %#v", m.GetClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.GetClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClickPipe != nil && afterGetClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s", m.funcGetClickPipeOrigin)
	}

	if !m.GetClickPipeMock.invocationsDone() && afterGetClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClickPipeMock.expectedInvocations), m.GetClickPipeMock.expectedInvocationsOrigin, afterGetClickPipeCounter)
	}
}

type mClientMockGetOrgPrivateEndpointConfig struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrgPrivateEndpointConfigExpectation
	expectations       []*ClientMockGetOrgPrivateEndpointConfigExpectation

	callArgs []*ClientMockGetOrgPrivateEndpointConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetOrgPrivateEndpointConfigExpectation specifies expectation struct of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetOrgPrivateEndpointConfigParams
	paramPtrs          *ClientMockGetOrgPrivateEndpointConfigParamPtrs
	expectationOrigins ClientMockGetOrgPrivateEndpointConfigExpectationOrigins
	results            *ClientMockGetOrgPrivateEndpointConfigResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetOrgPrivateEndpointConfigParams contains parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParams struct {
	ctx           context.Context
	cloudProvider string
	region        string
}

// ClientMockGetOrgPrivateEndpointConfigParamPtrs contains pointers to parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParamPtrs struct {
	ctx           *context.Context
	cloudProvider *string
	region        *string
}

// ClientMockGetOrgPrivateEndpointConfigResults contains results of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigResults struct {
	op1 *OrgPrivateEndpointConfig
	err error
}

// ClientMockGetOrgPrivateEndpointConfigOrigins contains origins of expectations of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectationOrigins struct {
	origin              string
	originCtx           string
	originCloudProvider string
	originRegion        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Optional() *mClientMockGetOrgPrivateEndpointConfig {
	mmGetOrgPrivateEndpointConfig.optional = true
	return mmGetOrgPrivateEndpointConfig
}

// Expect sets up expected params for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Expect(ctx context.Context, cloudProvider string, region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by ExpectParams functions")
	}

	mmGetOrgPrivateEndpointConfig.defaultExpectation.params = &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrgPrivateEndpointConfig.expectations {
		if minimock.Equal(e.params, mmGetOrgPrivateEndpointConfig.defaultExpectation.params) {
			mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrgPrivateEndpointConfig.defaultExpectation.params)
		}
	}

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCloudProviderParam2 sets up expected param cloudProvider for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCloudProviderParam2(cloudProvider string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.cloudProvider = &cloudProvider
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.originCloudProvider = minimock.CallerInfo(1)

	return mmGetOrgPrivateEndpointConfig
}

// ExpectRegionParam3 sets up expected param region for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectRegionParam3(region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.region = &region
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.originRegion = minimock.CallerInfo(1)

	return mmGetOrgPrivateEndpointConfig
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Inspect(f func(ctx context.Context, cloudProvider string, region string)) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrgPrivateEndpointConfig")
	}

	mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig = f

	return mmGetOrgPrivateEndpointConfig
}

// Return sets up results that will be returned by Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Return(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{mock: mmGetOrgPrivateEndpointConfig.mock}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrgPrivateEndpointConfig.mock
}

// Set uses given function f to mock the Client.GetOrgPrivateEndpointConfig method
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Set(f func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.defaultExpectation != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Default expectation is already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	if len(mmGetOrgPrivateEndpointConfig.expectations) > 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Some expectations are already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig = f
	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfigOrigin = minimock.CallerInfo(1)
	return mmGetOrgPrivateEndpointConfig.mock
}

// When sets expectation for the Client.GetOrgPrivateEndpointConfig which will trigger the result defined by the following
// Then helper
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) When(ctx context.Context, cloudProvider string, region string) *ClientMockGetOrgPrivateEndpointConfigExpectation {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	expectation := &ClientMockGetOrgPrivateEndpointConfigExpectation{
		mock:               mmGetOrgPrivateEndpointConfig.mock,
		params:             &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region},
		expectationOrigins: ClientMockGetOrgPrivateEndpointConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrgPrivateEndpointConfig.expectations = append(mmGetOrgPrivateEndpointConfig.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrgPrivateEndpointConfig return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrgPrivateEndpointConfigExpectation) Then(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	e.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return e.mock
}

// Times sets number of times Client.GetOrgPrivateEndpointConfig should be invoked
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Times(n uint64) *mClientMockGetOrgPrivateEndpointConfig {
	if n == 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Times of ClientMock.GetOrgPrivateEndpointConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations, n)
	mmGetOrgPrivateEndpointConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrgPrivateEndpointConfig
}

func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) invocationsDone() bool {
	if len(mmGetOrgPrivateEndpointConfig.expectations) == 0 && mmGetOrgPrivateEndpointConfig.defaultExpectation == nil && mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.mock.afterGetOrgPrivateEndpointConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrgPrivateEndpointConfig implements Client
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfig(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error) {
	mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter, 1)

	mmGetOrgPrivateEndpointConfig.t.Helper()

	if mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}

	mm_params := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

	// Record call args
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Lock()
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs = append(mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs, &mm_params)
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Unlock()

	for _, e := range mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cloudProvider != nil && !minimock.Equal(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter cloudProvider, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.originCloudProvider, *mm_want_ptrs.cloudProvider, mm_got.cloudProvider, minimock.Diff(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider))
			}

			if mm_want_ptrs.region != nil && !minimock.Equal(*mm_want_ptrs.region, mm_got.region) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter region, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.originRegion, *mm_want_ptrs.region, mm_got.region, minimock.Diff(*mm_want_ptrs.region, mm_got.region))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrgPrivateEndpointConfig.t.Fatal("No results are set for the ClientMock.GetOrgPrivateEndpointConfig")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig != nil {
		return mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}
	mmGetOrgPrivateEndpointConfig.t.Fatalf("Unexpected call to ClientMock.GetOrgPrivateEndpointConfig. %v %v %v", ctx, cloudProvider, region)
	return
}

// GetOrgPrivateEndpointConfigAfterCounter returns a count of finished ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter)
}

// GetOrgPrivateEndpointConfigBeforeCounter returns a count of ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrgPrivateEndpointConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Calls() []*ClientMockGetOrgPrivateEndpointConfigParams {
	mmGetOrgPrivateEndpointConfig.mutex.RLock()

	argCopy := make([]*ClientMockGetOrgPrivateEndpointConfigParams, len(mmGetOrgPrivateEndpointConfig.callArgs))
	copy(argCopy, mmGetOrgPrivateEndpointConfig.callArgs)

	mmGetOrgPrivateEndpointConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrgPrivateEndpointConfigDone returns true if the count of the GetOrgPrivateEndpointConfig invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigDone() bool {
	if m.GetOrgPrivateEndpointConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrgPrivateEndpointConfigMock.invocationsDone()
}

// MinimockGetOrgPrivateEndpointConfigInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigInspect() {
	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrgPrivateEndpointConfigCounter := mm_atomic.LoadUint64(&m.afterGetOrgPrivateEndpointConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		if m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s", m.GetOrgPrivateEndpointConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s with params: %#v", m.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrgPrivateEndpointConfig != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s", m.funcGetOrgPrivateEndpointConfigOrigin)
	}

	if !m.GetOrgPrivateEndpointConfigMock.invocationsDone() && afterGetOrgPrivateEndpointConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrgPrivateEndpointConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrgPrivateEndpointConfigMock.expectedInvocations), m.GetOrgPrivateEndpointConfigMock.expectedInvocationsOrigin, afterGetOrgPrivateEndpointConfigCounter)
	}
}

type mClientMockGetOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockGetOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockGetOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetOrganizationPrivateEndpointsParams
	paramPtrs          *ClientMockGetOrganizationPrivateEndpointsParamPtrs
	expectationOrigins ClientMockGetOrganizationPrivateEndpointsExpectationOrigins
	results            *ClientMockGetOrganizationPrivateEndpointsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetOrganizationPrivateEndpointsParams contains parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParams struct {
	ctx context.Context
}

// ClientMockGetOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParamPtrs struct {
	ctx *context.Context
}

// ClientMockGetOrganizationPrivateEndpointsResults contains results of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// ClientMockGetOrganizationPrivateEndpointsOrigins contains origins of expectations of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Optional() *mClientMockGetOrganizationPrivateEndpoints {
	mmGetOrganizationPrivateEndpoints.optional = true
	return mmGetOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Expect(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmGetOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockGetOrganizationPrivateEndpointsParams{ctx}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmGetOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmGetOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockGetOrganizationPrivateEndpointsParamPtrs{}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context)) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrganizationPrivateEndpoints")
	}

	mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints = f

	return mmGetOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{mock: mmGetOrganizationPrivateEndpoints.mock}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.GetOrganizationPrivateEndpoints method
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Set(f func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	if len(mmGetOrganizationPrivateEndpoints.expectations) > 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints = f
	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpointsOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.GetOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) When(ctx context.Context) *ClientMockGetOrganizationPrivateEndpointsExpectation {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockGetOrganizationPrivateEndpointsExpectation{
		mock:               mmGetOrganizationPrivateEndpoints.mock,
		params:             &ClientMockGetOrganizationPrivateEndpointsParams{ctx},
		expectationOrigins: ClientMockGetOrganizationPrivateEndpointsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrganizationPrivateEndpoints.expectations = append(mmGetOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.GetOrganizationPrivateEndpoints should be invoked
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Times(n uint64) *mClientMockGetOrganizationPrivateEndpoints {
	if n == 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.GetOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations, n)
	mmGetOrganizationPrivateEndpoints.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationPrivateEndpoints
}

func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmGetOrganizationPrivateEndpoints.expectations) == 0 && mmGetOrganizationPrivateEndpoints.defaultExpectation == nil && mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.mock.afterGetOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationPrivateEndpoints implements Client
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpoints(ctx context.Context) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter, 1)

	mmGetOrganizationPrivateEndpoints.t.Helper()

	if mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints(ctx)
	}

	mm_params := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

	// Record call args
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Lock()
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs = append(mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.GetOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints != nil {
		return mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints(ctx)
	}
	mmGetOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.GetOrganizationPrivateEndpoints. %v", ctx)
	return
}

// GetOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter)
}

// GetOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Calls() []*ClientMockGetOrganizationPrivateEndpointsParams {
	mmGetOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockGetOrganizationPrivateEndpointsParams, len(mmGetOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmGetOrganizationPrivateEndpoints.callArgs)

	mmGetOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationPrivateEndpointsDone returns true if the count of the GetOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsDone() bool {
	if m.GetOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockGetOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsInspect() {
	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		if m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s", m.GetOrganizationPrivateEndpointsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s with params: %#v", m.GetOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationPrivateEndpoints != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s", m.funcGetOrganizationPrivateEndpointsOrigin)
	}

	if !m.GetOrganizationPrivateEndpointsMock.invocationsDone() && afterGetOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrganizationPrivateEndpoints at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationPrivateEndpointsMock.expectedInvocations), m.GetOrganizationPrivateEndpointsMock.expectedInvocationsOrigin, afterGetOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockGetQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetQueryEndpointExpectation
	expectations       []*ClientMockGetQueryEndpointExpectation

	callArgs []*ClientMockGetQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetQueryEndpointExpectation specifies expectation struct of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetQueryEndpointParams
	paramPtrs          *ClientMockGetQueryEndpointParamPtrs
	expectationOrigins ClientMockGetQueryEndpointExpectationOrigins
	results            *ClientMockGetQueryEndpointResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetQueryEndpointParams contains parameters of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
}

// ClientMockGetQueryEndpointParamPtrs contains pointers to parameters of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
}

// ClientMockGetQueryEndpointResults contains results of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointResults struct {
	sp1 *ServiceQueryEndpoint
	err error
}

// ClientMockGetQueryEndpointOrigins contains origins of expectations of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Optional() *mClientMockGetQueryEndpoint {
	mmGetQueryEndpoint.optional = true
	return mmGetQueryEndpoint
}

// Expect sets up expected params for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Expect(ctx context.Context, serviceID string) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmGetQueryEndpoint.defaultExpectation.params = &ClientMockGetQueryEndpointParams{ctx, serviceID}
	mmGetQueryEndpoint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmGetQueryEndpoint.defaultExpectation.params) {
			mmGetQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmGetQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.params != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Expect")
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockGetQueryEndpointParamPtrs{}
	}
	mmGetQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetQueryEndpoint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.params != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Expect")
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockGetQueryEndpointParamPtrs{}
	}
	mmGetQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID
	mmGetQueryEndpoint.defaultExpectation.expectationOrigins.originServiceID = minimock.CallerInfo(1)

	return mmGetQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string)) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.inspectFuncGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.GetQueryEndpoint")
	}

	mmGetQueryEndpoint.mock.inspectFuncGetQueryEndpoint = f

	return mmGetQueryEndpoint
}

// Return sets up results that will be returned by Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Return(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{mock: mmGetQueryEndpoint.mock}
	}
	mmGetQueryEndpoint.defaultExpectation.results = &ClientMockGetQueryEndpointResults{sp1, err}
	mmGetQueryEndpoint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetQueryEndpoint.mock
}

// Set uses given function f to mock the Client.GetQueryEndpoint method
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Set(f func(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error)) *ClientMock {
	if mmGetQueryEndpoint.defaultExpectation != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.GetQueryEndpoint method")
	}

	if len(mmGetQueryEndpoint.expectations) > 0 {
		mmGetQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.GetQueryEndpoint method")
	}

	mmGetQueryEndpoint.mock.funcGetQueryEndpoint = f
	mmGetQueryEndpoint.mock.funcGetQueryEndpointOrigin = minimock.CallerInfo(1)
	return mmGetQueryEndpoint.mock
}

// When sets expectation for the Client.GetQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) When(ctx context.Context, serviceID string) *ClientMockGetQueryEndpointExpectation {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockGetQueryEndpointExpectation{
		mock:               mmGetQueryEndpoint.mock,
		params:             &ClientMockGetQueryEndpointParams{ctx, serviceID},
		expectationOrigins: ClientMockGetQueryEndpointExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetQueryEndpoint.expectations = append(mmGetQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.GetQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockGetQueryEndpointExpectation) Then(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetQueryEndpointResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetQueryEndpoint should be invoked
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Times(n uint64) *mClientMockGetQueryEndpoint {
	if n == 0 {
		mmGetQueryEndpoint.mock.t.Fatalf("Times of ClientMock.GetQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetQueryEndpoint.expectedInvocations, n)
	mmGetQueryEndpoint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetQueryEndpoint
}

func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) invocationsDone() bool {
	if len(mmGetQueryEndpoint.expectations) == 0 && mmGetQueryEndpoint.defaultExpectation == nil && mmGetQueryEndpoint.mock.funcGetQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetQueryEndpoint.mock.afterGetQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetQueryEndpoint implements Client
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpoint(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetQueryEndpoint.beforeGetQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmGetQueryEndpoint.afterGetQueryEndpointCounter, 1)

	mmGetQueryEndpoint.t.Helper()

	if mmGetQueryEndpoint.inspectFuncGetQueryEndpoint != nil {
		mmGetQueryEndpoint.inspectFuncGetQueryEndpoint(ctx, serviceID)
	}

	mm_params := ClientMockGetQueryEndpointParams{ctx, serviceID}

	// Record call args
	mmGetQueryEndpoint.GetQueryEndpointMock.mutex.Lock()
	mmGetQueryEndpoint.GetQueryEndpointMock.callArgs = append(mmGetQueryEndpoint.GetQueryEndpointMock.callArgs, &mm_params)
	mmGetQueryEndpoint.GetQueryEndpointMock.mutex.Unlock()

	for _, e := range mmGetQueryEndpoint.GetQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetQueryEndpointParams{ctx, serviceID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameter serviceID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.expectationOrigins.originServiceID, *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmGetQueryEndpoint.t.Fatal("No results are set for the ClientMock.GetQueryEndpoint")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetQueryEndpoint.funcGetQueryEndpoint != nil {
		return mmGetQueryEndpoint.funcGetQueryEndpoint(ctx, serviceID)
	}
	mmGetQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.GetQueryEndpoint. %v %v", ctx, serviceID)
	return
}

// GetQueryEndpointAfterCounter returns a count of finished ClientMock.GetQueryEndpoint invocations
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQueryEndpoint.afterGetQueryEndpointCounter)
}

// GetQueryEndpointBeforeCounter returns a count of ClientMock.GetQueryEndpoint invocations
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQueryEndpoint.beforeGetQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Calls() []*ClientMockGetQueryEndpointParams {
	mmGetQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockGetQueryEndpointParams, len(mmGetQueryEndpoint.callArgs))
	copy(argCopy, mmGetQueryEndpoint.callArgs)

	mmGetQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockGetQueryEndpointDone returns true if the count of the GetQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetQueryEndpointDone() bool {
	if m.GetQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetQueryEndpointMock.invocationsDone()
}

// MinimockGetQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockGetQueryEndpointInspect() {
	for _, e := range m.GetQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterGetQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetQueryEndpointMock.defaultExpectation != nil && afterGetQueryEndpointCounter < 1 {
		if m.GetQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint at\n%s", m.GetQueryEndpointMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint at\n%s with params: %#v", m.GetQueryEndpointMock.defaultExpectation.expectationOrigins.origin, *m.GetQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQueryEndpoint != nil && afterGetQueryEndpointCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint at\n%s", m.funcGetQueryEndpointOrigin)
	}

	if !m.GetQueryEndpointMock.invocationsDone() && afterGetQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetQueryEndpoint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetQueryEndpointMock.expectedInvocations), m.GetQueryEndpointMock.expectedInvocationsOrigin, afterGetQueryEndpointCounter)
	}
}

type mClientMockGetReversePrivateEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetReversePrivateEndpointExpectation
	expectations       []*ClientMockGetReversePrivateEndpointExpectation

	callArgs []*ClientMockGetReversePrivateEndpointParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetReversePrivateEndpointExpectation specifies expectation struct of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetReversePrivateEndpointParams
	paramPtrs          *ClientMockGetReversePrivateEndpointParamPtrs
	expectationOrigins ClientMockGetReversePrivateEndpointExpectationOrigins
	results            *ClientMockGetReversePrivateEndpointResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetReversePrivateEndpointParams contains parameters of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointParams struct {
	ctx                      context.Context
	serviceId                string
	reversePrivateEndpointId string
}

// ClientMockGetReversePrivateEndpointParamPtrs contains pointers to parameters of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointParamPtrs struct {
	ctx                      *context.Context
	serviceId                *string
	reversePrivateEndpointId *string
}

// ClientMockGetReversePrivateEndpointResults contains results of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointResults struct {
	rp1 *ReversePrivateEndpoint
	err error
}

// ClientMockGetReversePrivateEndpointOrigins contains origins of expectations of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointExpectationOrigins struct {
	origin                         string
	originCtx                      string
	originServiceId                string
	originReversePrivateEndpointId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Optional() *mClientMockGetReversePrivateEndpoint {
	mmGetReversePrivateEndpoint.optional = true
	return mmGetReversePrivateEndpoint
}

// Expect sets up expected params for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Expect(ctx context.Context, serviceId string, reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by ExpectParams functions")
	}

	mmGetReversePrivateEndpoint.defaultExpectation.params = &ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}
	mmGetReversePrivateEndpoint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReversePrivateEndpoint.expectations {
		if minimock.Equal(e.params, mmGetReversePrivateEndpoint.defaultExpectation.params) {
			mmGetReversePrivateEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReversePrivateEndpoint.defaultExpectation.params)
		}
	}

	return mmGetReversePrivateEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.params != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Expect")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointParamPtrs{}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReversePrivateEndpoint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReversePrivateEndpoint
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) ExpectServiceIdParam2(serviceId string) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.params != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Expect")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointParamPtrs{}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetReversePrivateEndpoint.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetReversePrivateEndpoint
}

// ExpectReversePrivateEndpointIdParam3 sets up expected param reversePrivateEndpointId for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) ExpectReversePrivateEndpointIdParam3(reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.params != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Expect")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointParamPtrs{}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId
	mmGetReversePrivateEndpoint.defaultExpectation.expectationOrigins.originReversePrivateEndpointId = minimock.CallerInfo(1)

	return mmGetReversePrivateEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Inspect(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string)) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.inspectFuncGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.GetReversePrivateEndpoint")
	}

	mmGetReversePrivateEndpoint.mock.inspectFuncGetReversePrivateEndpoint = f

	return mmGetReversePrivateEndpoint
}

// Return sets up results that will be returned by Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Return(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{mock: mmGetReversePrivateEndpoint.mock}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.results = &ClientMockGetReversePrivateEndpointResults{rp1, err}
	mmGetReversePrivateEndpoint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReversePrivateEndpoint.mock
}

// Set uses given function f to mock the Client.GetReversePrivateEndpoint method
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Set(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (rp1 *ReversePrivateEndpoint, err error)) *ClientMock {
	if mmGetReversePrivateEndpoint.defaultExpectation != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.GetReversePrivateEndpoint method")
	}

	if len(mmGetReversePrivateEndpoint.expectations) > 0 {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.GetReversePrivateEndpoint method")
	}

	mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint = f
	mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpointOrigin = minimock.CallerInfo(1)
	return mmGetReversePrivateEndpoint.mock
}

// When sets expectation for the Client.GetReversePrivateEndpoint which will trigger the result defined by the following
// Then helper
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) When(ctx context.Context, serviceId string, reversePrivateEndpointId string) *ClientMockGetReversePrivateEndpointExpectation {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	expectation := &ClientMockGetReversePrivateEndpointExpectation{
		mock:               mmGetReversePrivateEndpoint.mock,
		params:             &ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId},
		expectationOrigins: ClientMockGetReversePrivateEndpointExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReversePrivateEndpoint.expectations = append(mmGetReversePrivateEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.GetReversePrivateEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockGetReversePrivateEndpointExpectation) Then(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetReversePrivateEndpointResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.GetReversePrivateEndpoint should be invoked
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Times(n uint64) *mClientMockGetReversePrivateEndpoint {
	if n == 0 {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Times of ClientMock.GetReversePrivateEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReversePrivateEndpoint.expectedInvocations, n)
	mmGetReversePrivateEndpoint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReversePrivateEndpoint
}

func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) invocationsDone() bool {
	if len(mmGetReversePrivateEndpoint.expectations) == 0 && mmGetReversePrivateEndpoint.defaultExpectation == nil && mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.mock.afterGetReversePrivateEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReversePrivateEndpoint implements Client
func (mmGetReversePrivateEndpoint *ClientMock) GetReversePrivateEndpoint(ctx context.Context, serviceId string, reversePrivateEndpointId string) (rp1 *ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetReversePrivateEndpoint.beforeGetReversePrivateEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReversePrivateEndpoint.afterGetReversePrivateEndpointCounter, 1)

	mmGetReversePrivateEndpoint.t.Helper()

	if mmGetReversePrivateEndpoint.inspectFuncGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.inspectFuncGetReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}

	mm_params := ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

	// Record call args
	mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.mutex.Lock()
	mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.callArgs = append(mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.callArgs, &mm_params)
	mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.mutex.Unlock()

	for _, e := range mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameter reversePrivateEndpointId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.expectationOrigins.originReversePrivateEndpointId, *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReversePrivateEndpoint.t.Fatal("No results are set for the ClientMock.GetReversePrivateEndpoint")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetReversePrivateEndpoint.funcGetReversePrivateEndpoint != nil {
		return mmGetReversePrivateEndpoint.funcGetReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}
	mmGetReversePrivateEndpoint.t.Fatalf("Unexpected call to ClientMock.GetReversePrivateEndpoint. %v %v %v", ctx, serviceId, reversePrivateEndpointId)
	return
}

// GetReversePrivateEndpointAfterCounter returns a count of finished ClientMock.GetReversePrivateEndpoint invocations
func (mmGetReversePrivateEndpoint *ClientMock) GetReversePrivateEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.afterGetReversePrivateEndpointCounter)
}

// GetReversePrivateEndpointBeforeCounter returns a count of ClientMock.GetReversePrivateEndpoint invocations
func (mmGetReversePrivateEndpoint *ClientMock) GetReversePrivateEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.beforeGetReversePrivateEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetReversePrivateEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Calls() []*ClientMockGetReversePrivateEndpointParams {
	mmGetReversePrivateEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockGetReversePrivateEndpointParams, len(mmGetReversePrivateEndpoint.callArgs))
	copy(argCopy, mmGetReversePrivateEndpoint.callArgs)

	mmGetReversePrivateEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockGetReversePrivateEndpointDone returns true if the count of the GetReversePrivateEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetReversePrivateEndpointDone() bool {
	if m.GetReversePrivateEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReversePrivateEndpointMock.invocationsDone()
}

// MinimockGetReversePrivateEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockGetReversePrivateEndpointInspect() {
	for _, e := range m.GetReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpoint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReversePrivateEndpointCounter := mm_atomic.LoadUint64(&m.afterGetReversePrivateEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReversePrivateEndpointMock.defaultExpectation != nil && afterGetReversePrivateEndpointCounter < 1 {
		if m.GetReversePrivateEndpointMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpoint at\n%s", m.GetReversePrivateEndpointMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpoint at\n%s with params: %#v", m.GetReversePrivateEndpointMock.defaultExpectation.expectationOrigins.origin, *m.GetReversePrivateEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReversePrivateEndpoint != nil && afterGetReversePrivateEndpointCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpoint at\n%s", m.funcGetReversePrivateEndpointOrigin)
	}

	if !m.GetReversePrivateEndpointMock.invocationsDone() && afterGetReversePrivateEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetReversePrivateEndpoint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReversePrivateEndpointMock.expectedInvocations), m.GetReversePrivateEndpointMock.expectedInvocationsOrigin, afterGetReversePrivateEndpointCounter)
	}
}

type mClientMockGetReversePrivateEndpointPath struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetReversePrivateEndpointPathExpectation
	expectations       []*ClientMockGetReversePrivateEndpointPathExpectation

	callArgs []*ClientMockGetReversePrivateEndpointPathParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetReversePrivateEndpointPathExpectation specifies expectation struct of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetReversePrivateEndpointPathParams
	paramPtrs          *ClientMockGetReversePrivateEndpointPathParamPtrs
	expectationOrigins ClientMockGetReversePrivateEndpointPathExpectationOrigins
	results            *ClientMockGetReversePrivateEndpointPathResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetReversePrivateEndpointPathParams contains parameters of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathParams struct {
	serviceId                string
	reversePrivateEndpointId string
}

// ClientMockGetReversePrivateEndpointPathParamPtrs contains pointers to parameters of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathParamPtrs struct {
	serviceId                *string
	reversePrivateEndpointId *string
}

// ClientMockGetReversePrivateEndpointPathResults contains results of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathResults struct {
	s1 string
}

// ClientMockGetReversePrivateEndpointPathOrigins contains origins of expectations of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathExpectationOrigins struct {
	origin                         string
	originServiceId                string
	originReversePrivateEndpointId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Optional() *mClientMockGetReversePrivateEndpointPath {
	mmGetReversePrivateEndpointPath.optional = true
	return mmGetReversePrivateEndpointPath
}

// Expect sets up expected params for Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Expect(serviceId string, reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{}
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by ExpectParams functions")
	}

	mmGetReversePrivateEndpointPath.defaultExpectation.params = &ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId}
	mmGetReversePrivateEndpointPath.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReversePrivateEndpointPath.expectations {
		if minimock.Equal(e.params, mmGetReversePrivateEndpointPath.defaultExpectation.params) {
			mmGetReversePrivateEndpointPath.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReversePrivateEndpointPath.defaultExpectation.params)
		}
	}

	return mmGetReversePrivateEndpointPath
}

// ExpectServiceIdParam1 sets up expected param serviceId for Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) ExpectServiceIdParam1(serviceId string) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{}
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.params != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Expect")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointPathParamPtrs{}
	}
	mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetReversePrivateEndpointPath.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetReversePrivateEndpointPath
}

// ExpectReversePrivateEndpointIdParam2 sets up expected param reversePrivateEndpointId for Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) ExpectReversePrivateEndpointIdParam2(reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{}
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.params != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Expect")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointPathParamPtrs{}
	}
	mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId
	mmGetReversePrivateEndpointPath.defaultExpectation.expectationOrigins.originReversePrivateEndpointId = minimock.CallerInfo(1)

	return mmGetReversePrivateEndpointPath
}

// Inspect accepts an inspector function that has same arguments as the Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Inspect(f func(serviceId string, reversePrivateEndpointId string)) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.inspectFuncGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Inspect function is already set for ClientMock.GetReversePrivateEndpointPath")
	}

	mmGetReversePrivateEndpointPath.mock.inspectFuncGetReversePrivateEndpointPath = f

	return mmGetReversePrivateEndpointPath
}

// Return sets up results that will be returned by Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Return(s1 string) *ClientMock {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{mock: mmGetReversePrivateEndpointPath.mock}
	}
	mmGetReversePrivateEndpointPath.defaultExpectation.results = &ClientMockGetReversePrivateEndpointPathResults{s1}
	mmGetReversePrivateEndpointPath.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReversePrivateEndpointPath.mock
}

// Set uses given function f to mock the Client.GetReversePrivateEndpointPath method
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Set(f func(serviceId string, reversePrivateEndpointId string) (s1 string)) *ClientMock {
	if mmGetReversePrivateEndpointPath.defaultExpectation != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Default expectation is already set for the Client.GetReversePrivateEndpointPath method")
	}

	if len(mmGetReversePrivateEndpointPath.expectations) > 0 {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Some expectations are already set for the Client.GetReversePrivateEndpointPath method")
	}

	mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath = f
	mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPathOrigin = minimock.CallerInfo(1)
	return mmGetReversePrivateEndpointPath.mock
}

// When sets expectation for the Client.GetReversePrivateEndpointPath which will trigger the result defined by the following
// Then helper
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) When(serviceId string, reversePrivateEndpointId string) *ClientMockGetReversePrivateEndpointPathExpectation {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	expectation := &ClientMockGetReversePrivateEndpointPathExpectation{
		mock:               mmGetReversePrivateEndpointPath.mock,
		params:             &ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId},
		expectationOrigins: ClientMockGetReversePrivateEndpointPathExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReversePrivateEndpointPath.expectations = append(mmGetReversePrivateEndpointPath.expectations, expectation)
	return expectation
}

// Then sets up Client.GetReversePrivateEndpointPath return parameters for the expectation previously defined by the When method
func (e *ClientMockGetReversePrivateEndpointPathExpectation) Then(s1 string) *ClientMock {
	e.results = &ClientMockGetReversePrivateEndpointPathResults{s1}
	return e.mock
}

// Times sets number of times Client.GetReversePrivateEndpointPath should be invoked
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Times(n uint64) *mClientMockGetReversePrivateEndpointPath {
	if n == 0 {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Times of ClientMock.GetReversePrivateEndpointPath mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReversePrivateEndpointPath.expectedInvocations, n)
	mmGetReversePrivateEndpointPath.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReversePrivateEndpointPath
}

func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) invocationsDone() bool {
	if len(mmGetReversePrivateEndpointPath.expectations) == 0 && mmGetReversePrivateEndpointPath.defaultExpectation == nil && mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.mock.afterGetReversePrivateEndpointPathCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReversePrivateEndpointPath implements Client
func (mmGetReversePrivateEndpointPath *ClientMock) GetReversePrivateEndpointPath(serviceId string, reversePrivateEndpointId string) (s1 string) {
	mm_atomic.AddUint64(&mmGetReversePrivateEndpointPath.beforeGetReversePrivateEndpointPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReversePrivateEndpointPath.afterGetReversePrivateEndpointPathCounter, 1)

	mmGetReversePrivateEndpointPath.t.Helper()

	if mmGetReversePrivateEndpointPath.inspectFuncGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.inspectFuncGetReversePrivateEndpointPath(serviceId, reversePrivateEndpointId)
	}

	mm_params := ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId}

	// Record call args
	mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.mutex.Lock()
	mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.callArgs = append(mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.callArgs, &mm_params)
	mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.mutex.Unlock()

	for _, e := range mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.params
		mm_want_ptrs := mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetReversePrivateEndpointPath.t.Errorf("ClientMock.GetReversePrivateEndpointPath got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmGetReversePrivateEndpointPath.t.Errorf("ClientMock.GetReversePrivateEndpointPath got unexpected parameter reversePrivateEndpointId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.expectationOrigins.originReversePrivateEndpointId, *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReversePrivateEndpointPath.t.Errorf("ClientMock.GetReversePrivateEndpointPath got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReversePrivateEndpointPath.t.Fatal("No results are set for the ClientMock.GetReversePrivateEndpointPath")
		}
		return (*mm_results).s1
	}
	if mmGetReversePrivateEndpointPath.funcGetReversePrivateEndpointPath != nil {
		return mmGetReversePrivateEndpointPath.funcGetReversePrivateEndpointPath(serviceId, reversePrivateEndpointId)
	}
	mmGetReversePrivateEndpointPath.t.Fatalf("Unexpected call to ClientMock.GetReversePrivateEndpointPath. %v %v", serviceId, reversePrivateEndpointId)
	return
}

// GetReversePrivateEndpointPathAfterCounter returns a count of finished ClientMock.GetReversePrivateEndpointPath invocations
func (mmGetReversePrivateEndpointPath *ClientMock) GetReversePrivateEndpointPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.afterGetReversePrivateEndpointPathCounter)
}

// GetReversePrivateEndpointPathBeforeCounter returns a count of ClientMock.GetReversePrivateEndpointPath invocations
func (mmGetReversePrivateEndpointPath *ClientMock) GetReversePrivateEndpointPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.beforeGetReversePrivateEndpointPathCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetReversePrivateEndpointPath.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Calls() []*ClientMockGetReversePrivateEndpointPathParams {
	mmGetReversePrivateEndpointPath.mutex.RLock()

	argCopy := make([]*ClientMockGetReversePrivateEndpointPathParams, len(mmGetReversePrivateEndpointPath.callArgs))
	copy(argCopy, mmGetReversePrivateEndpointPath.callArgs)

	mmGetReversePrivateEndpointPath.mutex.RUnlock()

	return argCopy
}

// MinimockGetReversePrivateEndpointPathDone returns true if the count of the GetReversePrivateEndpointPath invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetReversePrivateEndpointPathDone() bool {
	if m.GetReversePrivateEndpointPathMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReversePrivateEndpointPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReversePrivateEndpointPathMock.invocationsDone()
}

// MinimockGetReversePrivateEndpointPathInspect logs each unmet expectation
func (m *ClientMock) MinimockGetReversePrivateEndpointPathInspect() {
	for _, e := range m.GetReversePrivateEndpointPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpointPath at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReversePrivateEndpointPathCounter := mm_atomic.LoadUint64(&m.afterGetReversePrivateEndpointPathCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReversePrivateEndpointPathMock.defaultExpectation != nil && afterGetReversePrivateEndpointPathCounter < 1 {
		if m.GetReversePrivateEndpointPathMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpointPath at\n%s", m.GetReversePrivateEndpointPathMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpointPath at\n%s with params: %#v", m.GetReversePrivateEndpointPathMock.defaultExpectation.expectationOrigins.origin, *m.GetReversePrivateEndpointPathMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReversePrivateEndpointPath != nil && afterGetReversePrivateEndpointPathCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpointPath at\n%s", m.funcGetReversePrivateEndpointPathOrigin)
	}

	if !m.GetReversePrivateEndpointPathMock.invocationsDone() && afterGetReversePrivateEndpointPathCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetReversePrivateEndpointPath at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReversePrivateEndpointPathMock.expectedInvocations), m.GetReversePrivateEndpointPathMock.expectedInvocationsOrigin, afterGetReversePrivateEndpointPathCounter)
	}
}

type mClientMockGetService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetServiceExpectation
	expectations       []*ClientMockGetServiceExpectation

	callArgs []*ClientMockGetServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetServiceExpectation specifies expectation struct of the Client.GetService
type ClientMockGetServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetServiceParams
	paramPtrs          *ClientMockGetServiceParamPtrs
	expectationOrigins ClientMockGetServiceExpectationOrigins
	results            *ClientMockGetServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetServiceParams contains parameters of the Client.GetService
type ClientMockGetServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetServiceParamPtrs contains pointers to parameters of the Client.GetService
type ClientMockGetServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetServiceResults contains results of the Client.GetService
type ClientMockGetServiceResults struct {
	sp1 *Service
	err error
}

// ClientMockGetServiceOrigins contains origins of expectations of the Client.GetService
type ClientMockGetServiceExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetService *mClientMockGetService) Optional() *mClientMockGetService {
	mmGetService.optional = true
	return mmGetService
}

// Expect sets up expected params for Client.GetService
func (mmGetService *mClientMockGetService) Expect(ctx context.Context, serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.paramPtrs != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by ExpectParams functions")
	}

	mmGetService.defaultExpectation.params = &ClientMockGetServiceParams{ctx, serviceId}
	mmGetService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetService.expectations {
		if minimock.Equal(e.params, mmGetService.defaultExpectation.params) {
			mmGetService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetService.defaultExpectation.params)
		}
	}

	return mmGetService
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetService
func (mmGetService *mClientMockGetService) ExpectCtxParam1(ctx context.Context) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetService
func (mmGetService *mClientMockGetService) ExpectServiceIdParam2(serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetService.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetService
}

// Inspect accepts an inspector function that has same arguments as the Client.GetService
func (mmGetService *mClientMockGetService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetService {
	if mmGetService.mock.inspectFuncGetService != nil {
		mmGetService.mock.t.Fatalf("Inspect function is already set for ClientMock.GetService")
	}

	mmGetService.mock.inspectFuncGetService = f

	return mmGetService
}

// Return sets up results that will be returned by Client.GetService
func (mmGetService *mClientMockGetService) Return(sp1 *Service, err error) *ClientMock {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{mock: mmGetService.mock}
	}
	mmGetService.defaultExpectation.results = &ClientMockGetServiceResults{sp1, err}
	mmGetService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetService.mock
}

// Set uses given function f to mock the Client.GetService method
func (mmGetService *mClientMockGetService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmGetService.defaultExpectation != nil {
		mmGetService.mock.t.Fatalf("Default expectation is already set for the Client.GetService method")
	}

	if len(mmGetService.expectations) > 0 {
		mmGetService.mock.t.Fatalf("Some expectations are already set for the Client.GetService method")
	}

	mmGetService.mock.funcGetService = f
	mmGetService.mock.funcGetServiceOrigin = minimock.CallerInfo(1)
	return mmGetService.mock
}

// When sets expectation for the Client.GetService which will trigger the result defined by the following
// Then helper
func (mmGetService *mClientMockGetService) When(ctx context.Context, serviceId string) *ClientMockGetServiceExpectation {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	expectation := &ClientMockGetServiceExpectation{
		mock:               mmGetService.mock,
		params:             &ClientMockGetServiceParams{ctx, serviceId},
		expectationOrigins: ClientMockGetServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetService.expectations = append(mmGetService.expectations, expectation)
	return expectation
}

// Then sets up Client.GetService return parameters for the expectation previously defined by the When method
func (e *ClientMockGetServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockGetServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetService should be invoked
func (mmGetService *mClientMockGetService) Times(n uint64) *mClientMockGetService {
	if n == 0 {
		mmGetService.mock.t.Fatalf("Times of ClientMock.GetService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetService.expectedInvocations, n)
	mmGetService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetService
}

func (mmGetService *mClientMockGetService) invocationsDone() bool {
	if len(mmGetService.expectations) == 0 && mmGetService.defaultExpectation == nil && mmGetService.mock.funcGetService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetService.mock.afterGetServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetService implements Client
func (mmGetService *ClientMock) GetService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmGetService.beforeGetServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetService.afterGetServiceCounter, 1)

	mmGetService.t.Helper()

	if mmGetService.inspectFuncGetService != nil {
		mmGetService.inspectFuncGetService(ctx, serviceId)
	}

	mm_params := ClientMockGetServiceParams{ctx, serviceId}

	// Record call args
	mmGetService.GetServiceMock.mutex.Lock()
	mmGetService.GetServiceMock.callArgs = append(mmGetService.GetServiceMock.callArgs, &mm_params)
	mmGetService.GetServiceMock.mutex.Unlock()

	for _, e := range mmGetService.GetServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetService.GetServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetService.GetServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetService.GetServiceMock.defaultExpectation.params
		mm_want_ptrs := mmGetService.GetServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetService.GetServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetService.GetServiceMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetService.t.Errorf("ClientMock.GetService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetService.GetServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetService.GetServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetService.t.Fatal("No results are set for the ClientMock.GetService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetService.funcGetService != nil {
		return mmGetService.funcGetService(ctx, serviceId)
	}
	mmGetService.t.Fatalf("Unexpected call to ClientMock.GetService. %v %v", ctx, serviceId)
	return
}

// GetServiceAfterCounter returns a count of finished ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.afterGetServiceCounter)
}

// GetServiceBeforeCounter returns a count of ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.beforeGetServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetService *mClientMockGetService) Calls() []*ClientMockGetServiceParams {
	mmGetService.mutex.RLock()

	argCopy := make([]*ClientMockGetServiceParams, len(mmGetService.callArgs))
	copy(argCopy, mmGetService.callArgs)

	mmGetService.mutex.RUnlock()

	return argCopy
}

// MinimockGetServiceDone returns true if the count of the GetService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetServiceDone() bool {
	if m.GetServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetServiceMock.invocationsDone()
}

// MinimockGetServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockGetServiceInspect() {
	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetServiceCounter := mm_atomic.LoadUint64(&m.afterGetServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetServiceMock.defaultExpectation != nil && afterGetServiceCounter < 1 {
		if m.GetServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetService at\n%s", m.GetServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetService at\n%s with params: %#v", m.GetServiceMock.defaultExpectation.expectationOrigins.origin, *m.GetServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetService != nil && afterGetServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetService at\n%s", m.funcGetServiceOrigin)
	}

	if !m.GetServiceMock.invocationsDone() && afterGetServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetServiceMock.expectedInvocations), m.GetServiceMock.expectedInvocationsOrigin, afterGetServiceCounter)
	}
}

type mClientMockListReversePrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListReversePrivateEndpointsExpectation
	expectations       []*ClientMockListReversePrivateEndpointsExpectation

	callArgs []*ClientMockListReversePrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockListReversePrivateEndpointsExpectation specifies expectation struct of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsExpectation struct {
	mock               *ClientMock
	params             *ClientMockListReversePrivateEndpointsParams
	paramPtrs          *ClientMockListReversePrivateEndpointsParamPtrs
	expectationOrigins ClientMockListReversePrivateEndpointsExpectationOrigins
	results            *ClientMockListReversePrivateEndpointsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockListReversePrivateEndpointsParams contains parameters of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockListReversePrivateEndpointsParamPtrs contains pointers to parameters of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockListReversePrivateEndpointsResults contains results of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsResults struct {
	rpa1 []*ReversePrivateEndpoint
	err  error
}

// ClientMockListReversePrivateEndpointsOrigins contains origins of expectations of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Optional() *mClientMockListReversePrivateEndpoints {
	mmListReversePrivateEndpoints.optional = true
	return mmListReversePrivateEndpoints
}

// Expect sets up expected params for Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Expect(ctx context.Context, serviceId string) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{}
	}

	if mmListReversePrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmListReversePrivateEndpoints.defaultExpectation.params = &ClientMockListReversePrivateEndpointsParams{ctx, serviceId}
	mmListReversePrivateEndpoints.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListReversePrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmListReversePrivateEndpoints.defaultExpectation.params) {
			mmListReversePrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReversePrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmListReversePrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{}
	}

	if mmListReversePrivateEndpoints.defaultExpectation.params != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Expect")
	}

	if mmListReversePrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmListReversePrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockListReversePrivateEndpointsParamPtrs{}
	}
	mmListReversePrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx
	mmListReversePrivateEndpoints.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListReversePrivateEndpoints
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) ExpectServiceIdParam2(serviceId string) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{}
	}

	if mmListReversePrivateEndpoints.defaultExpectation.params != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Expect")
	}

	if mmListReversePrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmListReversePrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockListReversePrivateEndpointsParamPtrs{}
	}
	mmListReversePrivateEndpoints.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmListReversePrivateEndpoints.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmListReversePrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.inspectFuncListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.ListReversePrivateEndpoints")
	}

	mmListReversePrivateEndpoints.mock.inspectFuncListReversePrivateEndpoints = f

	return mmListReversePrivateEndpoints
}

// Return sets up results that will be returned by Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Return(rpa1 []*ReversePrivateEndpoint, err error) *ClientMock {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{mock: mmListReversePrivateEndpoints.mock}
	}
	mmListReversePrivateEndpoints.defaultExpectation.results = &ClientMockListReversePrivateEndpointsResults{rpa1, err}
	mmListReversePrivateEndpoints.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListReversePrivateEndpoints.mock
}

// Set uses given function f to mock the Client.ListReversePrivateEndpoints method
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Set(f func(ctx context.Context, serviceId string) (rpa1 []*ReversePrivateEndpoint, err error)) *ClientMock {
	if mmListReversePrivateEndpoints.defaultExpectation != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.ListReversePrivateEndpoints method")
	}

	if len(mmListReversePrivateEndpoints.expectations) > 0 {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.ListReversePrivateEndpoints method")
	}

	mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints = f
	mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpointsOrigin = minimock.CallerInfo(1)
	return mmListReversePrivateEndpoints.mock
}

// When sets expectation for the Client.ListReversePrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) When(ctx context.Context, serviceId string) *ClientMockListReversePrivateEndpointsExpectation {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockListReversePrivateEndpointsExpectation{
		mock:               mmListReversePrivateEndpoints.mock,
		params:             &ClientMockListReversePrivateEndpointsParams{ctx, serviceId},
		expectationOrigins: ClientMockListReversePrivateEndpointsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListReversePrivateEndpoints.expectations = append(mmListReversePrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.ListReversePrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockListReversePrivateEndpointsExpectation) Then(rpa1 []*ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockListReversePrivateEndpointsResults{rpa1, err}
	return e.mock
}

// Times sets number of times Client.ListReversePrivateEndpoints should be invoked
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Times(n uint64) *mClientMockListReversePrivateEndpoints {
	if n == 0 {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Times of ClientMock.ListReversePrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReversePrivateEndpoints.expectedInvocations, n)
	mmListReversePrivateEndpoints.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListReversePrivateEndpoints
}

func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) invocationsDone() bool {
	if len(mmListReversePrivateEndpoints.expectations) == 0 && mmListReversePrivateEndpoints.defaultExpectation == nil && mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.mock.afterListReversePrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReversePrivateEndpoints implements Client
func (mmListReversePrivateEndpoints *ClientMock) ListReversePrivateEndpoints(ctx context.Context, serviceId string) (rpa1 []*ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmListReversePrivateEndpoints.beforeListReversePrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReversePrivateEndpoints.afterListReversePrivateEndpointsCounter, 1)

	mmListReversePrivateEndpoints.t.Helper()

	if mmListReversePrivateEndpoints.inspectFuncListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.inspectFuncListReversePrivateEndpoints(ctx, serviceId)
	}

	mm_params := ClientMockListReversePrivateEndpointsParams{ctx, serviceId}

	// Record call args
	mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.mutex.Lock()
	mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.callArgs = append(mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.callArgs, &mm_params)
	mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockListReversePrivateEndpointsParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReversePrivateEndpoints.t.Errorf("ClientMock.ListReversePrivateEndpoints got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmListReversePrivateEndpoints.t.Errorf("ClientMock.ListReversePrivateEndpoints got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReversePrivateEndpoints.t.Errorf("ClientMock.ListReversePrivateEndpoints got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReversePrivateEndpoints.t.Fatal("No results are set for the ClientMock.ListReversePrivateEndpoints")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmListReversePrivateEndpoints.funcListReversePrivateEndpoints != nil {
		return mmListReversePrivateEndpoints.funcListReversePrivateEndpoints(ctx, serviceId)
	}
	mmListReversePrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.ListReversePrivateEndpoints. %v %v", ctx, serviceId)
	return
}

// ListReversePrivateEndpointsAfterCounter returns a count of finished ClientMock.ListReversePrivateEndpoints invocations
func (mmListReversePrivateEndpoints *ClientMock) ListReversePrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.afterListReversePrivateEndpointsCounter)
}

// ListReversePrivateEndpointsBeforeCounter returns a count of ClientMock.ListReversePrivateEndpoints invocations
func (mmListReversePrivateEndpoints *ClientMock) ListReversePrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.beforeListReversePrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListReversePrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Calls() []*ClientMockListReversePrivateEndpointsParams {
	mmListReversePrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockListReversePrivateEndpointsParams, len(mmListReversePrivateEndpoints.callArgs))
	copy(argCopy, mmListReversePrivateEndpoints.callArgs)

	mmListReversePrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockListReversePrivateEndpointsDone returns true if the count of the ListReversePrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListReversePrivateEndpointsDone() bool {
	if m.ListReversePrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReversePrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReversePrivateEndpointsMock.invocationsDone()
}

// MinimockListReversePrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockListReversePrivateEndpointsInspect() {
	for _, e := range m.ListReversePrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListReversePrivateEndpoints at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListReversePrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterListReversePrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReversePrivateEndpointsMock.defaultExpectation != nil && afterListReversePrivateEndpointsCounter < 1 {
		if m.ListReversePrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ListReversePrivateEndpoints at\n%s", m.ListReversePrivateEndpointsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ListReversePrivateEndpoints at\n%s with params: %#v", m.ListReversePrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *m.ListReversePrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReversePrivateEndpoints != nil && afterListReversePrivateEndpointsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListReversePrivateEndpoints at\n%s", m.funcListReversePrivateEndpointsOrigin)
	}

	if !m.ListReversePrivateEndpointsMock.invocationsDone() && afterListReversePrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListReversePrivateEndpoints at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListReversePrivateEndpointsMock.expectedInvocations), m.ListReversePrivateEndpointsMock.expectedInvocationsOrigin, afterListReversePrivateEndpointsCounter)
	}
}

type mClientMockRotateTDEKey struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockRotateTDEKeyExpectation
	expectations       []*ClientMockRotateTDEKeyExpectation

	callArgs []*ClientMockRotateTDEKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockRotateTDEKeyExpectation specifies expectation struct of the Client.RotateTDEKey
type ClientMockRotateTDEKeyExpectation struct {
	mock               *ClientMock
	params             *ClientMockRotateTDEKeyParams
	paramPtrs          *ClientMockRotateTDEKeyParamPtrs
	expectationOrigins ClientMockRotateTDEKeyExpectationOrigins
	results            *ClientMockRotateTDEKeyResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockRotateTDEKeyParams contains parameters of the Client.RotateTDEKey
type ClientMockRotateTDEKeyParams struct {
	ctx       context.Context
	serviceId string
	keyId     string
}

// ClientMockRotateTDEKeyParamPtrs contains pointers to parameters of the Client.RotateTDEKey
type ClientMockRotateTDEKeyParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	keyId     *string
}

// ClientMockRotateTDEKeyResults contains results of the Client.RotateTDEKey
type ClientMockRotateTDEKeyResults struct {
	err error
}

// ClientMockRotateTDEKeyOrigins contains origins of expectations of the Client.RotateTDEKey
type ClientMockRotateTDEKeyExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originKeyId     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRotateTDEKey *mClientMockRotateTDEKey) Optional() *mClientMockRotateTDEKey {
	mmRotateTDEKey.optional = true
	return mmRotateTDEKey
}

// Expect sets up expected params for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) Expect(ctx context.Context, serviceId string, keyId string) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by ExpectParams functions")
	}

	mmRotateTDEKey.defaultExpectation.params = &ClientMockRotateTDEKeyParams{ctx, serviceId, keyId}
	mmRotateTDEKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRotateTDEKey.expectations {
		if minimock.Equal(e.params, mmRotateTDEKey.defaultExpectation.params) {
			mmRotateTDEKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRotateTDEKey.defaultExpectation.params)
		}
	}

	return mmRotateTDEKey
}

// ExpectCtxParam1 sets up expected param ctx for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) ExpectCtxParam1(ctx context.Context) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.params != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Expect")
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs == nil {
		mmRotateTDEKey.defaultExpectation.paramPtrs = &ClientMockRotateTDEKeyParamPtrs{}
	}
	mmRotateTDEKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmRotateTDEKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRotateTDEKey
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) ExpectServiceIdParam2(serviceId string) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.params != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Expect")
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs == nil {
		mmRotateTDEKey.defaultExpectation.paramPtrs = &ClientMockRotateTDEKeyParamPtrs{}
	}
	mmRotateTDEKey.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmRotateTDEKey.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmRotateTDEKey
}

// ExpectKeyIdParam3 sets up expected param keyId for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) ExpectKeyIdParam3(keyId string) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.params != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Expect")
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs == nil {
		mmRotateTDEKey.defaultExpectation.paramPtrs = &ClientMockRotateTDEKeyParamPtrs{}
	}
	mmRotateTDEKey.defaultExpectation.paramPtrs.keyId = &keyId
	mmRotateTDEKey.defaultExpectation.expectationOrigins.originKeyId = minimock.CallerInfo(1)

	return mmRotateTDEKey
}

// Inspect accepts an inspector function that has same arguments as the Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) Inspect(f func(ctx context.Context, serviceId string, keyId string)) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.inspectFuncRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("Inspect function is already set for ClientMock.RotateTDEKey")
	}

	mmRotateTDEKey.mock.inspectFuncRotateTDEKey = f

	return mmRotateTDEKey
}

// Return sets up results that will be returned by Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) Return(err error) *ClientMock {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{mock: mmRotateTDEKey.mock}
	}
	mmRotateTDEKey.defaultExpectation.results = &ClientMockRotateTDEKeyResults{err}
	mmRotateTDEKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRotateTDEKey.mock
}

// Set uses given function f to mock the Client.RotateTDEKey method
func (mmRotateTDEKey *mClientMockRotateTDEKey) Set(f func(ctx context.Context, serviceId string, keyId string) (err error)) *ClientMock {
	if mmRotateTDEKey.defaultExpectation != nil {
		mmRotateTDEKey.mock.t.Fatalf("Default expectation is already set for the Client.RotateTDEKey method")
	}

	if len(mmRotateTDEKey.expectations) > 0 {
		mmRotateTDEKey.mock.t.Fatalf("Some expectations are already set for the Client.RotateTDEKey method")
	}

	mmRotateTDEKey.mock.funcRotateTDEKey = f
	mmRotateTDEKey.mock.funcRotateTDEKeyOrigin = minimock.CallerInfo(1)
	return mmRotateTDEKey.mock
}

// When sets expectation for the Client.RotateTDEKey which will trigger the result defined by the following
// Then helper
func (mmRotateTDEKey *mClientMockRotateTDEKey) When(ctx context.Context, serviceId string, keyId string) *ClientMockRotateTDEKeyExpectation {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	expectation := &ClientMockRotateTDEKeyExpectation{
		mock:               mmRotateTDEKey.mock,
		params:             &ClientMockRotateTDEKeyParams{ctx, serviceId, keyId},
		expectationOrigins: ClientMockRotateTDEKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRotateTDEKey.expectations = append(mmRotateTDEKey.expectations, expectation)
	return expectation
}

// Then sets up Client.RotateTDEKey return parameters for the expectation previously defined by the When method
func (e *ClientMockRotateTDEKeyExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRotateTDEKeyResults{err}
	return e.mock
}

// Times sets number of times Client.RotateTDEKey should be invoked
func (mmRotateTDEKey *mClientMockRotateTDEKey) Times(n uint64) *mClientMockRotateTDEKey {
	if n == 0 {
		mmRotateTDEKey.mock.t.Fatalf("Times of ClientMock.RotateTDEKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRotateTDEKey.expectedInvocations, n)
	mmRotateTDEKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRotateTDEKey
}

func (mmRotateTDEKey *mClientMockRotateTDEKey) invocationsDone() bool {
	if len(mmRotateTDEKey.expectations) == 0 && mmRotateTDEKey.defaultExpectation == nil && mmRotateTDEKey.mock.funcRotateTDEKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRotateTDEKey.mock.afterRotateTDEKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRotateTDEKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RotateTDEKey implements Client
func (mmRotateTDEKey *ClientMock) RotateTDEKey(ctx context.Context, serviceId string, keyId string) (err error) {
	mm_atomic.AddUint64(&mmRotateTDEKey.beforeRotateTDEKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRotateTDEKey.afterRotateTDEKeyCounter, 1)

	mmRotateTDEKey.t.Helper()

	if mmRotateTDEKey.inspectFuncRotateTDEKey != nil {
		mmRotateTDEKey.inspectFuncRotateTDEKey(ctx, serviceId, keyId)
	}

	mm_params := ClientMockRotateTDEKeyParams{ctx, serviceId, keyId}

	// Record call args
	mmRotateTDEKey.RotateTDEKeyMock.mutex.Lock()
	mmRotateTDEKey.RotateTDEKeyMock.callArgs = append(mmRotateTDEKey.RotateTDEKeyMock.callArgs, &mm_params)
	mmRotateTDEKey.RotateTDEKeyMock.mutex.Unlock()

	for _, e := range mmRotateTDEKey.RotateTDEKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.params
		mm_want_ptrs := mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockRotateTDEKeyParams{ctx, serviceId, keyId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.keyId != nil && !minimock.Equal(*mm_want_ptrs.keyId, mm_got.keyId) {
				mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameter keyId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.expectationOrigins.originKeyId, *mm_want_ptrs.keyId, mm_got.keyId, minimock.Diff(*mm_want_ptrs.keyId, mm_got.keyId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRotateTDEKey.t.Fatal("No results are set for the ClientMock.RotateTDEKey")
		}
		return (*mm_results).err
	}
	if mmRotateTDEKey.funcRotateTDEKey != nil {
		return mmRotateTDEKey.funcRotateTDEKey(ctx, serviceId, keyId)
	}
	mmRotateTDEKey.t.Fatalf("Unexpected call to ClientMock.RotateTDEKey. %v %v %v", ctx, serviceId, keyId)
	return
}

// RotateTDEKeyAfterCounter returns a count of finished ClientMock.RotateTDEKey invocations
func (mmRotateTDEKey *ClientMock) RotateTDEKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRotateTDEKey.afterRotateTDEKeyCounter)
}

// RotateTDEKeyBeforeCounter returns a count of ClientMock.RotateTDEKey invocations
func (mmRotateTDEKey *ClientMock) RotateTDEKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRotateTDEKey.beforeRotateTDEKeyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RotateTDEKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRotateTDEKey *mClientMockRotateTDEKey) Calls() []*ClientMockRotateTDEKeyParams {
	mmRotateTDEKey.mutex.RLock()

	argCopy := make([]*ClientMockRotateTDEKeyParams, len(mmRotateTDEKey.callArgs))
	copy(argCopy, mmRotateTDEKey.callArgs)

	mmRotateTDEKey.mutex.RUnlock()

	return argCopy
}

// MinimockRotateTDEKeyDone returns true if the count of the RotateTDEKey invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRotateTDEKeyDone() bool {
	if m.RotateTDEKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RotateTDEKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RotateTDEKeyMock.invocationsDone()
}

// MinimockRotateTDEKeyInspect logs each unmet expectation
func (m *ClientMock) MinimockRotateTDEKeyInspect() {
	for _, e := range m.RotateTDEKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RotateTDEKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRotateTDEKeyCounter := mm_atomic.LoadUint64(&m.afterRotateTDEKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RotateTDEKeyMock.defaultExpectation != nil && afterRotateTDEKeyCounter < 1 {
		if m.RotateTDEKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.RotateTDEKey at\n%s", m.RotateTDEKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.RotateTDEKey at\n%s with params: %#v", m.RotateTDEKeyMock.defaultExpectation.expectationOrigins.origin, *m.RotateTDEKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRotateTDEKey != nil && afterRotateTDEKeyCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.RotateTDEKey at\n%s", m.funcRotateTDEKeyOrigin)
	}

	if !m.RotateTDEKeyMock.invocationsDone() && afterRotateTDEKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.RotateTDEKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RotateTDEKeyMock.expectedInvocations), m.RotateTDEKeyMock.expectedInvocationsOrigin, afterRotateTDEKeyCounter)
	}
}

type mClientMockScalingClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockScalingClickPipeExpectation
	expectations       []*ClientMockScalingClickPipeExpectation

	callArgs []*ClientMockScalingClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockScalingClickPipeExpectation specifies expectation struct of the Client.ScalingClickPipe
type ClientMockScalingClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockScalingClickPipeParams
	paramPtrs          *ClientMockScalingClickPipeParamPtrs
	expectationOrigins ClientMockScalingClickPipeExpectationOrigins
	results            *ClientMockScalingClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockScalingClickPipeParams contains parameters of the Client.ScalingClickPipe
type ClientMockScalingClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	request     ClickPipeScalingRequest
}

// ClientMockScalingClickPipeParamPtrs contains pointers to parameters of the Client.ScalingClickPipe
type ClientMockScalingClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	request     *ClickPipeScalingRequest
}

// ClientMockScalingClickPipeResults contains results of the Client.ScalingClickPipe
type ClientMockScalingClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockScalingClickPipeOrigins contains origins of expectations of the Client.ScalingClickPipe
type ClientMockScalingClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
	originRequest     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScalingClickPipe *mClientMockScalingClickPipe) Optional() *mClientMockScalingClickPipe {
	mmScalingClickPipe.optional = true
	return mmScalingClickPipe
}

// Expect sets up expected params for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by ExpectParams functions")
	}

	mmScalingClickPipe.defaultExpectation.params = &ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}
	mmScalingClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScalingClickPipe.expectations {
		if minimock.Equal(e.params, mmScalingClickPipe.defaultExpectation.params) {
			mmScalingClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScalingClickPipe.defaultExpectation.params)
		}
	}

	return mmScalingClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmScalingClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScalingClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmScalingClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmScalingClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmScalingClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmScalingClickPipe
}

// ExpectRequestParam4 sets up expected param request for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectRequestParam4(request ClickPipeScalingRequest) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.request = &request
	mmScalingClickPipe.defaultExpectation.expectationOrigins.originRequest = minimock.CallerInfo(1)

	return mmScalingClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest)) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.inspectFuncScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.ScalingClickPipe")
	}

	mmScalingClickPipe.mock.inspectFuncScalingClickPipe = f

	return mmScalingClickPipe
}

// Return sets up results that will be returned by Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{mock: mmScalingClickPipe.mock}
	}
	mmScalingClickPipe.defaultExpectation.results = &ClientMockScalingClickPipeResults{cp1, err}
	mmScalingClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScalingClickPipe.mock
}

// Set uses given function f to mock the Client.ScalingClickPipe method
func (mmScalingClickPipe *mClientMockScalingClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmScalingClickPipe.defaultExpectation != nil {
		mmScalingClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.ScalingClickPipe method")
	}

	if len(mmScalingClickPipe.expectations) > 0 {
		mmScalingClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.ScalingClickPipe method")
	}

	mmScalingClickPipe.mock.funcScalingClickPipe = f
	mmScalingClickPipe.mock.funcScalingClickPipeOrigin = minimock.CallerInfo(1)
	return mmScalingClickPipe.mock
}

// When sets expectation for the Client.ScalingClickPipe which will trigger the result defined by the following
// Then helper
func (mmScalingClickPipe *mClientMockScalingClickPipe) When(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest) *ClientMockScalingClickPipeExpectation {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	expectation := &ClientMockScalingClickPipeExpectation{
		mock:               mmScalingClickPipe.mock,
		params:             &ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request},
		expectationOrigins: ClientMockScalingClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScalingClickPipe.expectations = append(mmScalingClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.ScalingClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockScalingClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockScalingClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ScalingClickPipe should be invoked
func (mmScalingClickPipe *mClientMockScalingClickPipe) Times(n uint64) *mClientMockScalingClickPipe {
	if n == 0 {
		mmScalingClickPipe.mock.t.Fatalf("Times of ClientMock.ScalingClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScalingClickPipe.expectedInvocations, n)
	mmScalingClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScalingClickPipe
}

func (mmScalingClickPipe *mClientMockScalingClickPipe) invocationsDone() bool {
	if len(mmScalingClickPipe.expectations) == 0 && mmScalingClickPipe.defaultExpectation == nil && mmScalingClickPipe.mock.funcScalingClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScalingClickPipe.mock.afterScalingClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScalingClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScalingClickPipe implements Client
func (mmScalingClickPipe *ClientMock) ScalingClickPipe(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScalingRequest) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmScalingClickPipe.beforeScalingClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmScalingClickPipe.afterScalingClickPipeCounter, 1)

	mmScalingClickPipe.t.Helper()

	if mmScalingClickPipe.inspectFuncScalingClickPipe != nil {
		mmScalingClickPipe.inspectFuncScalingClickPipe(ctx, serviceId, clickPipeId, request)
	}

	mm_params := ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}

	// Record call args
	mmScalingClickPipe.ScalingClickPipeMock.mutex.Lock()
	mmScalingClickPipe.ScalingClickPipeMock.callArgs = append(mmScalingClickPipe.ScalingClickPipeMock.callArgs, &mm_params)
	mmScalingClickPipe.ScalingClickPipeMock.mutex.Unlock()

	for _, e := range mmScalingClickPipe.ScalingClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter request, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.expectationOrigins.originRequest, *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmScalingClickPipe.t.Fatal("No results are set for the ClientMock.ScalingClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmScalingClickPipe.funcScalingClickPipe != nil {
		return mmScalingClickPipe.funcScalingClickPipe(ctx, serviceId, clickPipeId, request)
	}
	mmScalingClickPipe.t.Fatalf("Unexpected call to ClientMock.ScalingClickPipe. %v %v %v %v", ctx, serviceId, clickPipeId, request)
	return
}

// ScalingClickPipeAfterCounter returns a count of finished ClientMock.ScalingClickPipe invocations
func (mmScalingClickPipe *ClientMock) ScalingClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScalingClickPipe.afterScalingClickPipeCounter)
}

// ScalingClickPipeBeforeCounter returns a count of ClientMock.ScalingClickPipe invocations
func (mmScalingClickPipe *ClientMock) ScalingClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScalingClickPipe.beforeScalingClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ScalingClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScalingClickPipe *mClientMockScalingClickPipe) Calls() []*ClientMockScalingClickPipeParams {
	mmScalingClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockScalingClickPipeParams, len(mmScalingClickPipe.callArgs))
	copy(argCopy, mmScalingClickPipe.callArgs)

	mmScalingClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockScalingClickPipeDone returns true if the count of the ScalingClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockScalingClickPipeDone() bool {
	if m.ScalingClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScalingClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScalingClickPipeMock.invocationsDone()
}

// MinimockScalingClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockScalingClickPipeInspect() {
	for _, e := range m.ScalingClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScalingClickPipeCounter := mm_atomic.LoadUint64(&m.afterScalingClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScalingClickPipeMock.defaultExpectation != nil && afterScalingClickPipeCounter < 1 {
		if m.ScalingClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s", m.ScalingClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s with params: %#v", m.ScalingClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.ScalingClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScalingClickPipe != nil && afterScalingClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s", m.funcScalingClickPipeOrigin)
	}

	if !m.ScalingClickPipeMock.invocationsDone() && afterScalingClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ScalingClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScalingClickPipeMock.expectedInvocations), m.ScalingClickPipeMock.expectedInvocationsOrigin, afterScalingClickPipeCounter)
	}
}

type mClientMockUpdateBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateBackupConfigurationExpectation
	expectations       []*ClientMockUpdateBackupConfigurationExpectation

	callArgs []*ClientMockUpdateBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateBackupConfigurationExpectation specifies expectation struct of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateBackupConfigurationParams
	paramPtrs          *ClientMockUpdateBackupConfigurationParamPtrs
	expectationOrigins ClientMockUpdateBackupConfigurationExpectationOrigins
	results            *ClientMockUpdateBackupConfigurationResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateBackupConfigurationParams contains parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
	b         BackupConfiguration
}

// ClientMockUpdateBackupConfigurationParamPtrs contains pointers to parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	b         *BackupConfiguration
}

// ClientMockUpdateBackupConfigurationResults contains results of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// ClientMockUpdateBackupConfigurationOrigins contains origins of expectations of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originB         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Optional() *mClientMockUpdateBackupConfiguration {
	mmUpdateBackupConfiguration.optional = true
	return mmUpdateBackupConfiguration
}

// Expect sets up expected params for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Expect(ctx context.Context, serviceId string, b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmUpdateBackupConfiguration.defaultExpectation.params = &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmUpdateBackupConfiguration.defaultExpectation.params) {
			mmUpdateBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmUpdateBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateBackupConfiguration
}

// ExpectBParam3 sets up expected param b for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectBParam3(b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.b = &b
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmUpdateBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string, b BackupConfiguration)) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateBackupConfiguration")
	}

	mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration = f

	return mmUpdateBackupConfiguration
}

// Return sets up results that will be returned by Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{mock: mmUpdateBackupConfiguration.mock}
	}
	mmUpdateBackupConfiguration.defaultExpectation.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	mmUpdateBackupConfiguration.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateBackupConfiguration.mock
}

// Set uses given function f to mock the Client.UpdateBackupConfiguration method
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Set(f func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmUpdateBackupConfiguration.defaultExpectation != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.UpdateBackupConfiguration method")
	}

	if len(mmUpdateBackupConfiguration.expectations) > 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.UpdateBackupConfiguration method")
	}

	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration = f
	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfigurationOrigin = minimock.CallerInfo(1)
	return mmUpdateBackupConfiguration.mock
}

// When sets expectation for the Client.UpdateBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) When(ctx context.Context, serviceId string, b BackupConfiguration) *ClientMockUpdateBackupConfigurationExpectation {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockUpdateBackupConfigurationExpectation{
		mock:               mmUpdateBackupConfiguration.mock,
		params:             &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b},
		expectationOrigins: ClientMockUpdateBackupConfigurationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateBackupConfiguration.expectations = append(mmUpdateBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateBackupConfiguration should be invoked
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Times(n uint64) *mClientMockUpdateBackupConfiguration {
	if n == 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Times of ClientMock.UpdateBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateBackupConfiguration.expectedInvocations, n)
	mmUpdateBackupConfiguration.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateBackupConfiguration
}

func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) invocationsDone() bool {
	if len(mmUpdateBackupConfiguration.expectations) == 0 && mmUpdateBackupConfiguration.defaultExpectation == nil && mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.mock.afterUpdateBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateBackupConfiguration implements Client
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfiguration(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter, 1)

	mmUpdateBackupConfiguration.t.Helper()

	if mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration(ctx, serviceId, b)
	}

	mm_params := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

	// Record call args
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Lock()
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs = append(mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs, &mm_params)
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBackupConfiguration.t.Fatal("No results are set for the ClientMock.UpdateBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmUpdateBackupConfiguration.funcUpdateBackupConfiguration != nil {
		return mmUpdateBackupConfiguration.funcUpdateBackupConfiguration(ctx, serviceId, b)
	}
	mmUpdateBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.UpdateBackupConfiguration. %v %v %v", ctx, serviceId, b)
	return
}

// UpdateBackupConfigurationAfterCounter returns a count of finished ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter)
}

// UpdateBackupConfigurationBeforeCounter returns a count of ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Calls() []*ClientMockUpdateBackupConfigurationParams {
	mmUpdateBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockUpdateBackupConfigurationParams, len(mmUpdateBackupConfiguration.callArgs))
	copy(argCopy, mmUpdateBackupConfiguration.callArgs)

	mmUpdateBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBackupConfigurationDone returns true if the count of the UpdateBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateBackupConfigurationDone() bool {
	if m.UpdateBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateBackupConfigurationMock.invocationsDone()
}

// MinimockUpdateBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateBackupConfigurationInspect() {
	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterUpdateBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBackupConfigurationMock.defaultExpectation != nil && afterUpdateBackupConfigurationCounter < 1 {
		if m.UpdateBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s", m.UpdateBackupConfigurationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s with params: %#v", m.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *m.UpdateBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBackupConfiguration != nil && afterUpdateBackupConfigurationCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s", m.funcUpdateBackupConfigurationOrigin)
	}

	if !m.UpdateBackupConfigurationMock.invocationsDone() && afterUpdateBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateBackupConfiguration at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateBackupConfigurationMock.expectedInvocations), m.UpdateBackupConfigurationMock.expectedInvocationsOrigin, afterUpdateBackupConfigurationCounter)
	}
}

type mClientMockUpdateClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateClickPipeExpectation
	expectations       []*ClientMockUpdateClickPipeExpectation

	callArgs []*ClientMockUpdateClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateClickPipeExpectation specifies expectation struct of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateClickPipeParams
	paramPtrs          *ClientMockUpdateClickPipeParamPtrs
	expectationOrigins ClientMockUpdateClickPipeExpectationOrigins
	results            *ClientMockUpdateClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateClickPipeParams contains parameters of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	request     ClickPipeUpdate
}

// ClientMockUpdateClickPipeParamPtrs contains pointers to parameters of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	request     *ClickPipeUpdate
}

// ClientMockUpdateClickPipeResults contains results of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockUpdateClickPipeOrigins contains origins of expectations of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
	originRequest     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Optional() *mClientMockUpdateClickPipe {
	mmUpdateClickPipe.optional = true
	return mmUpdateClickPipe
}

// Expect sets up expected params for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by ExpectParams functions")
	}

	mmUpdateClickPipe.defaultExpectation.params = &ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request}
	mmUpdateClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateClickPipe.expectations {
		if minimock.Equal(e.params, mmUpdateClickPipe.defaultExpectation.params) {
			mmUpdateClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateClickPipe.defaultExpectation.params)
		}
	}

	return mmUpdateClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmUpdateClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmUpdateClickPipe
}

// ExpectRequestParam4 sets up expected param request for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectRequestParam4(request ClickPipeUpdate) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.request = &request
	mmUpdateClickPipe.defaultExpectation.expectationOrigins.originRequest = minimock.CallerInfo(1)

	return mmUpdateClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate)) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.inspectFuncUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateClickPipe")
	}

	mmUpdateClickPipe.mock.inspectFuncUpdateClickPipe = f

	return mmUpdateClickPipe
}

// Return sets up results that will be returned by Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{mock: mmUpdateClickPipe.mock}
	}
	mmUpdateClickPipe.defaultExpectation.results = &ClientMockUpdateClickPipeResults{cp1, err}
	mmUpdateClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateClickPipe.mock
}

// Set uses given function f to mock the Client.UpdateClickPipe method
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmUpdateClickPipe.defaultExpectation != nil {
		mmUpdateClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.UpdateClickPipe method")
	}

	if len(mmUpdateClickPipe.expectations) > 0 {
		mmUpdateClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.UpdateClickPipe method")
	}

	mmUpdateClickPipe.mock.funcUpdateClickPipe = f
	mmUpdateClickPipe.mock.funcUpdateClickPipeOrigin = minimock.CallerInfo(1)
	return mmUpdateClickPipe.mock
}

// When sets expectation for the Client.UpdateClickPipe which will trigger the result defined by the following
// Then helper
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) When(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) *ClientMockUpdateClickPipeExpectation {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	expectation := &ClientMockUpdateClickPipeExpectation{
		mock:               mmUpdateClickPipe.mock,
		params:             &ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request},
		expectationOrigins: ClientMockUpdateClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateClickPipe.expectations = append(mmUpdateClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockUpdateClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateClickPipe should be invoked
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Times(n uint64) *mClientMockUpdateClickPipe {
	if n == 0 {
		mmUpdateClickPipe.mock.t.Fatalf("Times of ClientMock.UpdateClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateClickPipe.expectedInvocations, n)
	mmUpdateClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateClickPipe
}

func (mmUpdateClickPipe *mClientMockUpdateClickPipe) invocationsDone() bool {
	if len(mmUpdateClickPipe.expectations) == 0 && mmUpdateClickPipe.defaultExpectation == nil && mmUpdateClickPipe.mock.funcUpdateClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateClickPipe.mock.afterUpdateClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateClickPipe implements Client
func (mmUpdateClickPipe *ClientMock) UpdateClickPipe(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmUpdateClickPipe.beforeUpdateClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateClickPipe.afterUpdateClickPipeCounter, 1)

	mmUpdateClickPipe.t.Helper()

	if mmUpdateClickPipe.inspectFuncUpdateClickPipe != nil {
		mmUpdateClickPipe.inspectFuncUpdateClickPipe(ctx, serviceId, clickPipeId, request)
	}

	mm_params := ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request}

	// Record call args
	mmUpdateClickPipe.UpdateClickPipeMock.mutex.Lock()
	mmUpdateClickPipe.UpdateClickPipeMock.callArgs = append(mmUpdateClickPipe.UpdateClickPipeMock.callArgs, &mm_params)
	mmUpdateClickPipe.UpdateClickPipeMock.mutex.Unlock()

	for _, e := range mmUpdateClickPipe.UpdateClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter request, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.expectationOrigins.originRequest, *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateClickPipe.t.Fatal("No results are set for the ClientMock.UpdateClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpdateClickPipe.funcUpdateClickPipe != nil {
		return mmUpdateClickPipe.funcUpdateClickPipe(ctx, serviceId, clickPipeId, request)
	}
	mmUpdateClickPipe.t.Fatalf("Unexpected call to ClientMock.UpdateClickPipe. %v %v %v %v", ctx, serviceId, clickPipeId, request)
	return
}

// UpdateClickPipeAfterCounter returns a count of finished ClientMock.UpdateClickPipe invocations
func (mmUpdateClickPipe *ClientMock) UpdateClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClickPipe.afterUpdateClickPipeCounter)
}

// UpdateClickPipeBeforeCounter returns a count of ClientMock.UpdateClickPipe invocations
func (mmUpdateClickPipe *ClientMock) UpdateClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClickPipe.beforeUpdateClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Calls() []*ClientMockUpdateClickPipeParams {
	mmUpdateClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockUpdateClickPipeParams, len(mmUpdateClickPipe.callArgs))
	copy(argCopy, mmUpdateClickPipe.callArgs)

	mmUpdateClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateClickPipeDone returns true if the count of the UpdateClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateClickPipeDone() bool {
	if m.UpdateClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateClickPipeMock.invocationsDone()
}

// MinimockUpdateClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateClickPipeInspect() {
	for _, e := range m.UpdateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateClickPipeCounter := mm_atomic.LoadUint64(&m.afterUpdateClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClickPipeMock.defaultExpectation != nil && afterUpdateClickPipeCounter < 1 {
		if m.UpdateClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateClickPipe at\n%s", m.UpdateClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateClickPipe at\n%s with params: %#v", m.UpdateClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.UpdateClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClickPipe != nil && afterUpdateClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateClickPipe at\n%s", m.funcUpdateClickPipeOrigin)
	}

	if !m.UpdateClickPipeMock.invocationsDone() && afterUpdateClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateClickPipeMock.expectedInvocations), m.UpdateClickPipeMock.expectedInvocationsOrigin, afterUpdateClickPipeCounter)
	}
}

type mClientMockUpdateOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockUpdateOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockUpdateOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateOrganizationPrivateEndpointsParams
	paramPtrs          *ClientMockUpdateOrganizationPrivateEndpointsParamPtrs
	expectationOrigins ClientMockUpdateOrganizationPrivateEndpointsExpectationOrigins
	results            *ClientMockUpdateOrganizationPrivateEndpointsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsParams contains parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParams struct {
	ctx       context.Context
	orgUpdate OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	orgUpdate *OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsResults contains results of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// ClientMockUpdateOrganizationPrivateEndpointsOrigins contains origins of expectations of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectationOrigins struct {
	origin          string
	originCtx       string
	originOrgUpdate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Optional() *mClientMockUpdateOrganizationPrivateEndpoints {
	mmUpdateOrganizationPrivateEndpoints.optional = true
	return mmUpdateOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Expect(ctx context.Context, orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectOrgUpdateParam2 sets up expected param orgUpdate for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectOrgUpdateParam2(orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.orgUpdate = &orgUpdate
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.originOrgUpdate = minimock.CallerInfo(1)

	return mmUpdateOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context, orgUpdate OrganizationUpdate)) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints = f

	return mmUpdateOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{mock: mmUpdateOrganizationPrivateEndpoints.mock}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.UpdateOrganizationPrivateEndpoints method
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Set(f func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	if len(mmUpdateOrganizationPrivateEndpoints.expectations) > 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints = f
	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpointsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.UpdateOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) When(ctx context.Context, orgUpdate OrganizationUpdate) *ClientMockUpdateOrganizationPrivateEndpointsExpectation {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockUpdateOrganizationPrivateEndpointsExpectation{
		mock:               mmUpdateOrganizationPrivateEndpoints.mock,
		params:             &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate},
		expectationOrigins: ClientMockUpdateOrganizationPrivateEndpointsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrganizationPrivateEndpoints.expectations = append(mmUpdateOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.UpdateOrganizationPrivateEndpoints should be invoked
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Times(n uint64) *mClientMockUpdateOrganizationPrivateEndpoints {
	if n == 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.UpdateOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations, n)
	mmUpdateOrganizationPrivateEndpoints.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationPrivateEndpoints
}

func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmUpdateOrganizationPrivateEndpoints.expectations) == 0 && mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil && mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.mock.afterUpdateOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrganizationPrivateEndpoints implements Client
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpoints(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter, 1)

	mmUpdateOrganizationPrivateEndpoints.t.Helper()

	if mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}

	mm_params := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

	// Record call args
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Lock()
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs = append(mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orgUpdate != nil && !minimock.Equal(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter orgUpdate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.originOrgUpdate, *mm_want_ptrs.orgUpdate, mm_got.orgUpdate, minimock.Diff(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.UpdateOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints != nil {
		return mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}
	mmUpdateOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.UpdateOrganizationPrivateEndpoints. %v %v", ctx, orgUpdate)
	return
}

// UpdateOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter)
}

// UpdateOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Calls() []*ClientMockUpdateOrganizationPrivateEndpointsParams {
	mmUpdateOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockUpdateOrganizationPrivateEndpointsParams, len(mmUpdateOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmUpdateOrganizationPrivateEndpoints.callArgs)

	mmUpdateOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrganizationPrivateEndpointsDone returns true if the count of the UpdateOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsDone() bool {
	if m.UpdateOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockUpdateOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsInspect() {
	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterUpdateOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s", m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s with params: %#v", m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrganizationPrivateEndpoints != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s", m.funcUpdateOrganizationPrivateEndpointsOrigin)
	}

	if !m.UpdateOrganizationPrivateEndpointsMock.invocationsDone() && afterUpdateOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrganizationPrivateEndpointsMock.expectedInvocations), m.UpdateOrganizationPrivateEndpointsMock.expectedInvocationsOrigin, afterUpdateOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockUpdateReplicaScaling struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateReplicaScalingExpectation
	expectations       []*ClientMockUpdateReplicaScalingExpectation

	callArgs []*ClientMockUpdateReplicaScalingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateReplicaScalingExpectation specifies expectation struct of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateReplicaScalingParams
	paramPtrs          *ClientMockUpdateReplicaScalingParamPtrs
	expectationOrigins ClientMockUpdateReplicaScalingExpectationOrigins
	results            *ClientMockUpdateReplicaScalingResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateReplicaScalingParams contains parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParams struct {
	ctx       context.Context
	serviceId string
	s         ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingParamPtrs contains pointers to parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingResults contains results of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingResults struct {
	sp1 *Service
	err error
}

// ClientMockUpdateReplicaScalingOrigins contains origins of expectations of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originS         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Optional() *mClientMockUpdateReplicaScaling {
	mmUpdateReplicaScaling.optional = true
	return mmUpdateReplicaScaling
}

// Expect sets up expected params for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Expect(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by ExpectParams functions")
	}

	mmUpdateReplicaScaling.defaultExpectation.params = &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateReplicaScaling.expectations {
		if minimock.Equal(e.params, mmUpdateReplicaScaling.defaultExpectation.params) {
			mmUpdateReplicaScaling.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReplicaScaling.defaultExpectation.params)
		}
	}

	return mmUpdateReplicaScaling
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateReplicaScaling
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateReplicaScaling
}

// ExpectSParam3 sets up expected param s for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectSParam3(s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.s = &s
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.originS = minimock.CallerInfo(1)

	return mmUpdateReplicaScaling
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Inspect(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateReplicaScaling")
	}

	mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling = f

	return mmUpdateReplicaScaling
}

// Return sets up results that will be returned by Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{mock: mmUpdateReplicaScaling.mock}
	}
	mmUpdateReplicaScaling.defaultExpectation.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	mmUpdateReplicaScaling.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateReplicaScaling.mock
}

// Set uses given function f to mock the Client.UpdateReplicaScaling method
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Set(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateReplicaScaling.defaultExpectation != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Default expectation is already set for the Client.UpdateReplicaScaling method")
	}

	if len(mmUpdateReplicaScaling.expectations) > 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Some expectations are already set for the Client.UpdateReplicaScaling method")
	}

	mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling = f
	mmUpdateReplicaScaling.mock.funcUpdateReplicaScalingOrigin = minimock.CallerInfo(1)
	return mmUpdateReplicaScaling.mock
}

// When sets expectation for the Client.UpdateReplicaScaling which will trigger the result defined by the following
// Then helper
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) When(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *ClientMockUpdateReplicaScalingExpectation {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	expectation := &ClientMockUpdateReplicaScalingExpectation{
		mock:               mmUpdateReplicaScaling.mock,
		params:             &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s},
		expectationOrigins: ClientMockUpdateReplicaScalingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateReplicaScaling.expectations = append(mmUpdateReplicaScaling.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateReplicaScaling return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateReplicaScalingExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateReplicaScaling should be invoked
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Times(n uint64) *mClientMockUpdateReplicaScaling {
	if n == 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Times of ClientMock.UpdateReplicaScaling mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReplicaScaling.expectedInvocations, n)
	mmUpdateReplicaScaling.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateReplicaScaling
}

func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) invocationsDone() bool {
	if len(mmUpdateReplicaScaling.expectations) == 0 && mmUpdateReplicaScaling.defaultExpectation == nil && mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.mock.afterUpdateReplicaScalingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReplicaScaling implements Client
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScaling(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter, 1)

	mmUpdateReplicaScaling.t.Helper()

	if mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

	// Record call args
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Lock()
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs = append(mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs, &mm_params)
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Unlock()

	for _, e := range mmUpdateReplicaScaling.UpdateReplicaScalingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter s, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.originS, *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReplicaScaling.t.Fatal("No results are set for the ClientMock.UpdateReplicaScaling")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateReplicaScaling.funcUpdateReplicaScaling != nil {
		return mmUpdateReplicaScaling.funcUpdateReplicaScaling(ctx, serviceId, s)
	}
	mmUpdateReplicaScaling.t.Fatalf("Unexpected call to ClientMock.UpdateReplicaScaling. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateReplicaScalingAfterCounter returns a count of finished ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter)
}

// UpdateReplicaScalingBeforeCounter returns a count of ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateReplicaScaling.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Calls() []*ClientMockUpdateReplicaScalingParams {
	mmUpdateReplicaScaling.mutex.RLock()

	argCopy := make([]*ClientMockUpdateReplicaScalingParams, len(mmUpdateReplicaScaling.callArgs))
	copy(argCopy, mmUpdateReplicaScaling.callArgs)

	mmUpdateReplicaScaling.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReplicaScalingDone returns true if the count of the UpdateReplicaScaling invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateReplicaScalingDone() bool {
	if m.UpdateReplicaScalingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReplicaScalingMock.invocationsDone()
}

// MinimockUpdateReplicaScalingInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateReplicaScalingInspect() {
	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateReplicaScalingCounter := mm_atomic.LoadUint64(&m.afterUpdateReplicaScalingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReplicaScalingMock.defaultExpectation != nil && afterUpdateReplicaScalingCounter < 1 {
		if m.UpdateReplicaScalingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s", m.UpdateReplicaScalingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s with params: %#v", m.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.origin, *m.UpdateReplicaScalingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReplicaScaling != nil && afterUpdateReplicaScalingCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s", m.funcUpdateReplicaScalingOrigin)
	}

	if !m.UpdateReplicaScalingMock.invocationsDone() && afterUpdateReplicaScalingCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateReplicaScaling at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReplicaScalingMock.expectedInvocations), m.UpdateReplicaScalingMock.expectedInvocationsOrigin, afterUpdateReplicaScalingCounter)
	}
}

type mClientMockUpdateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServiceExpectation
	expectations       []*ClientMockUpdateServiceExpectation

	callArgs []*ClientMockUpdateServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateServiceExpectation specifies expectation struct of the Client.UpdateService
type ClientMockUpdateServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateServiceParams
	paramPtrs          *ClientMockUpdateServiceParamPtrs
	expectationOrigins ClientMockUpdateServiceExpectationOrigins
	results            *ClientMockUpdateServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateServiceParams contains parameters of the Client.UpdateService
type ClientMockUpdateServiceParams struct {
	ctx       context.Context
	serviceId string
	s         ServiceUpdate
}

// ClientMockUpdateServiceParamPtrs contains pointers to parameters of the Client.UpdateService
type ClientMockUpdateServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ServiceUpdate
}

// ClientMockUpdateServiceResults contains results of the Client.UpdateService
type ClientMockUpdateServiceResults struct {
	sp1 *Service
	err error
}

// ClientMockUpdateServiceOrigins contains origins of expectations of the Client.UpdateService
type ClientMockUpdateServiceExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originS         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateService *mClientMockUpdateService) Optional() *mClientMockUpdateService {
	mmUpdateService.optional = true
	return mmUpdateService
}

// Expect sets up expected params for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Expect(ctx context.Context, serviceId string, s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.paramPtrs != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by ExpectParams functions")
	}

	mmUpdateService.defaultExpectation.params = &ClientMockUpdateServiceParams{ctx, serviceId, s}
	mmUpdateService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateService.expectations {
		if minimock.Equal(e.params, mmUpdateService.defaultExpectation.params) {
			mmUpdateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateService.defaultExpectation.params)
		}
	}

	return mmUpdateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateService.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateService
}

// ExpectSParam3 sets up expected param s for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectSParam3(s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.s = &s
	mmUpdateService.defaultExpectation.expectationOrigins.originS = minimock.CallerInfo(1)

	return mmUpdateService
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Inspect(f func(ctx context.Context, serviceId string, s ServiceUpdate)) *mClientMockUpdateService {
	if mmUpdateService.mock.inspectFuncUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateService")
	}

	mmUpdateService.mock.inspectFuncUpdateService = f

	return mmUpdateService
}

// Return sets up results that will be returned by Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{mock: mmUpdateService.mock}
	}
	mmUpdateService.defaultExpectation.results = &ClientMockUpdateServiceResults{sp1, err}
	mmUpdateService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateService.mock
}

// Set uses given function f to mock the Client.UpdateService method
func (mmUpdateService *mClientMockUpdateService) Set(f func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateService.defaultExpectation != nil {
		mmUpdateService.mock.t.Fatalf("Default expectation is already set for the Client.UpdateService method")
	}

	if len(mmUpdateService.expectations) > 0 {
		mmUpdateService.mock.t.Fatalf("Some expectations are already set for the Client.UpdateService method")
	}

	mmUpdateService.mock.funcUpdateService = f
	mmUpdateService.mock.funcUpdateServiceOrigin = minimock.CallerInfo(1)
	return mmUpdateService.mock
}

// When sets expectation for the Client.UpdateService which will trigger the result defined by the following
// Then helper
func (mmUpdateService *mClientMockUpdateService) When(ctx context.Context, serviceId string, s ServiceUpdate) *ClientMockUpdateServiceExpectation {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	expectation := &ClientMockUpdateServiceExpectation{
		mock:               mmUpdateService.mock,
		params:             &ClientMockUpdateServiceParams{ctx, serviceId, s},
		expectationOrigins: ClientMockUpdateServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateService.expectations = append(mmUpdateService.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateService return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateService should be invoked
func (mmUpdateService *mClientMockUpdateService) Times(n uint64) *mClientMockUpdateService {
	if n == 0 {
		mmUpdateService.mock.t.Fatalf("Times of ClientMock.UpdateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateService.expectedInvocations, n)
	mmUpdateService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateService
}

func (mmUpdateService *mClientMockUpdateService) invocationsDone() bool {
	if len(mmUpdateService.expectations) == 0 && mmUpdateService.defaultExpectation == nil && mmUpdateService.mock.funcUpdateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateService.mock.afterUpdateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateService implements Client
func (mmUpdateService *ClientMock) UpdateService(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateService.beforeUpdateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateService.afterUpdateServiceCounter, 1)

	mmUpdateService.t.Helper()

	if mmUpdateService.inspectFuncUpdateService != nil {
		mmUpdateService.inspectFuncUpdateService(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateServiceParams{ctx, serviceId, s}

	// Record call args
	mmUpdateService.UpdateServiceMock.mutex.Lock()
	mmUpdateService.UpdateServiceMock.callArgs = append(mmUpdateService.UpdateServiceMock.callArgs, &mm_params)
	mmUpdateService.UpdateServiceMock.mutex.Unlock()

	for _, e := range mmUpdateService.UpdateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateService.UpdateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateService.UpdateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateService.UpdateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateService.UpdateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServiceParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter s, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.originS, *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateService.UpdateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateService.t.Fatal("No results are set for the ClientMock.UpdateService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateService.funcUpdateService != nil {
		return mmUpdateService.funcUpdateService(ctx, serviceId, s)
	}
	mmUpdateService.t.Fatalf("Unexpected call to ClientMock.UpdateService. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateServiceAfterCounter returns a count of finished ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.afterUpdateServiceCounter)
}

// UpdateServiceBeforeCounter returns a count of ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.beforeUpdateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateService *mClientMockUpdateService) Calls() []*ClientMockUpdateServiceParams {
	mmUpdateService.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServiceParams, len(mmUpdateService.callArgs))
	copy(argCopy, mmUpdateService.callArgs)

	mmUpdateService.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServiceDone returns true if the count of the UpdateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServiceDone() bool {
	if m.UpdateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServiceMock.invocationsDone()
}

// MinimockUpdateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServiceInspect() {
	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateServiceCounter := mm_atomic.LoadUint64(&m.afterUpdateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServiceMock.defaultExpectation != nil && afterUpdateServiceCounter < 1 {
		if m.UpdateServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s", m.UpdateServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s with params: %#v", m.UpdateServiceMock.defaultExpectation.expectationOrigins.origin, *m.UpdateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateService != nil && afterUpdateServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s", m.funcUpdateServiceOrigin)
	}

	if !m.UpdateServiceMock.invocationsDone() && afterUpdateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServiceMock.expectedInvocations), m.UpdateServiceMock.expectedInvocationsOrigin, afterUpdateServiceCounter)
	}
}

type mClientMockUpdateServicePassword struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServicePasswordExpectation
	expectations       []*ClientMockUpdateServicePasswordExpectation

	callArgs []*ClientMockUpdateServicePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateServicePasswordExpectation specifies expectation struct of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateServicePasswordParams
	paramPtrs          *ClientMockUpdateServicePasswordParamPtrs
	expectationOrigins ClientMockUpdateServicePasswordExpectationOrigins
	results            *ClientMockUpdateServicePasswordResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateServicePasswordParams contains parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParams struct {
	ctx       context.Context
	serviceId string
	u         ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordParamPtrs contains pointers to parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	u         *ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordResults contains results of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordResults struct {
	sp1 *ServicePasswordUpdateResult
	err error
}

// ClientMockUpdateServicePasswordOrigins contains origins of expectations of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originU         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Optional() *mClientMockUpdateServicePassword {
	mmUpdateServicePassword.optional = true
	return mmUpdateServicePassword
}

// Expect sets up expected params for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Expect(ctx context.Context, serviceId string, u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by ExpectParams functions")
	}

	mmUpdateServicePassword.defaultExpectation.params = &ClientMockUpdateServicePasswordParams{ctx, serviceId, u}
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateServicePassword.expectations {
		if minimock.Equal(e.params, mmUpdateServicePassword.defaultExpectation.params) {
			mmUpdateServicePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateServicePassword.defaultExpectation.params)
		}
	}

	return mmUpdateServicePassword
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateServicePassword
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateServicePassword
}

// ExpectUParam3 sets up expected param u for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectUParam3(u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.u = &u
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.originU = minimock.CallerInfo(1)

	return mmUpdateServicePassword
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Inspect(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate)) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateServicePassword")
	}

	mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword = f

	return mmUpdateServicePassword
}

// Return sets up results that will be returned by Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Return(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{mock: mmUpdateServicePassword.mock}
	}
	mmUpdateServicePassword.defaultExpectation.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	mmUpdateServicePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateServicePassword.mock
}

// Set uses given function f to mock the Client.UpdateServicePassword method
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Set(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)) *ClientMock {
	if mmUpdateServicePassword.defaultExpectation != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Default expectation is already set for the Client.UpdateServicePassword method")
	}

	if len(mmUpdateServicePassword.expectations) > 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Some expectations are already set for the Client.UpdateServicePassword method")
	}

	mmUpdateServicePassword.mock.funcUpdateServicePassword = f
	mmUpdateServicePassword.mock.funcUpdateServicePasswordOrigin = minimock.CallerInfo(1)
	return mmUpdateServicePassword.mock
}

// When sets expectation for the Client.UpdateServicePassword which will trigger the result defined by the following
// Then helper
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) When(ctx context.Context, serviceId string, u ServicePasswordUpdate) *ClientMockUpdateServicePasswordExpectation {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	expectation := &ClientMockUpdateServicePasswordExpectation{
		mock:               mmUpdateServicePassword.mock,
		params:             &ClientMockUpdateServicePasswordParams{ctx, serviceId, u},
		expectationOrigins: ClientMockUpdateServicePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateServicePassword.expectations = append(mmUpdateServicePassword.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateServicePassword return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServicePasswordExpectation) Then(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	e.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateServicePassword should be invoked
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Times(n uint64) *mClientMockUpdateServicePassword {
	if n == 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Times of ClientMock.UpdateServicePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateServicePassword.expectedInvocations, n)
	mmUpdateServicePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateServicePassword
}

func (mmUpdateServicePassword *mClientMockUpdateServicePassword) invocationsDone() bool {
	if len(mmUpdateServicePassword.expectations) == 0 && mmUpdateServicePassword.defaultExpectation == nil && mmUpdateServicePassword.mock.funcUpdateServicePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.mock.afterUpdateServicePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateServicePassword implements Client
func (mmUpdateServicePassword *ClientMock) UpdateServicePassword(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error) {
	mm_atomic.AddUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter, 1)

	mmUpdateServicePassword.t.Helper()

	if mmUpdateServicePassword.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.inspectFuncUpdateServicePassword(ctx, serviceId, u)
	}

	mm_params := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

	// Record call args
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Lock()
	mmUpdateServicePassword.UpdateServicePasswordMock.callArgs = append(mmUpdateServicePassword.UpdateServicePasswordMock.callArgs, &mm_params)
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Unlock()

	for _, e := range mmUpdateServicePassword.UpdateServicePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.u != nil && !minimock.Equal(*mm_want_ptrs.u, mm_got.u) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter u, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.originU, *mm_want_ptrs.u, mm_got.u, minimock.Diff(*mm_want_ptrs.u, mm_got.u))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateServicePassword.t.Fatal("No results are set for the ClientMock.UpdateServicePassword")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateServicePassword.funcUpdateServicePassword != nil {
		return mmUpdateServicePassword.funcUpdateServicePassword(ctx, serviceId, u)
	}
	mmUpdateServicePassword.t.Fatalf("Unexpected call to ClientMock.UpdateServicePassword. %v %v %v", ctx, serviceId, u)
	return
}

// UpdateServicePasswordAfterCounter returns a count of finished ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter)
}

// UpdateServicePasswordBeforeCounter returns a count of ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateServicePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Calls() []*ClientMockUpdateServicePasswordParams {
	mmUpdateServicePassword.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServicePasswordParams, len(mmUpdateServicePassword.callArgs))
	copy(argCopy, mmUpdateServicePassword.callArgs)

	mmUpdateServicePassword.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServicePasswordDone returns true if the count of the UpdateServicePassword invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServicePasswordDone() bool {
	if m.UpdateServicePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServicePasswordMock.invocationsDone()
}

// MinimockUpdateServicePasswordInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServicePasswordInspect() {
	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateServicePasswordCounter := mm_atomic.LoadUint64(&m.afterUpdateServicePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServicePasswordMock.defaultExpectation != nil && afterUpdateServicePasswordCounter < 1 {
		if m.UpdateServicePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s", m.UpdateServicePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s with params: %#v", m.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.origin, *m.UpdateServicePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateServicePassword != nil && afterUpdateServicePasswordCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s", m.funcUpdateServicePasswordOrigin)
	}

	if !m.UpdateServicePasswordMock.invocationsDone() && afterUpdateServicePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateServicePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServicePasswordMock.expectedInvocations), m.UpdateServicePasswordMock.expectedInvocationsOrigin, afterUpdateServicePasswordCounter)
	}
}

type mClientMockWaitForClickPipeState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForClickPipeStateExpectation
	expectations       []*ClientMockWaitForClickPipeStateExpectation

	callArgs []*ClientMockWaitForClickPipeStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockWaitForClickPipeStateExpectation specifies expectation struct of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateExpectation struct {
	mock               *ClientMock
	params             *ClientMockWaitForClickPipeStateParams
	paramPtrs          *ClientMockWaitForClickPipeStateParamPtrs
	expectationOrigins ClientMockWaitForClickPipeStateExpectationOrigins
	results            *ClientMockWaitForClickPipeStateResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockWaitForClickPipeStateParams contains parameters of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateParams struct {
	ctx            context.Context
	serviceId      string
	clickPipeId    string
	stateChecker   func(string) bool
	maxWaitSeconds uint64
}

// ClientMockWaitForClickPipeStateParamPtrs contains pointers to parameters of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	clickPipeId    *string
	stateChecker   *func(string) bool
	maxWaitSeconds *uint64
}

// ClientMockWaitForClickPipeStateResults contains results of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockWaitForClickPipeStateOrigins contains origins of expectations of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateExpectationOrigins struct {
	origin               string
	originCtx            string
	originServiceId      string
	originClickPipeId    string
	originStateChecker   string
	originMaxWaitSeconds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Optional() *mClientMockWaitForClickPipeState {
	mmWaitForClickPipeState.optional = true
	return mmWaitForClickPipeState
}

// Expect sets up expected params for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Expect(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by ExpectParams functions")
	}

	mmWaitForClickPipeState.defaultExpectation.params = &ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}
	mmWaitForClickPipeState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWaitForClickPipeState.expectations {
		if minimock.Equal(e.params, mmWaitForClickPipeState.defaultExpectation.params) {
			mmWaitForClickPipeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForClickPipeState.defaultExpectation.params)
		}
	}

	return mmWaitForClickPipeState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.ctx = &ctx
	mmWaitForClickPipeState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWaitForClickPipeState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmWaitForClickPipeState.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmWaitForClickPipeState
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmWaitForClickPipeState.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmWaitForClickPipeState
}

// ExpectStateCheckerParam4 sets up expected param stateChecker for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectStateCheckerParam4(stateChecker func(string) bool) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.stateChecker = &stateChecker
	mmWaitForClickPipeState.defaultExpectation.expectationOrigins.originStateChecker = minimock.CallerInfo(1)

	return mmWaitForClickPipeState
}

// ExpectMaxWaitSecondsParam5 sets up expected param maxWaitSeconds for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectMaxWaitSecondsParam5(maxWaitSeconds uint64) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds
	mmWaitForClickPipeState.defaultExpectation.expectationOrigins.originMaxWaitSeconds = minimock.CallerInfo(1)

	return mmWaitForClickPipeState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64)) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.inspectFuncWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForClickPipeState")
	}

	mmWaitForClickPipeState.mock.inspectFuncWaitForClickPipeState = f

	return mmWaitForClickPipeState
}

// Return sets up results that will be returned by Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{mock: mmWaitForClickPipeState.mock}
	}
	mmWaitForClickPipeState.defaultExpectation.results = &ClientMockWaitForClickPipeStateResults{cp1, err}
	mmWaitForClickPipeState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWaitForClickPipeState.mock
}

// Set uses given function f to mock the Client.WaitForClickPipeState method
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Set(f func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmWaitForClickPipeState.defaultExpectation != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForClickPipeState method")
	}

	if len(mmWaitForClickPipeState.expectations) > 0 {
		mmWaitForClickPipeState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForClickPipeState method")
	}

	mmWaitForClickPipeState.mock.funcWaitForClickPipeState = f
	mmWaitForClickPipeState.mock.funcWaitForClickPipeStateOrigin = minimock.CallerInfo(1)
	return mmWaitForClickPipeState.mock
}

// When sets expectation for the Client.WaitForClickPipeState which will trigger the result defined by the following
// Then helper
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) When(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) *ClientMockWaitForClickPipeStateExpectation {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockWaitForClickPipeStateExpectation{
		mock:               mmWaitForClickPipeState.mock,
		params:             &ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds},
		expectationOrigins: ClientMockWaitForClickPipeStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWaitForClickPipeState.expectations = append(mmWaitForClickPipeState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForClickPipeState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForClickPipeStateExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockWaitForClickPipeStateResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.WaitForClickPipeState should be invoked
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Times(n uint64) *mClientMockWaitForClickPipeState {
	if n == 0 {
		mmWaitForClickPipeState.mock.t.Fatalf("Times of ClientMock.WaitForClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForClickPipeState.expectedInvocations, n)
	mmWaitForClickPipeState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWaitForClickPipeState
}

func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) invocationsDone() bool {
	if len(mmWaitForClickPipeState.expectations) == 0 && mmWaitForClickPipeState.defaultExpectation == nil && mmWaitForClickPipeState.mock.funcWaitForClickPipeState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForClickPipeState.mock.afterWaitForClickPipeStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForClickPipeState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForClickPipeState implements Client
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeState(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmWaitForClickPipeState.beforeWaitForClickPipeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForClickPipeState.afterWaitForClickPipeStateCounter, 1)

	mmWaitForClickPipeState.t.Helper()

	if mmWaitForClickPipeState.inspectFuncWaitForClickPipeState != nil {
		mmWaitForClickPipeState.inspectFuncWaitForClickPipeState(ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForClickPipeState.WaitForClickPipeStateMock.mutex.Lock()
	mmWaitForClickPipeState.WaitForClickPipeStateMock.callArgs = append(mmWaitForClickPipeState.WaitForClickPipeStateMock.callArgs, &mm_params)
	mmWaitForClickPipeState.WaitForClickPipeStateMock.mutex.Unlock()

	for _, e := range mmWaitForClickPipeState.WaitForClickPipeStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter stateChecker, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.originStateChecker, *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter maxWaitSeconds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.originMaxWaitSeconds, *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForClickPipeState.t.Fatal("No results are set for the ClientMock.WaitForClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmWaitForClickPipeState.funcWaitForClickPipeState != nil {
		return mmWaitForClickPipeState.funcWaitForClickPipeState(ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	}
	mmWaitForClickPipeState.t.Fatalf("Unexpected call to ClientMock.WaitForClickPipeState. %v %v %v %v %v", ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	return
}

// WaitForClickPipeStateAfterCounter returns a count of finished ClientMock.WaitForClickPipeState invocations
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForClickPipeState.afterWaitForClickPipeStateCounter)
}

// WaitForClickPipeStateBeforeCounter returns a count of ClientMock.WaitForClickPipeState invocations
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForClickPipeState.beforeWaitForClickPipeStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForClickPipeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Calls() []*ClientMockWaitForClickPipeStateParams {
	mmWaitForClickPipeState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForClickPipeStateParams, len(mmWaitForClickPipeState.callArgs))
	copy(argCopy, mmWaitForClickPipeState.callArgs)

	mmWaitForClickPipeState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForClickPipeStateDone returns true if the count of the WaitForClickPipeState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForClickPipeStateDone() bool {
	if m.WaitForClickPipeStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForClickPipeStateMock.invocationsDone()
}

// MinimockWaitForClickPipeStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForClickPipeStateInspect() {
	for _, e := range m.WaitForClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWaitForClickPipeStateCounter := mm_atomic.LoadUint64(&m.afterWaitForClickPipeStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForClickPipeStateMock.defaultExpectation != nil && afterWaitForClickPipeStateCounter < 1 {
		if m.WaitForClickPipeStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState at\n%s", m.WaitForClickPipeStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState at\n%s with params: %#v", m.WaitForClickPipeStateMock.defaultExpectation.expectationOrigins.origin, *m.WaitForClickPipeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForClickPipeState != nil && afterWaitForClickPipeStateCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState at\n%s", m.funcWaitForClickPipeStateOrigin)
	}

	if !m.WaitForClickPipeStateMock.invocationsDone() && afterWaitForClickPipeStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForClickPipeState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForClickPipeStateMock.expectedInvocations), m.WaitForClickPipeStateMock.expectedInvocationsOrigin, afterWaitForClickPipeStateCounter)
	}
}

type mClientMockWaitForReversePrivateEndpointState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForReversePrivateEndpointStateExpectation
	expectations       []*ClientMockWaitForReversePrivateEndpointStateExpectation

	callArgs []*ClientMockWaitForReversePrivateEndpointStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockWaitForReversePrivateEndpointStateExpectation specifies expectation struct of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateExpectation struct {
	mock               *ClientMock
	params             *ClientMockWaitForReversePrivateEndpointStateParams
	paramPtrs          *ClientMockWaitForReversePrivateEndpointStateParamPtrs
	expectationOrigins ClientMockWaitForReversePrivateEndpointStateExpectationOrigins
	results            *ClientMockWaitForReversePrivateEndpointStateResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockWaitForReversePrivateEndpointStateParams contains parameters of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateParams struct {
	ctx                      context.Context
	serviceId                string
	reversePrivateEndpointId string
	stateChecker             func(string) bool
	maxWaitSeconds           uint64
}

// ClientMockWaitForReversePrivateEndpointStateParamPtrs contains pointers to parameters of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateParamPtrs struct {
	ctx                      *context.Context
	serviceId                *string
	reversePrivateEndpointId *string
	stateChecker             *func(string) bool
	maxWaitSeconds           *uint64
}

// ClientMockWaitForReversePrivateEndpointStateResults contains results of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateResults struct {
	rp1 *ReversePrivateEndpoint
	err error
}

// ClientMockWaitForReversePrivateEndpointStateOrigins contains origins of expectations of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateExpectationOrigins struct {
	origin                         string
	originCtx                      string
	originServiceId                string
	originReversePrivateEndpointId string
	originStateChecker             string
	originMaxWaitSeconds           string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Optional() *mClientMockWaitForReversePrivateEndpointState {
	mmWaitForReversePrivateEndpointState.optional = true
	return mmWaitForReversePrivateEndpointState
}

// Expect sets up expected params for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Expect(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by ExpectParams functions")
	}

	mmWaitForReversePrivateEndpointState.defaultExpectation.params = &ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds}
	mmWaitForReversePrivateEndpointState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWaitForReversePrivateEndpointState.expectations {
		if minimock.Equal(e.params, mmWaitForReversePrivateEndpointState.defaultExpectation.params) {
			mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForReversePrivateEndpointState.defaultExpectation.params)
		}
	}

	return mmWaitForReversePrivateEndpointState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.ctx = &ctx
	mmWaitForReversePrivateEndpointState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWaitForReversePrivateEndpointState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmWaitForReversePrivateEndpointState.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmWaitForReversePrivateEndpointState
}

// ExpectReversePrivateEndpointIdParam3 sets up expected param reversePrivateEndpointId for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectReversePrivateEndpointIdParam3(reversePrivateEndpointId string) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId
	mmWaitForReversePrivateEndpointState.defaultExpectation.expectationOrigins.originReversePrivateEndpointId = minimock.CallerInfo(1)

	return mmWaitForReversePrivateEndpointState
}

// ExpectStateCheckerParam4 sets up expected param stateChecker for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectStateCheckerParam4(stateChecker func(string) bool) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.stateChecker = &stateChecker
	mmWaitForReversePrivateEndpointState.defaultExpectation.expectationOrigins.originStateChecker = minimock.CallerInfo(1)

	return mmWaitForReversePrivateEndpointState
}

// ExpectMaxWaitSecondsParam5 sets up expected param maxWaitSeconds for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectMaxWaitSecondsParam5(maxWaitSeconds uint64) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds
	mmWaitForReversePrivateEndpointState.defaultExpectation.expectationOrigins.originMaxWaitSeconds = minimock.CallerInfo(1)

	return mmWaitForReversePrivateEndpointState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Inspect(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64)) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.inspectFuncWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForReversePrivateEndpointState")
	}

	mmWaitForReversePrivateEndpointState.mock.inspectFuncWaitForReversePrivateEndpointState = f

	return mmWaitForReversePrivateEndpointState
}

// Return sets up results that will be returned by Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Return(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{mock: mmWaitForReversePrivateEndpointState.mock}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.results = &ClientMockWaitForReversePrivateEndpointStateResults{rp1, err}
	mmWaitForReversePrivateEndpointState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWaitForReversePrivateEndpointState.mock
}

// Set uses given function f to mock the Client.WaitForReversePrivateEndpointState method
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Set(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) (rp1 *ReversePrivateEndpoint, err error)) *ClientMock {
	if mmWaitForReversePrivateEndpointState.defaultExpectation != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForReversePrivateEndpointState method")
	}

	if len(mmWaitForReversePrivateEndpointState.expectations) > 0 {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForReversePrivateEndpointState method")
	}

	mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState = f
	mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointStateOrigin = minimock.CallerInfo(1)
	return mmWaitForReversePrivateEndpointState.mock
}

// When sets expectation for the Client.WaitForReversePrivateEndpointState which will trigger the result defined by the following
// Then helper
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) When(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) *ClientMockWaitForReversePrivateEndpointStateExpectation {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	expectation := &ClientMockWaitForReversePrivateEndpointStateExpectation{
		mock:               mmWaitForReversePrivateEndpointState.mock,
		params:             &ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds},
		expectationOrigins: ClientMockWaitForReversePrivateEndpointStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWaitForReversePrivateEndpointState.expectations = append(mmWaitForReversePrivateEndpointState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForReversePrivateEndpointState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForReversePrivateEndpointStateExpectation) Then(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockWaitForReversePrivateEndpointStateResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.WaitForReversePrivateEndpointState should be invoked
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Times(n uint64) *mClientMockWaitForReversePrivateEndpointState {
	if n == 0 {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Times of ClientMock.WaitForReversePrivateEndpointState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForReversePrivateEndpointState.expectedInvocations, n)
	mmWaitForReversePrivateEndpointState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWaitForReversePrivateEndpointState
}

func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) invocationsDone() bool {
	if len(mmWaitForReversePrivateEndpointState.expectations) == 0 && mmWaitForReversePrivateEndpointState.defaultExpectation == nil && mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.mock.afterWaitForReversePrivateEndpointStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForReversePrivateEndpointState implements Client
func (mmWaitForReversePrivateEndpointState *ClientMock) WaitForReversePrivateEndpointState(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) (rp1 *ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmWaitForReversePrivateEndpointState.beforeWaitForReversePrivateEndpointStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForReversePrivateEndpointState.afterWaitForReversePrivateEndpointStateCounter, 1)

	mmWaitForReversePrivateEndpointState.t.Helper()

	if mmWaitForReversePrivateEndpointState.inspectFuncWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.inspectFuncWaitForReversePrivateEndpointState(ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.mutex.Lock()
	mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.callArgs = append(mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.callArgs, &mm_params)
	mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.mutex.Unlock()

	for _, e := range mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter reversePrivateEndpointId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.originReversePrivateEndpointId, *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter stateChecker, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.originStateChecker, *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter maxWaitSeconds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.originMaxWaitSeconds, *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForReversePrivateEndpointState.t.Fatal("No results are set for the ClientMock.WaitForReversePrivateEndpointState")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmWaitForReversePrivateEndpointState.funcWaitForReversePrivateEndpointState != nil {
		return mmWaitForReversePrivateEndpointState.funcWaitForReversePrivateEndpointState(ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds)
	}
	mmWaitForReversePrivateEndpointState.t.Fatalf("Unexpected call to ClientMock.WaitForReversePrivateEndpointState. %v %v %v %v %v", ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds)
	return
}

// WaitForReversePrivateEndpointStateAfterCounter returns a count of finished ClientMock.WaitForReversePrivateEndpointState invocations
func (mmWaitForReversePrivateEndpointState *ClientMock) WaitForReversePrivateEndpointStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.afterWaitForReversePrivateEndpointStateCounter)
}

// WaitForReversePrivateEndpointStateBeforeCounter returns a count of ClientMock.WaitForReversePrivateEndpointState invocations
func (mmWaitForReversePrivateEndpointState *ClientMock) WaitForReversePrivateEndpointStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.beforeWaitForReversePrivateEndpointStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForReversePrivateEndpointState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Calls() []*ClientMockWaitForReversePrivateEndpointStateParams {
	mmWaitForReversePrivateEndpointState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForReversePrivateEndpointStateParams, len(mmWaitForReversePrivateEndpointState.callArgs))
	copy(argCopy, mmWaitForReversePrivateEndpointState.callArgs)

	mmWaitForReversePrivateEndpointState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForReversePrivateEndpointStateDone returns true if the count of the WaitForReversePrivateEndpointState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForReversePrivateEndpointStateDone() bool {
	if m.WaitForReversePrivateEndpointStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForReversePrivateEndpointStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForReversePrivateEndpointStateMock.invocationsDone()
}

// MinimockWaitForReversePrivateEndpointStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForReversePrivateEndpointStateInspect() {
	for _, e := range m.WaitForReversePrivateEndpointStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForReversePrivateEndpointState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWaitForReversePrivateEndpointStateCounter := mm_atomic.LoadUint64(&m.afterWaitForReversePrivateEndpointStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForReversePrivateEndpointStateMock.defaultExpectation != nil && afterWaitForReversePrivateEndpointStateCounter < 1 {
		if m.WaitForReversePrivateEndpointStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.WaitForReversePrivateEndpointState at\n%s", m.WaitForReversePrivateEndpointStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForReversePrivateEndpointState at\n%s with params: %#v", m.WaitForReversePrivateEndpointStateMock.defaultExpectation.expectationOrigins.origin, *m.WaitForReversePrivateEndpointStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForReversePrivateEndpointState != nil && afterWaitForReversePrivateEndpointStateCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.WaitForReversePrivateEndpointState at\n%s", m.funcWaitForReversePrivateEndpointStateOrigin)
	}

	if !m.WaitForReversePrivateEndpointStateMock.invocationsDone() && afterWaitForReversePrivateEndpointStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForReversePrivateEndpointState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForReversePrivateEndpointStateMock.expectedInvocations), m.WaitForReversePrivateEndpointStateMock.expectedInvocationsOrigin, afterWaitForReversePrivateEndpointStateCounter)
	}
}

type mClientMockWaitForServiceState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForServiceStateExpectation
	expectations       []*ClientMockWaitForServiceStateExpectation

	callArgs []*ClientMockWaitForServiceStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockWaitForServiceStateExpectation specifies expectation struct of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectation struct {
	mock               *ClientMock
	params             *ClientMockWaitForServiceStateParams
	paramPtrs          *ClientMockWaitForServiceStateParamPtrs
	expectationOrigins ClientMockWaitForServiceStateExpectationOrigins
	results            *ClientMockWaitForServiceStateResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockWaitForServiceStateParams contains parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParams struct {
	ctx            context.Context
	serviceId      string
	stateChecker   func(string) bool
	maxWaitSeconds int
}

// ClientMockWaitForServiceStateParamPtrs contains pointers to parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	stateChecker   *func(string) bool
	maxWaitSeconds *int
}

// ClientMockWaitForServiceStateResults contains results of the Client.WaitForServiceState
type ClientMockWaitForServiceStateResults struct {
	err error
}

// ClientMockWaitForServiceStateOrigins contains origins of expectations of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectationOrigins struct {
	origin               string
	originCtx            string
	originServiceId      string
	originStateChecker   string
	originMaxWaitSeconds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForServiceState *mClientMockWaitForServiceState) Optional() *mClientMockWaitForServiceState {
	mmWaitForServiceState.optional = true
	return mmWaitForServiceState
}

// Expect sets up expected params for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Expect(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by ExpectParams functions")
	}

	mmWaitForServiceState.defaultExpectation.params = &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}
	mmWaitForServiceState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWaitForServiceState.expectations {
		if minimock.Equal(e.params, mmWaitForServiceState.defaultExpectation.params) {
			mmWaitForServiceState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForServiceState.defaultExpectation.params)
		}
	}

	return mmWaitForServiceState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.ctx = &ctx
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// ExpectStateCheckerParam3 sets up expected param stateChecker for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectStateCheckerParam3(stateChecker func(string) bool) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.stateChecker = &stateChecker
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originStateChecker = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// ExpectMaxWaitSecondsParam4 sets up expected param maxWaitSeconds for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectMaxWaitSecondsParam4(maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originMaxWaitSeconds = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Inspect(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForServiceState")
	}

	mmWaitForServiceState.mock.inspectFuncWaitForServiceState = f

	return mmWaitForServiceState
}

// Return sets up results that will be returned by Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Return(err error) *ClientMock {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{mock: mmWaitForServiceState.mock}
	}
	mmWaitForServiceState.defaultExpectation.results = &ClientMockWaitForServiceStateResults{err}
	mmWaitForServiceState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWaitForServiceState.mock
}

// Set uses given function f to mock the Client.WaitForServiceState method
func (mmWaitForServiceState *mClientMockWaitForServiceState) Set(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)) *ClientMock {
	if mmWaitForServiceState.defaultExpectation != nil {
		mmWaitForServiceState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForServiceState method")
	}

	if len(mmWaitForServiceState.expectations) > 0 {
		mmWaitForServiceState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForServiceState method")
	}

	mmWaitForServiceState.mock.funcWaitForServiceState = f
	mmWaitForServiceState.mock.funcWaitForServiceStateOrigin = minimock.CallerInfo(1)
	return mmWaitForServiceState.mock
}

// When sets expectation for the Client.WaitForServiceState which will trigger the result defined by the following
// Then helper
func (mmWaitForServiceState *mClientMockWaitForServiceState) When(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *ClientMockWaitForServiceStateExpectation {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	expectation := &ClientMockWaitForServiceStateExpectation{
		mock:               mmWaitForServiceState.mock,
		params:             &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds},
		expectationOrigins: ClientMockWaitForServiceStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWaitForServiceState.expectations = append(mmWaitForServiceState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForServiceState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForServiceStateExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockWaitForServiceStateResults{err}
	return e.mock
}

// Times sets number of times Client.WaitForServiceState should be invoked
func (mmWaitForServiceState *mClientMockWaitForServiceState) Times(n uint64) *mClientMockWaitForServiceState {
	if n == 0 {
		mmWaitForServiceState.mock.t.Fatalf("Times of ClientMock.WaitForServiceState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForServiceState.expectedInvocations, n)
	mmWaitForServiceState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWaitForServiceState
}

func (mmWaitForServiceState *mClientMockWaitForServiceState) invocationsDone() bool {
	if len(mmWaitForServiceState.expectations) == 0 && mmWaitForServiceState.defaultExpectation == nil && mmWaitForServiceState.mock.funcWaitForServiceState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.mock.afterWaitForServiceStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForServiceState implements Client
func (mmWaitForServiceState *ClientMock) WaitForServiceState(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error) {
	mm_atomic.AddUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter, 1)

	mmWaitForServiceState.t.Helper()

	if mmWaitForServiceState.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.inspectFuncWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Lock()
	mmWaitForServiceState.WaitForServiceStateMock.callArgs = append(mmWaitForServiceState.WaitForServiceStateMock.callArgs, &mm_params)
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Unlock()

	for _, e := range mmWaitForServiceState.WaitForServiceStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter stateChecker, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originStateChecker, *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter maxWaitSeconds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originMaxWaitSeconds, *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForServiceState.t.Fatal("No results are set for the ClientMock.WaitForServiceState")
		}
		return (*mm_results).err
	}
	if mmWaitForServiceState.funcWaitForServiceState != nil {
		return mmWaitForServiceState.funcWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}
	mmWaitForServiceState.t.Fatalf("Unexpected call to ClientMock.WaitForServiceState. %v %v %v %v", ctx, serviceId, stateChecker, maxWaitSeconds)
	return
}

// WaitForServiceStateAfterCounter returns a count of finished ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter)
}

// WaitForServiceStateBeforeCounter returns a count of ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForServiceState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForServiceState *mClientMockWaitForServiceState) Calls() []*ClientMockWaitForServiceStateParams {
	mmWaitForServiceState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForServiceStateParams, len(mmWaitForServiceState.callArgs))
	copy(argCopy, mmWaitForServiceState.callArgs)

	mmWaitForServiceState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForServiceStateDone returns true if the count of the WaitForServiceState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForServiceStateDone() bool {
	if m.WaitForServiceStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForServiceStateMock.invocationsDone()
}

// MinimockWaitForServiceStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForServiceStateInspect() {
	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWaitForServiceStateCounter := mm_atomic.LoadUint64(&m.afterWaitForServiceStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForServiceStateMock.defaultExpectation != nil && afterWaitForServiceStateCounter < 1 {
		if m.WaitForServiceStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s", m.WaitForServiceStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s with params: %#v", m.WaitForServiceStateMock.defaultExpectation.expectationOrigins.origin, *m.WaitForServiceStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForServiceState != nil && afterWaitForServiceStateCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s", m.funcWaitForServiceStateOrigin)
	}

	if !m.WaitForServiceStateMock.invocationsDone() && afterWaitForServiceStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForServiceState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForServiceStateMock.expectedInvocations), m.WaitForServiceStateMock.expectedInvocationsOrigin, afterWaitForServiceStateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangeClickPipeStateInspect()

			m.MinimockCreateClickPipeInspect()

			m.MinimockCreateQueryEndpointInspect()

			m.MinimockCreateReversePrivateEndpointInspect()

			m.MinimockCreateServiceInspect()

			m.MinimockDeleteClickPipeInspect()

			m.MinimockDeleteQueryEndpointInspect()

			m.MinimockDeleteReversePrivateEndpointInspect()

			m.MinimockDeleteServiceInspect()

			m.MinimockGetApiKeyIDInspect()

			m.MinimockGetBackupConfigurationInspect()

			m.MinimockGetClickPipeInspect()

			m.MinimockGetOrgPrivateEndpointConfigInspect()

			m.MinimockGetOrganizationPrivateEndpointsInspect()

			m.MinimockGetQueryEndpointInspect()

			m.MinimockGetReversePrivateEndpointInspect()

			m.MinimockGetReversePrivateEndpointPathInspect()

			m.MinimockGetServiceInspect()

			m.MinimockListReversePrivateEndpointsInspect()

			m.MinimockRotateTDEKeyInspect()

			m.MinimockScalingClickPipeInspect()

			m.MinimockUpdateBackupConfigurationInspect()

			m.MinimockUpdateClickPipeInspect()

			m.MinimockUpdateOrganizationPrivateEndpointsInspect()

			m.MinimockUpdateReplicaScalingInspect()

			m.MinimockUpdateServiceInspect()

			m.MinimockUpdateServicePasswordInspect()

			m.MinimockWaitForClickPipeStateInspect()

			m.MinimockWaitForReversePrivateEndpointStateInspect()

			m.MinimockWaitForServiceStateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangeClickPipeStateDone() &&
		m.MinimockCreateClickPipeDone() &&
		m.MinimockCreateQueryEndpointDone() &&
		m.MinimockCreateReversePrivateEndpointDone() &&
		m.MinimockCreateServiceDone() &&
		m.MinimockDeleteClickPipeDone() &&
		m.MinimockDeleteQueryEndpointDone() &&
		m.MinimockDeleteReversePrivateEndpointDone() &&
		m.MinimockDeleteServiceDone() &&
		m.MinimockGetApiKeyIDDone() &&
		m.MinimockGetBackupConfigurationDone() &&
		m.MinimockGetClickPipeDone() &&
		m.MinimockGetOrgPrivateEndpointConfigDone() &&
		m.MinimockGetOrganizationPrivateEndpointsDone() &&
		m.MinimockGetQueryEndpointDone() &&
		m.MinimockGetReversePrivateEndpointDone() &&
		m.MinimockGetReversePrivateEndpointPathDone() &&
		m.MinimockGetServiceDone() &&
		m.MinimockListReversePrivateEndpointsDone() &&
		m.MinimockRotateTDEKeyDone() &&
		m.MinimockScalingClickPipeDone() &&
		m.MinimockUpdateBackupConfigurationDone() &&
		m.MinimockUpdateClickPipeDone() &&
		m.MinimockUpdateOrganizationPrivateEndpointsDone() &&
		m.MinimockUpdateReplicaScalingDone() &&
		m.MinimockUpdateServiceDone() &&
		m.MinimockUpdateServicePasswordDone() &&
		m.MinimockWaitForClickPipeStateDone() &&
		m.MinimockWaitForReversePrivateEndpointStateDone() &&
		m.MinimockWaitForServiceStateDone()
}
