// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package api

//go:generate minimock -i github.com/ClickHouse/terraform-provider-clickhouse/pkg/internal/api.Client -o client_mock.go -n ClientMock -p api

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateClickPipe          func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)
	funcCreateClickPipeOrigin    string
	inspectFuncCreateClickPipe   func(ctx context.Context, serviceId string, clickPipe ClickPipe)
	afterCreateClickPipeCounter  uint64
	beforeCreateClickPipeCounter uint64
	CreateClickPipeMock          mClientMockCreateClickPipe

	funcCreateService          func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)
	funcCreateServiceOrigin    string
	inspectFuncCreateService   func(ctx context.Context, s Service)
	afterCreateServiceCounter  uint64
	beforeCreateServiceCounter uint64
	CreateServiceMock          mClientMockCreateService

	funcDeleteClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (err error)
	funcDeleteClickPipeOrigin    string
	inspectFuncDeleteClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterDeleteClickPipeCounter  uint64
	beforeDeleteClickPipeCounter uint64
	DeleteClickPipeMock          mClientMockDeleteClickPipe

	funcDeleteService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	funcDeleteServiceOrigin    string
	inspectFuncDeleteService   func(ctx context.Context, serviceId string)
	afterDeleteServiceCounter  uint64
	beforeDeleteServiceCounter uint64
	DeleteServiceMock          mClientMockDeleteService

	funcGetBackupConfiguration          func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)
	funcGetBackupConfigurationOrigin    string
	inspectFuncGetBackupConfiguration   func(ctx context.Context, serviceId string)
	afterGetBackupConfigurationCounter  uint64
	beforeGetBackupConfigurationCounter uint64
	GetBackupConfigurationMock          mClientMockGetBackupConfiguration

	funcGetClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)
	funcGetClickPipeOrigin    string
	inspectFuncGetClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterGetClickPipeCounter  uint64
	beforeGetClickPipeCounter uint64
	GetClickPipeMock          mClientMockGetClickPipe

	funcGetOrgPrivateEndpointConfig          func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)
	funcGetOrgPrivateEndpointConfigOrigin    string
	inspectFuncGetOrgPrivateEndpointConfig   func(ctx context.Context, cloudProvider string, region string)
	afterGetOrgPrivateEndpointConfigCounter  uint64
	beforeGetOrgPrivateEndpointConfigCounter uint64
	GetOrgPrivateEndpointConfigMock          mClientMockGetOrgPrivateEndpointConfig

	funcGetOrganizationPrivateEndpoints          func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)
	funcGetOrganizationPrivateEndpointsOrigin    string
	inspectFuncGetOrganizationPrivateEndpoints   func(ctx context.Context)
	afterGetOrganizationPrivateEndpointsCounter  uint64
	beforeGetOrganizationPrivateEndpointsCounter uint64
	GetOrganizationPrivateEndpointsMock          mClientMockGetOrganizationPrivateEndpoints

	funcGetService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	funcGetServiceOrigin    string
	inspectFuncGetService   func(ctx context.Context, serviceId string)
	afterGetServiceCounter  uint64
	beforeGetServiceCounter uint64
	GetServiceMock          mClientMockGetService

	funcPauseClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)
	funcPauseClickPipeOrigin    string
	inspectFuncPauseClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterPauseClickPipeCounter  uint64
	beforePauseClickPipeCounter uint64
	PauseClickPipeMock          mClientMockPauseClickPipe

	funcResumeClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)
	funcResumeClickPipeOrigin    string
	inspectFuncResumeClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterResumeClickPipeCounter  uint64
	beforeResumeClickPipeCounter uint64
	ResumeClickPipeMock          mClientMockResumeClickPipe

	funcScaleClickPipe          func(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64) (cp1 *ClickPipe, err error)
	funcScaleClickPipeOrigin    string
	inspectFuncScaleClickPipe   func(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64)
	afterScaleClickPipeCounter  uint64
	beforeScaleClickPipeCounter uint64
	ScaleClickPipeMock          mClientMockScaleClickPipe

	funcUpdateBackupConfiguration          func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)
	funcUpdateBackupConfigurationOrigin    string
	inspectFuncUpdateBackupConfiguration   func(ctx context.Context, serviceId string, b BackupConfiguration)
	afterUpdateBackupConfigurationCounter  uint64
	beforeUpdateBackupConfigurationCounter uint64
	UpdateBackupConfigurationMock          mClientMockUpdateBackupConfiguration

	funcUpdateOrganizationPrivateEndpoints          func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)
	funcUpdateOrganizationPrivateEndpointsOrigin    string
	inspectFuncUpdateOrganizationPrivateEndpoints   func(ctx context.Context, orgUpdate OrganizationUpdate)
	afterUpdateOrganizationPrivateEndpointsCounter  uint64
	beforeUpdateOrganizationPrivateEndpointsCounter uint64
	UpdateOrganizationPrivateEndpointsMock          mClientMockUpdateOrganizationPrivateEndpoints

	funcUpdateReplicaScaling          func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)
	funcUpdateReplicaScalingOrigin    string
	inspectFuncUpdateReplicaScaling   func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)
	afterUpdateReplicaScalingCounter  uint64
	beforeUpdateReplicaScalingCounter uint64
	UpdateReplicaScalingMock          mClientMockUpdateReplicaScaling

	funcUpdateService          func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)
	funcUpdateServiceOrigin    string
	inspectFuncUpdateService   func(ctx context.Context, serviceId string, s ServiceUpdate)
	afterUpdateServiceCounter  uint64
	beforeUpdateServiceCounter uint64
	UpdateServiceMock          mClientMockUpdateService

	funcUpdateServicePassword          func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)
	funcUpdateServicePasswordOrigin    string
	inspectFuncUpdateServicePassword   func(ctx context.Context, serviceId string, u ServicePasswordUpdate)
	afterUpdateServicePasswordCounter  uint64
	beforeUpdateServicePasswordCounter uint64
	UpdateServicePasswordMock          mClientMockUpdateServicePassword

	funcWaitForServiceState          func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)
	funcWaitForServiceStateOrigin    string
	inspectFuncWaitForServiceState   func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)
	afterWaitForServiceStateCounter  uint64
	beforeWaitForServiceStateCounter uint64
	WaitForServiceStateMock          mClientMockWaitForServiceState
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateClickPipeMock = mClientMockCreateClickPipe{mock: m}
	m.CreateClickPipeMock.callArgs = []*ClientMockCreateClickPipeParams{}

	m.CreateServiceMock = mClientMockCreateService{mock: m}
	m.CreateServiceMock.callArgs = []*ClientMockCreateServiceParams{}

	m.DeleteClickPipeMock = mClientMockDeleteClickPipe{mock: m}
	m.DeleteClickPipeMock.callArgs = []*ClientMockDeleteClickPipeParams{}

	m.DeleteServiceMock = mClientMockDeleteService{mock: m}
	m.DeleteServiceMock.callArgs = []*ClientMockDeleteServiceParams{}

	m.GetBackupConfigurationMock = mClientMockGetBackupConfiguration{mock: m}
	m.GetBackupConfigurationMock.callArgs = []*ClientMockGetBackupConfigurationParams{}

	m.GetClickPipeMock = mClientMockGetClickPipe{mock: m}
	m.GetClickPipeMock.callArgs = []*ClientMockGetClickPipeParams{}

	m.GetOrgPrivateEndpointConfigMock = mClientMockGetOrgPrivateEndpointConfig{mock: m}
	m.GetOrgPrivateEndpointConfigMock.callArgs = []*ClientMockGetOrgPrivateEndpointConfigParams{}

	m.GetOrganizationPrivateEndpointsMock = mClientMockGetOrganizationPrivateEndpoints{mock: m}
	m.GetOrganizationPrivateEndpointsMock.callArgs = []*ClientMockGetOrganizationPrivateEndpointsParams{}

	m.GetServiceMock = mClientMockGetService{mock: m}
	m.GetServiceMock.callArgs = []*ClientMockGetServiceParams{}

	m.PauseClickPipeMock = mClientMockPauseClickPipe{mock: m}
	m.PauseClickPipeMock.callArgs = []*ClientMockPauseClickPipeParams{}

	m.ResumeClickPipeMock = mClientMockResumeClickPipe{mock: m}
	m.ResumeClickPipeMock.callArgs = []*ClientMockResumeClickPipeParams{}

	m.ScaleClickPipeMock = mClientMockScaleClickPipe{mock: m}
	m.ScaleClickPipeMock.callArgs = []*ClientMockScaleClickPipeParams{}

	m.UpdateBackupConfigurationMock = mClientMockUpdateBackupConfiguration{mock: m}
	m.UpdateBackupConfigurationMock.callArgs = []*ClientMockUpdateBackupConfigurationParams{}

	m.UpdateOrganizationPrivateEndpointsMock = mClientMockUpdateOrganizationPrivateEndpoints{mock: m}
	m.UpdateOrganizationPrivateEndpointsMock.callArgs = []*ClientMockUpdateOrganizationPrivateEndpointsParams{}

	m.UpdateReplicaScalingMock = mClientMockUpdateReplicaScaling{mock: m}
	m.UpdateReplicaScalingMock.callArgs = []*ClientMockUpdateReplicaScalingParams{}

	m.UpdateServiceMock = mClientMockUpdateService{mock: m}
	m.UpdateServiceMock.callArgs = []*ClientMockUpdateServiceParams{}

	m.UpdateServicePasswordMock = mClientMockUpdateServicePassword{mock: m}
	m.UpdateServicePasswordMock.callArgs = []*ClientMockUpdateServicePasswordParams{}

	m.WaitForServiceStateMock = mClientMockWaitForServiceState{mock: m}
	m.WaitForServiceStateMock.callArgs = []*ClientMockWaitForServiceStateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockCreateClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateClickPipeExpectation
	expectations       []*ClientMockCreateClickPipeExpectation

	callArgs []*ClientMockCreateClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateClickPipeExpectation specifies expectation struct of the Client.CreateClickPipe
type ClientMockCreateClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateClickPipeParams
	paramPtrs          *ClientMockCreateClickPipeParamPtrs
	expectationOrigins ClientMockCreateClickPipeExpectationOrigins
	results            *ClientMockCreateClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateClickPipeParams contains parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParams struct {
	ctx       context.Context
	serviceId string
	clickPipe ClickPipe
}

// ClientMockCreateClickPipeParamPtrs contains pointers to parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	clickPipe *ClickPipe
}

// ClientMockCreateClickPipeResults contains results of the Client.CreateClickPipe
type ClientMockCreateClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockCreateClickPipeOrigins contains origins of expectations of the Client.CreateClickPipe
type ClientMockCreateClickPipeExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originClickPipe string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateClickPipe *mClientMockCreateClickPipe) Optional() *mClientMockCreateClickPipe {
	mmCreateClickPipe.optional = true
	return mmCreateClickPipe
}

// Expect sets up expected params for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Expect(ctx context.Context, serviceId string, clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by ExpectParams functions")
	}

	mmCreateClickPipe.defaultExpectation.params = &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}
	mmCreateClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateClickPipe.expectations {
		if minimock.Equal(e.params, mmCreateClickPipe.defaultExpectation.params) {
			mmCreateClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClickPipe.defaultExpectation.params)
		}
	}

	return mmCreateClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmCreateClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmCreateClickPipe
}

// ExpectClickPipeParam3 sets up expected param clickPipe for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectClickPipeParam3(clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.clickPipe = &clickPipe
	mmCreateClickPipe.defaultExpectation.expectationOrigins.originClickPipe = minimock.CallerInfo(1)

	return mmCreateClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipe ClickPipe)) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateClickPipe")
	}

	mmCreateClickPipe.mock.inspectFuncCreateClickPipe = f

	return mmCreateClickPipe
}

// Return sets up results that will be returned by Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{mock: mmCreateClickPipe.mock}
	}
	mmCreateClickPipe.defaultExpectation.results = &ClientMockCreateClickPipeResults{cp1, err}
	mmCreateClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateClickPipe.mock
}

// Set uses given function f to mock the Client.CreateClickPipe method
func (mmCreateClickPipe *mClientMockCreateClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmCreateClickPipe.defaultExpectation != nil {
		mmCreateClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.CreateClickPipe method")
	}

	if len(mmCreateClickPipe.expectations) > 0 {
		mmCreateClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.CreateClickPipe method")
	}

	mmCreateClickPipe.mock.funcCreateClickPipe = f
	mmCreateClickPipe.mock.funcCreateClickPipeOrigin = minimock.CallerInfo(1)
	return mmCreateClickPipe.mock
}

// When sets expectation for the Client.CreateClickPipe which will trigger the result defined by the following
// Then helper
func (mmCreateClickPipe *mClientMockCreateClickPipe) When(ctx context.Context, serviceId string, clickPipe ClickPipe) *ClientMockCreateClickPipeExpectation {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	expectation := &ClientMockCreateClickPipeExpectation{
		mock:               mmCreateClickPipe.mock,
		params:             &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe},
		expectationOrigins: ClientMockCreateClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateClickPipe.expectations = append(mmCreateClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockCreateClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.CreateClickPipe should be invoked
func (mmCreateClickPipe *mClientMockCreateClickPipe) Times(n uint64) *mClientMockCreateClickPipe {
	if n == 0 {
		mmCreateClickPipe.mock.t.Fatalf("Times of ClientMock.CreateClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateClickPipe.expectedInvocations, n)
	mmCreateClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateClickPipe
}

func (mmCreateClickPipe *mClientMockCreateClickPipe) invocationsDone() bool {
	if len(mmCreateClickPipe.expectations) == 0 && mmCreateClickPipe.defaultExpectation == nil && mmCreateClickPipe.mock.funcCreateClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.mock.afterCreateClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateClickPipe implements Client
func (mmCreateClickPipe *ClientMock) CreateClickPipe(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClickPipe.afterCreateClickPipeCounter, 1)

	mmCreateClickPipe.t.Helper()

	if mmCreateClickPipe.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.inspectFuncCreateClickPipe(ctx, serviceId, clickPipe)
	}

	mm_params := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

	// Record call args
	mmCreateClickPipe.CreateClickPipeMock.mutex.Lock()
	mmCreateClickPipe.CreateClickPipeMock.callArgs = append(mmCreateClickPipe.CreateClickPipeMock.callArgs, &mm_params)
	mmCreateClickPipe.CreateClickPipeMock.mutex.Unlock()

	for _, e := range mmCreateClickPipe.CreateClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateClickPipe.CreateClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipe != nil && !minimock.Equal(*mm_want_ptrs.clickPipe, mm_got.clickPipe) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter clickPipe, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.originClickPipe, *mm_want_ptrs.clickPipe, mm_got.clickPipe, minimock.Diff(*mm_want_ptrs.clickPipe, mm_got.clickPipe))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClickPipe.t.Fatal("No results are set for the ClientMock.CreateClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateClickPipe.funcCreateClickPipe != nil {
		return mmCreateClickPipe.funcCreateClickPipe(ctx, serviceId, clickPipe)
	}
	mmCreateClickPipe.t.Fatalf("Unexpected call to ClientMock.CreateClickPipe. %v %v %v", ctx, serviceId, clickPipe)
	return
}

// CreateClickPipeAfterCounter returns a count of finished ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.afterCreateClickPipeCounter)
}

// CreateClickPipeBeforeCounter returns a count of ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClickPipe *mClientMockCreateClickPipe) Calls() []*ClientMockCreateClickPipeParams {
	mmCreateClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockCreateClickPipeParams, len(mmCreateClickPipe.callArgs))
	copy(argCopy, mmCreateClickPipe.callArgs)

	mmCreateClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClickPipeDone returns true if the count of the CreateClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateClickPipeDone() bool {
	if m.CreateClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateClickPipeMock.invocationsDone()
}

// MinimockCreateClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateClickPipeInspect() {
	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateClickPipeCounter := mm_atomic.LoadUint64(&m.afterCreateClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClickPipeMock.defaultExpectation != nil && afterCreateClickPipeCounter < 1 {
		if m.CreateClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s", m.CreateClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s with params: %#v", m.CreateClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.CreateClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClickPipe != nil && afterCreateClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateClickPipe at\n%s", m.funcCreateClickPipeOrigin)
	}

	if !m.CreateClickPipeMock.invocationsDone() && afterCreateClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateClickPipeMock.expectedInvocations), m.CreateClickPipeMock.expectedInvocationsOrigin, afterCreateClickPipeCounter)
	}
}

type mClientMockCreateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateServiceExpectation
	expectations       []*ClientMockCreateServiceExpectation

	callArgs []*ClientMockCreateServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateServiceExpectation specifies expectation struct of the Client.CreateService
type ClientMockCreateServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateServiceParams
	paramPtrs          *ClientMockCreateServiceParamPtrs
	expectationOrigins ClientMockCreateServiceExpectationOrigins
	results            *ClientMockCreateServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateServiceParams contains parameters of the Client.CreateService
type ClientMockCreateServiceParams struct {
	ctx context.Context
	s   Service
}

// ClientMockCreateServiceParamPtrs contains pointers to parameters of the Client.CreateService
type ClientMockCreateServiceParamPtrs struct {
	ctx *context.Context
	s   *Service
}

// ClientMockCreateServiceResults contains results of the Client.CreateService
type ClientMockCreateServiceResults struct {
	sp1 *Service
	s1  string
	err error
}

// ClientMockCreateServiceOrigins contains origins of expectations of the Client.CreateService
type ClientMockCreateServiceExpectationOrigins struct {
	origin    string
	originCtx string
	originS   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateService *mClientMockCreateService) Optional() *mClientMockCreateService {
	mmCreateService.optional = true
	return mmCreateService
}

// Expect sets up expected params for Client.CreateService
func (mmCreateService *mClientMockCreateService) Expect(ctx context.Context, s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.paramPtrs != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by ExpectParams functions")
	}

	mmCreateService.defaultExpectation.params = &ClientMockCreateServiceParams{ctx, s}
	mmCreateService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateService.expectations {
		if minimock.Equal(e.params, mmCreateService.defaultExpectation.params) {
			mmCreateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateService.defaultExpectation.params)
		}
	}

	return mmCreateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectCtxParam1(ctx context.Context) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateService
}

// ExpectSParam2 sets up expected param s for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectSParam2(s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.s = &s
	mmCreateService.defaultExpectation.expectationOrigins.originS = minimock.CallerInfo(1)

	return mmCreateService
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateService
func (mmCreateService *mClientMockCreateService) Inspect(f func(ctx context.Context, s Service)) *mClientMockCreateService {
	if mmCreateService.mock.inspectFuncCreateService != nil {
		mmCreateService.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateService")
	}

	mmCreateService.mock.inspectFuncCreateService = f

	return mmCreateService
}

// Return sets up results that will be returned by Client.CreateService
func (mmCreateService *mClientMockCreateService) Return(sp1 *Service, s1 string, err error) *ClientMock {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{mock: mmCreateService.mock}
	}
	mmCreateService.defaultExpectation.results = &ClientMockCreateServiceResults{sp1, s1, err}
	mmCreateService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateService.mock
}

// Set uses given function f to mock the Client.CreateService method
func (mmCreateService *mClientMockCreateService) Set(f func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)) *ClientMock {
	if mmCreateService.defaultExpectation != nil {
		mmCreateService.mock.t.Fatalf("Default expectation is already set for the Client.CreateService method")
	}

	if len(mmCreateService.expectations) > 0 {
		mmCreateService.mock.t.Fatalf("Some expectations are already set for the Client.CreateService method")
	}

	mmCreateService.mock.funcCreateService = f
	mmCreateService.mock.funcCreateServiceOrigin = minimock.CallerInfo(1)
	return mmCreateService.mock
}

// When sets expectation for the Client.CreateService which will trigger the result defined by the following
// Then helper
func (mmCreateService *mClientMockCreateService) When(ctx context.Context, s Service) *ClientMockCreateServiceExpectation {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	expectation := &ClientMockCreateServiceExpectation{
		mock:               mmCreateService.mock,
		params:             &ClientMockCreateServiceParams{ctx, s},
		expectationOrigins: ClientMockCreateServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateService.expectations = append(mmCreateService.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateService return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateServiceExpectation) Then(sp1 *Service, s1 string, err error) *ClientMock {
	e.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return e.mock
}

// Times sets number of times Client.CreateService should be invoked
func (mmCreateService *mClientMockCreateService) Times(n uint64) *mClientMockCreateService {
	if n == 0 {
		mmCreateService.mock.t.Fatalf("Times of ClientMock.CreateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateService.expectedInvocations, n)
	mmCreateService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateService
}

func (mmCreateService *mClientMockCreateService) invocationsDone() bool {
	if len(mmCreateService.expectations) == 0 && mmCreateService.defaultExpectation == nil && mmCreateService.mock.funcCreateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateService.mock.afterCreateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateService implements Client
func (mmCreateService *ClientMock) CreateService(ctx context.Context, s Service) (sp1 *Service, s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateService.beforeCreateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateService.afterCreateServiceCounter, 1)

	mmCreateService.t.Helper()

	if mmCreateService.inspectFuncCreateService != nil {
		mmCreateService.inspectFuncCreateService(ctx, s)
	}

	mm_params := ClientMockCreateServiceParams{ctx, s}

	// Record call args
	mmCreateService.CreateServiceMock.mutex.Lock()
	mmCreateService.CreateServiceMock.callArgs = append(mmCreateService.CreateServiceMock.callArgs, &mm_params)
	mmCreateService.CreateServiceMock.mutex.Unlock()

	for _, e := range mmCreateService.CreateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.err
		}
	}

	if mmCreateService.CreateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateService.CreateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateService.CreateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmCreateService.CreateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateServiceParams{ctx, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateService.CreateServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter s, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateService.CreateServiceMock.defaultExpectation.expectationOrigins.originS, *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateService.CreateServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateService.CreateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateService.t.Fatal("No results are set for the ClientMock.CreateService")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).err
	}
	if mmCreateService.funcCreateService != nil {
		return mmCreateService.funcCreateService(ctx, s)
	}
	mmCreateService.t.Fatalf("Unexpected call to ClientMock.CreateService. %v %v", ctx, s)
	return
}

// CreateServiceAfterCounter returns a count of finished ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.afterCreateServiceCounter)
}

// CreateServiceBeforeCounter returns a count of ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.beforeCreateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateService *mClientMockCreateService) Calls() []*ClientMockCreateServiceParams {
	mmCreateService.mutex.RLock()

	argCopy := make([]*ClientMockCreateServiceParams, len(mmCreateService.callArgs))
	copy(argCopy, mmCreateService.callArgs)

	mmCreateService.mutex.RUnlock()

	return argCopy
}

// MinimockCreateServiceDone returns true if the count of the CreateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateServiceDone() bool {
	if m.CreateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateServiceMock.invocationsDone()
}

// MinimockCreateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateServiceInspect() {
	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateServiceCounter := mm_atomic.LoadUint64(&m.afterCreateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceMock.defaultExpectation != nil && afterCreateServiceCounter < 1 {
		if m.CreateServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateService at\n%s", m.CreateServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateService at\n%s with params: %#v", m.CreateServiceMock.defaultExpectation.expectationOrigins.origin, *m.CreateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateService != nil && afterCreateServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateService at\n%s", m.funcCreateServiceOrigin)
	}

	if !m.CreateServiceMock.invocationsDone() && afterCreateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateServiceMock.expectedInvocations), m.CreateServiceMock.expectedInvocationsOrigin, afterCreateServiceCounter)
	}
}

type mClientMockDeleteClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteClickPipeExpectation
	expectations       []*ClientMockDeleteClickPipeExpectation

	callArgs []*ClientMockDeleteClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteClickPipeExpectation specifies expectation struct of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteClickPipeParams
	paramPtrs          *ClientMockDeleteClickPipeParamPtrs
	expectationOrigins ClientMockDeleteClickPipeExpectationOrigins
	results            *ClientMockDeleteClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteClickPipeParams contains parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockDeleteClickPipeParamPtrs contains pointers to parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockDeleteClickPipeResults contains results of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeResults struct {
	err error
}

// ClientMockDeleteClickPipeOrigins contains origins of expectations of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Optional() *mClientMockDeleteClickPipe {
	mmDeleteClickPipe.optional = true
	return mmDeleteClickPipe
}

// Expect sets up expected params for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by ExpectParams functions")
	}

	mmDeleteClickPipe.defaultExpectation.params = &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteClickPipe.expectations {
		if minimock.Equal(e.params, mmDeleteClickPipe.defaultExpectation.params) {
			mmDeleteClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteClickPipe.defaultExpectation.params)
		}
	}

	return mmDeleteClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmDeleteClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmDeleteClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmDeleteClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteClickPipe")
	}

	mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe = f

	return mmDeleteClickPipe
}

// Return sets up results that will be returned by Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Return(err error) *ClientMock {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{mock: mmDeleteClickPipe.mock}
	}
	mmDeleteClickPipe.defaultExpectation.results = &ClientMockDeleteClickPipeResults{err}
	mmDeleteClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteClickPipe.mock
}

// Set uses given function f to mock the Client.DeleteClickPipe method
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (err error)) *ClientMock {
	if mmDeleteClickPipe.defaultExpectation != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.DeleteClickPipe method")
	}

	if len(mmDeleteClickPipe.expectations) > 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.DeleteClickPipe method")
	}

	mmDeleteClickPipe.mock.funcDeleteClickPipe = f
	mmDeleteClickPipe.mock.funcDeleteClickPipeOrigin = minimock.CallerInfo(1)
	return mmDeleteClickPipe.mock
}

// When sets expectation for the Client.DeleteClickPipe which will trigger the result defined by the following
// Then helper
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockDeleteClickPipeExpectation {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	expectation := &ClientMockDeleteClickPipeExpectation{
		mock:               mmDeleteClickPipe.mock,
		params:             &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId},
		expectationOrigins: ClientMockDeleteClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteClickPipe.expectations = append(mmDeleteClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteClickPipeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteClickPipeResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteClickPipe should be invoked
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Times(n uint64) *mClientMockDeleteClickPipe {
	if n == 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Times of ClientMock.DeleteClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteClickPipe.expectedInvocations, n)
	mmDeleteClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteClickPipe
}

func (mmDeleteClickPipe *mClientMockDeleteClickPipe) invocationsDone() bool {
	if len(mmDeleteClickPipe.expectations) == 0 && mmDeleteClickPipe.defaultExpectation == nil && mmDeleteClickPipe.mock.funcDeleteClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.mock.afterDeleteClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteClickPipe implements Client
func (mmDeleteClickPipe *ClientMock) DeleteClickPipe(ctx context.Context, serviceId string, clickPipeId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter, 1)

	mmDeleteClickPipe.t.Helper()

	if mmDeleteClickPipe.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.inspectFuncDeleteClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Lock()
	mmDeleteClickPipe.DeleteClickPipeMock.callArgs = append(mmDeleteClickPipe.DeleteClickPipeMock.callArgs, &mm_params)
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Unlock()

	for _, e := range mmDeleteClickPipe.DeleteClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteClickPipe.t.Fatal("No results are set for the ClientMock.DeleteClickPipe")
		}
		return (*mm_results).err
	}
	if mmDeleteClickPipe.funcDeleteClickPipe != nil {
		return mmDeleteClickPipe.funcDeleteClickPipe(ctx, serviceId, clickPipeId)
	}
	mmDeleteClickPipe.t.Fatalf("Unexpected call to ClientMock.DeleteClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// DeleteClickPipeAfterCounter returns a count of finished ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter)
}

// DeleteClickPipeBeforeCounter returns a count of ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Calls() []*ClientMockDeleteClickPipeParams {
	mmDeleteClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockDeleteClickPipeParams, len(mmDeleteClickPipe.callArgs))
	copy(argCopy, mmDeleteClickPipe.callArgs)

	mmDeleteClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteClickPipeDone returns true if the count of the DeleteClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteClickPipeDone() bool {
	if m.DeleteClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteClickPipeMock.invocationsDone()
}

// MinimockDeleteClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteClickPipeInspect() {
	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteClickPipeCounter := mm_atomic.LoadUint64(&m.afterDeleteClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClickPipeMock.defaultExpectation != nil && afterDeleteClickPipeCounter < 1 {
		if m.DeleteClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s", m.DeleteClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s with params: %#v", m.DeleteClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.DeleteClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClickPipe != nil && afterDeleteClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteClickPipe at\n%s", m.funcDeleteClickPipeOrigin)
	}

	if !m.DeleteClickPipeMock.invocationsDone() && afterDeleteClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteClickPipeMock.expectedInvocations), m.DeleteClickPipeMock.expectedInvocationsOrigin, afterDeleteClickPipeCounter)
	}
}

type mClientMockDeleteService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteServiceExpectation
	expectations       []*ClientMockDeleteServiceExpectation

	callArgs []*ClientMockDeleteServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteServiceExpectation specifies expectation struct of the Client.DeleteService
type ClientMockDeleteServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteServiceParams
	paramPtrs          *ClientMockDeleteServiceParamPtrs
	expectationOrigins ClientMockDeleteServiceExpectationOrigins
	results            *ClientMockDeleteServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteServiceParams contains parameters of the Client.DeleteService
type ClientMockDeleteServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockDeleteServiceParamPtrs contains pointers to parameters of the Client.DeleteService
type ClientMockDeleteServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockDeleteServiceResults contains results of the Client.DeleteService
type ClientMockDeleteServiceResults struct {
	sp1 *Service
	err error
}

// ClientMockDeleteServiceOrigins contains origins of expectations of the Client.DeleteService
type ClientMockDeleteServiceExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteService *mClientMockDeleteService) Optional() *mClientMockDeleteService {
	mmDeleteService.optional = true
	return mmDeleteService
}

// Expect sets up expected params for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Expect(ctx context.Context, serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.paramPtrs != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by ExpectParams functions")
	}

	mmDeleteService.defaultExpectation.params = &ClientMockDeleteServiceParams{ctx, serviceId}
	mmDeleteService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteService.expectations {
		if minimock.Equal(e.params, mmDeleteService.defaultExpectation.params) {
			mmDeleteService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteService.defaultExpectation.params)
		}
	}

	return mmDeleteService
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmDeleteService.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmDeleteService
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockDeleteService {
	if mmDeleteService.mock.inspectFuncDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteService")
	}

	mmDeleteService.mock.inspectFuncDeleteService = f

	return mmDeleteService
}

// Return sets up results that will be returned by Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Return(sp1 *Service, err error) *ClientMock {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{mock: mmDeleteService.mock}
	}
	mmDeleteService.defaultExpectation.results = &ClientMockDeleteServiceResults{sp1, err}
	mmDeleteService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteService.mock
}

// Set uses given function f to mock the Client.DeleteService method
func (mmDeleteService *mClientMockDeleteService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmDeleteService.defaultExpectation != nil {
		mmDeleteService.mock.t.Fatalf("Default expectation is already set for the Client.DeleteService method")
	}

	if len(mmDeleteService.expectations) > 0 {
		mmDeleteService.mock.t.Fatalf("Some expectations are already set for the Client.DeleteService method")
	}

	mmDeleteService.mock.funcDeleteService = f
	mmDeleteService.mock.funcDeleteServiceOrigin = minimock.CallerInfo(1)
	return mmDeleteService.mock
}

// When sets expectation for the Client.DeleteService which will trigger the result defined by the following
// Then helper
func (mmDeleteService *mClientMockDeleteService) When(ctx context.Context, serviceId string) *ClientMockDeleteServiceExpectation {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	expectation := &ClientMockDeleteServiceExpectation{
		mock:               mmDeleteService.mock,
		params:             &ClientMockDeleteServiceParams{ctx, serviceId},
		expectationOrigins: ClientMockDeleteServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteService.expectations = append(mmDeleteService.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteService return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockDeleteServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.DeleteService should be invoked
func (mmDeleteService *mClientMockDeleteService) Times(n uint64) *mClientMockDeleteService {
	if n == 0 {
		mmDeleteService.mock.t.Fatalf("Times of ClientMock.DeleteService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteService.expectedInvocations, n)
	mmDeleteService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteService
}

func (mmDeleteService *mClientMockDeleteService) invocationsDone() bool {
	if len(mmDeleteService.expectations) == 0 && mmDeleteService.defaultExpectation == nil && mmDeleteService.mock.funcDeleteService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteService.mock.afterDeleteServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteService implements Client
func (mmDeleteService *ClientMock) DeleteService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmDeleteService.beforeDeleteServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteService.afterDeleteServiceCounter, 1)

	mmDeleteService.t.Helper()

	if mmDeleteService.inspectFuncDeleteService != nil {
		mmDeleteService.inspectFuncDeleteService(ctx, serviceId)
	}

	mm_params := ClientMockDeleteServiceParams{ctx, serviceId}

	// Record call args
	mmDeleteService.DeleteServiceMock.mutex.Lock()
	mmDeleteService.DeleteServiceMock.callArgs = append(mmDeleteService.DeleteServiceMock.callArgs, &mm_params)
	mmDeleteService.DeleteServiceMock.mutex.Unlock()

	for _, e := range mmDeleteService.DeleteServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDeleteService.DeleteServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteService.DeleteServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteService.DeleteServiceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteService.DeleteServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteService.DeleteServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteService.DeleteServiceMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteService.DeleteServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteService.DeleteServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteService.t.Fatal("No results are set for the ClientMock.DeleteService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDeleteService.funcDeleteService != nil {
		return mmDeleteService.funcDeleteService(ctx, serviceId)
	}
	mmDeleteService.t.Fatalf("Unexpected call to ClientMock.DeleteService. %v %v", ctx, serviceId)
	return
}

// DeleteServiceAfterCounter returns a count of finished ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.afterDeleteServiceCounter)
}

// DeleteServiceBeforeCounter returns a count of ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.beforeDeleteServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteService *mClientMockDeleteService) Calls() []*ClientMockDeleteServiceParams {
	mmDeleteService.mutex.RLock()

	argCopy := make([]*ClientMockDeleteServiceParams, len(mmDeleteService.callArgs))
	copy(argCopy, mmDeleteService.callArgs)

	mmDeleteService.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteServiceDone returns true if the count of the DeleteService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteServiceDone() bool {
	if m.DeleteServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteServiceMock.invocationsDone()
}

// MinimockDeleteServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteServiceInspect() {
	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteServiceCounter := mm_atomic.LoadUint64(&m.afterDeleteServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteServiceMock.defaultExpectation != nil && afterDeleteServiceCounter < 1 {
		if m.DeleteServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s", m.DeleteServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s with params: %#v", m.DeleteServiceMock.defaultExpectation.expectationOrigins.origin, *m.DeleteServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteService != nil && afterDeleteServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteService at\n%s", m.funcDeleteServiceOrigin)
	}

	if !m.DeleteServiceMock.invocationsDone() && afterDeleteServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteServiceMock.expectedInvocations), m.DeleteServiceMock.expectedInvocationsOrigin, afterDeleteServiceCounter)
	}
}

type mClientMockGetBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetBackupConfigurationExpectation
	expectations       []*ClientMockGetBackupConfigurationExpectation

	callArgs []*ClientMockGetBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetBackupConfigurationExpectation specifies expectation struct of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetBackupConfigurationParams
	paramPtrs          *ClientMockGetBackupConfigurationParamPtrs
	expectationOrigins ClientMockGetBackupConfigurationExpectationOrigins
	results            *ClientMockGetBackupConfigurationResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetBackupConfigurationParams contains parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetBackupConfigurationParamPtrs contains pointers to parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetBackupConfigurationResults contains results of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// ClientMockGetBackupConfigurationOrigins contains origins of expectations of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Optional() *mClientMockGetBackupConfiguration {
	mmGetBackupConfiguration.optional = true
	return mmGetBackupConfiguration
}

// Expect sets up expected params for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Expect(ctx context.Context, serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmGetBackupConfiguration.defaultExpectation.params = &ClientMockGetBackupConfigurationParams{ctx, serviceId}
	mmGetBackupConfiguration.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmGetBackupConfiguration.defaultExpectation.params) {
			mmGetBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmGetBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBackupConfiguration.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetBackupConfiguration.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.GetBackupConfiguration")
	}

	mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration = f

	return mmGetBackupConfiguration
}

// Return sets up results that will be returned by Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{mock: mmGetBackupConfiguration.mock}
	}
	mmGetBackupConfiguration.defaultExpectation.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	mmGetBackupConfiguration.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBackupConfiguration.mock
}

// Set uses given function f to mock the Client.GetBackupConfiguration method
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Set(f func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmGetBackupConfiguration.defaultExpectation != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.GetBackupConfiguration method")
	}

	if len(mmGetBackupConfiguration.expectations) > 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.GetBackupConfiguration method")
	}

	mmGetBackupConfiguration.mock.funcGetBackupConfiguration = f
	mmGetBackupConfiguration.mock.funcGetBackupConfigurationOrigin = minimock.CallerInfo(1)
	return mmGetBackupConfiguration.mock
}

// When sets expectation for the Client.GetBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) When(ctx context.Context, serviceId string) *ClientMockGetBackupConfigurationExpectation {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockGetBackupConfigurationExpectation{
		mock:               mmGetBackupConfiguration.mock,
		params:             &ClientMockGetBackupConfigurationParams{ctx, serviceId},
		expectationOrigins: ClientMockGetBackupConfigurationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBackupConfiguration.expectations = append(mmGetBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.GetBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockGetBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.GetBackupConfiguration should be invoked
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Times(n uint64) *mClientMockGetBackupConfiguration {
	if n == 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Times of ClientMock.GetBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBackupConfiguration.expectedInvocations, n)
	mmGetBackupConfiguration.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBackupConfiguration
}

func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) invocationsDone() bool {
	if len(mmGetBackupConfiguration.expectations) == 0 && mmGetBackupConfiguration.defaultExpectation == nil && mmGetBackupConfiguration.mock.funcGetBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.mock.afterGetBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBackupConfiguration implements Client
func (mmGetBackupConfiguration *ClientMock) GetBackupConfiguration(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter, 1)

	mmGetBackupConfiguration.t.Helper()

	if mmGetBackupConfiguration.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.inspectFuncGetBackupConfiguration(ctx, serviceId)
	}

	mm_params := ClientMockGetBackupConfigurationParams{ctx, serviceId}

	// Record call args
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Lock()
	mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs = append(mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs, &mm_params)
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmGetBackupConfiguration.GetBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetBackupConfigurationParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBackupConfiguration.t.Fatal("No results are set for the ClientMock.GetBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBackupConfiguration.funcGetBackupConfiguration != nil {
		return mmGetBackupConfiguration.funcGetBackupConfiguration(ctx, serviceId)
	}
	mmGetBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.GetBackupConfiguration. %v %v", ctx, serviceId)
	return
}

// GetBackupConfigurationAfterCounter returns a count of finished ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter)
}

// GetBackupConfigurationBeforeCounter returns a count of ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Calls() []*ClientMockGetBackupConfigurationParams {
	mmGetBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockGetBackupConfigurationParams, len(mmGetBackupConfiguration.callArgs))
	copy(argCopy, mmGetBackupConfiguration.callArgs)

	mmGetBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockGetBackupConfigurationDone returns true if the count of the GetBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetBackupConfigurationDone() bool {
	if m.GetBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBackupConfigurationMock.invocationsDone()
}

// MinimockGetBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockGetBackupConfigurationInspect() {
	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterGetBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBackupConfigurationMock.defaultExpectation != nil && afterGetBackupConfigurationCounter < 1 {
		if m.GetBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s", m.GetBackupConfigurationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s with params: %#v", m.GetBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *m.GetBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBackupConfiguration != nil && afterGetBackupConfigurationCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration at\n%s", m.funcGetBackupConfigurationOrigin)
	}

	if !m.GetBackupConfigurationMock.invocationsDone() && afterGetBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetBackupConfiguration at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBackupConfigurationMock.expectedInvocations), m.GetBackupConfigurationMock.expectedInvocationsOrigin, afterGetBackupConfigurationCounter)
	}
}

type mClientMockGetClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetClickPipeExpectation
	expectations       []*ClientMockGetClickPipeExpectation

	callArgs []*ClientMockGetClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetClickPipeExpectation specifies expectation struct of the Client.GetClickPipe
type ClientMockGetClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetClickPipeParams
	paramPtrs          *ClientMockGetClickPipeParamPtrs
	expectationOrigins ClientMockGetClickPipeExpectationOrigins
	results            *ClientMockGetClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetClickPipeParams contains parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockGetClickPipeParamPtrs contains pointers to parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockGetClickPipeResults contains results of the Client.GetClickPipe
type ClientMockGetClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockGetClickPipeOrigins contains origins of expectations of the Client.GetClickPipe
type ClientMockGetClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClickPipe *mClientMockGetClickPipe) Optional() *mClientMockGetClickPipe {
	mmGetClickPipe.optional = true
	return mmGetClickPipe
}

// Expect sets up expected params for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by ExpectParams functions")
	}

	mmGetClickPipe.defaultExpectation.params = &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}
	mmGetClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClickPipe.expectations {
		if minimock.Equal(e.params, mmGetClickPipe.defaultExpectation.params) {
			mmGetClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClickPipe.defaultExpectation.params)
		}
	}

	return mmGetClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmGetClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmGetClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.GetClickPipe")
	}

	mmGetClickPipe.mock.inspectFuncGetClickPipe = f

	return mmGetClickPipe
}

// Return sets up results that will be returned by Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{mock: mmGetClickPipe.mock}
	}
	mmGetClickPipe.defaultExpectation.results = &ClientMockGetClickPipeResults{cp1, err}
	mmGetClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClickPipe.mock
}

// Set uses given function f to mock the Client.GetClickPipe method
func (mmGetClickPipe *mClientMockGetClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmGetClickPipe.defaultExpectation != nil {
		mmGetClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.GetClickPipe method")
	}

	if len(mmGetClickPipe.expectations) > 0 {
		mmGetClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.GetClickPipe method")
	}

	mmGetClickPipe.mock.funcGetClickPipe = f
	mmGetClickPipe.mock.funcGetClickPipeOrigin = minimock.CallerInfo(1)
	return mmGetClickPipe.mock
}

// When sets expectation for the Client.GetClickPipe which will trigger the result defined by the following
// Then helper
func (mmGetClickPipe *mClientMockGetClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockGetClickPipeExpectation {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	expectation := &ClientMockGetClickPipeExpectation{
		mock:               mmGetClickPipe.mock,
		params:             &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId},
		expectationOrigins: ClientMockGetClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClickPipe.expectations = append(mmGetClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.GetClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockGetClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockGetClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.GetClickPipe should be invoked
func (mmGetClickPipe *mClientMockGetClickPipe) Times(n uint64) *mClientMockGetClickPipe {
	if n == 0 {
		mmGetClickPipe.mock.t.Fatalf("Times of ClientMock.GetClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClickPipe.expectedInvocations, n)
	mmGetClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClickPipe
}

func (mmGetClickPipe *mClientMockGetClickPipe) invocationsDone() bool {
	if len(mmGetClickPipe.expectations) == 0 && mmGetClickPipe.defaultExpectation == nil && mmGetClickPipe.mock.funcGetClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.mock.afterGetClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClickPipe implements Client
func (mmGetClickPipe *ClientMock) GetClickPipe(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmGetClickPipe.beforeGetClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClickPipe.afterGetClickPipeCounter, 1)

	mmGetClickPipe.t.Helper()

	if mmGetClickPipe.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.inspectFuncGetClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmGetClickPipe.GetClickPipeMock.mutex.Lock()
	mmGetClickPipe.GetClickPipeMock.callArgs = append(mmGetClickPipe.GetClickPipeMock.callArgs, &mm_params)
	mmGetClickPipe.GetClickPipeMock.mutex.Unlock()

	for _, e := range mmGetClickPipe.GetClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetClickPipe.GetClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClickPipe.GetClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClickPipe.GetClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmGetClickPipe.GetClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClickPipe.GetClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClickPipe.GetClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClickPipe.t.Fatal("No results are set for the ClientMock.GetClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetClickPipe.funcGetClickPipe != nil {
		return mmGetClickPipe.funcGetClickPipe(ctx, serviceId, clickPipeId)
	}
	mmGetClickPipe.t.Fatalf("Unexpected call to ClientMock.GetClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// GetClickPipeAfterCounter returns a count of finished ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.afterGetClickPipeCounter)
}

// GetClickPipeBeforeCounter returns a count of ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.beforeGetClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClickPipe *mClientMockGetClickPipe) Calls() []*ClientMockGetClickPipeParams {
	mmGetClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockGetClickPipeParams, len(mmGetClickPipe.callArgs))
	copy(argCopy, mmGetClickPipe.callArgs)

	mmGetClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockGetClickPipeDone returns true if the count of the GetClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetClickPipeDone() bool {
	if m.GetClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClickPipeMock.invocationsDone()
}

// MinimockGetClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetClickPipeInspect() {
	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClickPipeCounter := mm_atomic.LoadUint64(&m.afterGetClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClickPipeMock.defaultExpectation != nil && afterGetClickPipeCounter < 1 {
		if m.GetClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s", m.GetClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s with params: %#v", m.GetClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.GetClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClickPipe != nil && afterGetClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetClickPipe at\n%s", m.funcGetClickPipeOrigin)
	}

	if !m.GetClickPipeMock.invocationsDone() && afterGetClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClickPipeMock.expectedInvocations), m.GetClickPipeMock.expectedInvocationsOrigin, afterGetClickPipeCounter)
	}
}

type mClientMockGetOrgPrivateEndpointConfig struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrgPrivateEndpointConfigExpectation
	expectations       []*ClientMockGetOrgPrivateEndpointConfigExpectation

	callArgs []*ClientMockGetOrgPrivateEndpointConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetOrgPrivateEndpointConfigExpectation specifies expectation struct of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetOrgPrivateEndpointConfigParams
	paramPtrs          *ClientMockGetOrgPrivateEndpointConfigParamPtrs
	expectationOrigins ClientMockGetOrgPrivateEndpointConfigExpectationOrigins
	results            *ClientMockGetOrgPrivateEndpointConfigResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetOrgPrivateEndpointConfigParams contains parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParams struct {
	ctx           context.Context
	cloudProvider string
	region        string
}

// ClientMockGetOrgPrivateEndpointConfigParamPtrs contains pointers to parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParamPtrs struct {
	ctx           *context.Context
	cloudProvider *string
	region        *string
}

// ClientMockGetOrgPrivateEndpointConfigResults contains results of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigResults struct {
	op1 *OrgPrivateEndpointConfig
	err error
}

// ClientMockGetOrgPrivateEndpointConfigOrigins contains origins of expectations of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectationOrigins struct {
	origin              string
	originCtx           string
	originCloudProvider string
	originRegion        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Optional() *mClientMockGetOrgPrivateEndpointConfig {
	mmGetOrgPrivateEndpointConfig.optional = true
	return mmGetOrgPrivateEndpointConfig
}

// Expect sets up expected params for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Expect(ctx context.Context, cloudProvider string, region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by ExpectParams functions")
	}

	mmGetOrgPrivateEndpointConfig.defaultExpectation.params = &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrgPrivateEndpointConfig.expectations {
		if minimock.Equal(e.params, mmGetOrgPrivateEndpointConfig.defaultExpectation.params) {
			mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrgPrivateEndpointConfig.defaultExpectation.params)
		}
	}

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCloudProviderParam2 sets up expected param cloudProvider for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCloudProviderParam2(cloudProvider string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.cloudProvider = &cloudProvider
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.originCloudProvider = minimock.CallerInfo(1)

	return mmGetOrgPrivateEndpointConfig
}

// ExpectRegionParam3 sets up expected param region for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectRegionParam3(region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.region = &region
	mmGetOrgPrivateEndpointConfig.defaultExpectation.expectationOrigins.originRegion = minimock.CallerInfo(1)

	return mmGetOrgPrivateEndpointConfig
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Inspect(f func(ctx context.Context, cloudProvider string, region string)) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrgPrivateEndpointConfig")
	}

	mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig = f

	return mmGetOrgPrivateEndpointConfig
}

// Return sets up results that will be returned by Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Return(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{mock: mmGetOrgPrivateEndpointConfig.mock}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrgPrivateEndpointConfig.mock
}

// Set uses given function f to mock the Client.GetOrgPrivateEndpointConfig method
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Set(f func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.defaultExpectation != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Default expectation is already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	if len(mmGetOrgPrivateEndpointConfig.expectations) > 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Some expectations are already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig = f
	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfigOrigin = minimock.CallerInfo(1)
	return mmGetOrgPrivateEndpointConfig.mock
}

// When sets expectation for the Client.GetOrgPrivateEndpointConfig which will trigger the result defined by the following
// Then helper
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) When(ctx context.Context, cloudProvider string, region string) *ClientMockGetOrgPrivateEndpointConfigExpectation {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	expectation := &ClientMockGetOrgPrivateEndpointConfigExpectation{
		mock:               mmGetOrgPrivateEndpointConfig.mock,
		params:             &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region},
		expectationOrigins: ClientMockGetOrgPrivateEndpointConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrgPrivateEndpointConfig.expectations = append(mmGetOrgPrivateEndpointConfig.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrgPrivateEndpointConfig return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrgPrivateEndpointConfigExpectation) Then(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	e.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return e.mock
}

// Times sets number of times Client.GetOrgPrivateEndpointConfig should be invoked
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Times(n uint64) *mClientMockGetOrgPrivateEndpointConfig {
	if n == 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Times of ClientMock.GetOrgPrivateEndpointConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations, n)
	mmGetOrgPrivateEndpointConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrgPrivateEndpointConfig
}

func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) invocationsDone() bool {
	if len(mmGetOrgPrivateEndpointConfig.expectations) == 0 && mmGetOrgPrivateEndpointConfig.defaultExpectation == nil && mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.mock.afterGetOrgPrivateEndpointConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrgPrivateEndpointConfig implements Client
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfig(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error) {
	mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter, 1)

	mmGetOrgPrivateEndpointConfig.t.Helper()

	if mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}

	mm_params := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

	// Record call args
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Lock()
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs = append(mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs, &mm_params)
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Unlock()

	for _, e := range mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cloudProvider != nil && !minimock.Equal(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter cloudProvider, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.originCloudProvider, *mm_want_ptrs.cloudProvider, mm_got.cloudProvider, minimock.Diff(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider))
			}

			if mm_want_ptrs.region != nil && !minimock.Equal(*mm_want_ptrs.region, mm_got.region) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter region, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.originRegion, *mm_want_ptrs.region, mm_got.region, minimock.Diff(*mm_want_ptrs.region, mm_got.region))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrgPrivateEndpointConfig.t.Fatal("No results are set for the ClientMock.GetOrgPrivateEndpointConfig")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig != nil {
		return mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}
	mmGetOrgPrivateEndpointConfig.t.Fatalf("Unexpected call to ClientMock.GetOrgPrivateEndpointConfig. %v %v %v", ctx, cloudProvider, region)
	return
}

// GetOrgPrivateEndpointConfigAfterCounter returns a count of finished ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter)
}

// GetOrgPrivateEndpointConfigBeforeCounter returns a count of ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrgPrivateEndpointConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Calls() []*ClientMockGetOrgPrivateEndpointConfigParams {
	mmGetOrgPrivateEndpointConfig.mutex.RLock()

	argCopy := make([]*ClientMockGetOrgPrivateEndpointConfigParams, len(mmGetOrgPrivateEndpointConfig.callArgs))
	copy(argCopy, mmGetOrgPrivateEndpointConfig.callArgs)

	mmGetOrgPrivateEndpointConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrgPrivateEndpointConfigDone returns true if the count of the GetOrgPrivateEndpointConfig invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigDone() bool {
	if m.GetOrgPrivateEndpointConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrgPrivateEndpointConfigMock.invocationsDone()
}

// MinimockGetOrgPrivateEndpointConfigInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigInspect() {
	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrgPrivateEndpointConfigCounter := mm_atomic.LoadUint64(&m.afterGetOrgPrivateEndpointConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		if m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s", m.GetOrgPrivateEndpointConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s with params: %#v", m.GetOrgPrivateEndpointConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrgPrivateEndpointConfig != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig at\n%s", m.funcGetOrgPrivateEndpointConfigOrigin)
	}

	if !m.GetOrgPrivateEndpointConfigMock.invocationsDone() && afterGetOrgPrivateEndpointConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrgPrivateEndpointConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrgPrivateEndpointConfigMock.expectedInvocations), m.GetOrgPrivateEndpointConfigMock.expectedInvocationsOrigin, afterGetOrgPrivateEndpointConfigCounter)
	}
}

type mClientMockGetOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockGetOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockGetOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetOrganizationPrivateEndpointsParams
	paramPtrs          *ClientMockGetOrganizationPrivateEndpointsParamPtrs
	expectationOrigins ClientMockGetOrganizationPrivateEndpointsExpectationOrigins
	results            *ClientMockGetOrganizationPrivateEndpointsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetOrganizationPrivateEndpointsParams contains parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParams struct {
	ctx context.Context
}

// ClientMockGetOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParamPtrs struct {
	ctx *context.Context
}

// ClientMockGetOrganizationPrivateEndpointsResults contains results of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// ClientMockGetOrganizationPrivateEndpointsOrigins contains origins of expectations of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Optional() *mClientMockGetOrganizationPrivateEndpoints {
	mmGetOrganizationPrivateEndpoints.optional = true
	return mmGetOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Expect(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmGetOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockGetOrganizationPrivateEndpointsParams{ctx}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmGetOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmGetOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockGetOrganizationPrivateEndpointsParamPtrs{}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context)) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrganizationPrivateEndpoints")
	}

	mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints = f

	return mmGetOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{mock: mmGetOrganizationPrivateEndpoints.mock}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.GetOrganizationPrivateEndpoints method
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Set(f func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	if len(mmGetOrganizationPrivateEndpoints.expectations) > 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints = f
	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpointsOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.GetOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) When(ctx context.Context) *ClientMockGetOrganizationPrivateEndpointsExpectation {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockGetOrganizationPrivateEndpointsExpectation{
		mock:               mmGetOrganizationPrivateEndpoints.mock,
		params:             &ClientMockGetOrganizationPrivateEndpointsParams{ctx},
		expectationOrigins: ClientMockGetOrganizationPrivateEndpointsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrganizationPrivateEndpoints.expectations = append(mmGetOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.GetOrganizationPrivateEndpoints should be invoked
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Times(n uint64) *mClientMockGetOrganizationPrivateEndpoints {
	if n == 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.GetOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations, n)
	mmGetOrganizationPrivateEndpoints.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationPrivateEndpoints
}

func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmGetOrganizationPrivateEndpoints.expectations) == 0 && mmGetOrganizationPrivateEndpoints.defaultExpectation == nil && mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.mock.afterGetOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationPrivateEndpoints implements Client
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpoints(ctx context.Context) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter, 1)

	mmGetOrganizationPrivateEndpoints.t.Helper()

	if mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints(ctx)
	}

	mm_params := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

	// Record call args
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Lock()
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs = append(mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.GetOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints != nil {
		return mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints(ctx)
	}
	mmGetOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.GetOrganizationPrivateEndpoints. %v", ctx)
	return
}

// GetOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter)
}

// GetOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Calls() []*ClientMockGetOrganizationPrivateEndpointsParams {
	mmGetOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockGetOrganizationPrivateEndpointsParams, len(mmGetOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmGetOrganizationPrivateEndpoints.callArgs)

	mmGetOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationPrivateEndpointsDone returns true if the count of the GetOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsDone() bool {
	if m.GetOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockGetOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsInspect() {
	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		if m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s", m.GetOrganizationPrivateEndpointsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s with params: %#v", m.GetOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationPrivateEndpoints != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints at\n%s", m.funcGetOrganizationPrivateEndpointsOrigin)
	}

	if !m.GetOrganizationPrivateEndpointsMock.invocationsDone() && afterGetOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrganizationPrivateEndpoints at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationPrivateEndpointsMock.expectedInvocations), m.GetOrganizationPrivateEndpointsMock.expectedInvocationsOrigin, afterGetOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockGetService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetServiceExpectation
	expectations       []*ClientMockGetServiceExpectation

	callArgs []*ClientMockGetServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetServiceExpectation specifies expectation struct of the Client.GetService
type ClientMockGetServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetServiceParams
	paramPtrs          *ClientMockGetServiceParamPtrs
	expectationOrigins ClientMockGetServiceExpectationOrigins
	results            *ClientMockGetServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetServiceParams contains parameters of the Client.GetService
type ClientMockGetServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetServiceParamPtrs contains pointers to parameters of the Client.GetService
type ClientMockGetServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetServiceResults contains results of the Client.GetService
type ClientMockGetServiceResults struct {
	sp1 *Service
	err error
}

// ClientMockGetServiceOrigins contains origins of expectations of the Client.GetService
type ClientMockGetServiceExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetService *mClientMockGetService) Optional() *mClientMockGetService {
	mmGetService.optional = true
	return mmGetService
}

// Expect sets up expected params for Client.GetService
func (mmGetService *mClientMockGetService) Expect(ctx context.Context, serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.paramPtrs != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by ExpectParams functions")
	}

	mmGetService.defaultExpectation.params = &ClientMockGetServiceParams{ctx, serviceId}
	mmGetService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetService.expectations {
		if minimock.Equal(e.params, mmGetService.defaultExpectation.params) {
			mmGetService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetService.defaultExpectation.params)
		}
	}

	return mmGetService
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetService
func (mmGetService *mClientMockGetService) ExpectCtxParam1(ctx context.Context) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetService
func (mmGetService *mClientMockGetService) ExpectServiceIdParam2(serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmGetService.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmGetService
}

// Inspect accepts an inspector function that has same arguments as the Client.GetService
func (mmGetService *mClientMockGetService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetService {
	if mmGetService.mock.inspectFuncGetService != nil {
		mmGetService.mock.t.Fatalf("Inspect function is already set for ClientMock.GetService")
	}

	mmGetService.mock.inspectFuncGetService = f

	return mmGetService
}

// Return sets up results that will be returned by Client.GetService
func (mmGetService *mClientMockGetService) Return(sp1 *Service, err error) *ClientMock {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{mock: mmGetService.mock}
	}
	mmGetService.defaultExpectation.results = &ClientMockGetServiceResults{sp1, err}
	mmGetService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetService.mock
}

// Set uses given function f to mock the Client.GetService method
func (mmGetService *mClientMockGetService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmGetService.defaultExpectation != nil {
		mmGetService.mock.t.Fatalf("Default expectation is already set for the Client.GetService method")
	}

	if len(mmGetService.expectations) > 0 {
		mmGetService.mock.t.Fatalf("Some expectations are already set for the Client.GetService method")
	}

	mmGetService.mock.funcGetService = f
	mmGetService.mock.funcGetServiceOrigin = minimock.CallerInfo(1)
	return mmGetService.mock
}

// When sets expectation for the Client.GetService which will trigger the result defined by the following
// Then helper
func (mmGetService *mClientMockGetService) When(ctx context.Context, serviceId string) *ClientMockGetServiceExpectation {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	expectation := &ClientMockGetServiceExpectation{
		mock:               mmGetService.mock,
		params:             &ClientMockGetServiceParams{ctx, serviceId},
		expectationOrigins: ClientMockGetServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetService.expectations = append(mmGetService.expectations, expectation)
	return expectation
}

// Then sets up Client.GetService return parameters for the expectation previously defined by the When method
func (e *ClientMockGetServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockGetServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetService should be invoked
func (mmGetService *mClientMockGetService) Times(n uint64) *mClientMockGetService {
	if n == 0 {
		mmGetService.mock.t.Fatalf("Times of ClientMock.GetService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetService.expectedInvocations, n)
	mmGetService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetService
}

func (mmGetService *mClientMockGetService) invocationsDone() bool {
	if len(mmGetService.expectations) == 0 && mmGetService.defaultExpectation == nil && mmGetService.mock.funcGetService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetService.mock.afterGetServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetService implements Client
func (mmGetService *ClientMock) GetService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmGetService.beforeGetServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetService.afterGetServiceCounter, 1)

	mmGetService.t.Helper()

	if mmGetService.inspectFuncGetService != nil {
		mmGetService.inspectFuncGetService(ctx, serviceId)
	}

	mm_params := ClientMockGetServiceParams{ctx, serviceId}

	// Record call args
	mmGetService.GetServiceMock.mutex.Lock()
	mmGetService.GetServiceMock.callArgs = append(mmGetService.GetServiceMock.callArgs, &mm_params)
	mmGetService.GetServiceMock.mutex.Unlock()

	for _, e := range mmGetService.GetServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetService.GetServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetService.GetServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetService.GetServiceMock.defaultExpectation.params
		mm_want_ptrs := mmGetService.GetServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetService.GetServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetService.GetServiceMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetService.t.Errorf("ClientMock.GetService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetService.GetServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetService.GetServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetService.t.Fatal("No results are set for the ClientMock.GetService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetService.funcGetService != nil {
		return mmGetService.funcGetService(ctx, serviceId)
	}
	mmGetService.t.Fatalf("Unexpected call to ClientMock.GetService. %v %v", ctx, serviceId)
	return
}

// GetServiceAfterCounter returns a count of finished ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.afterGetServiceCounter)
}

// GetServiceBeforeCounter returns a count of ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.beforeGetServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetService *mClientMockGetService) Calls() []*ClientMockGetServiceParams {
	mmGetService.mutex.RLock()

	argCopy := make([]*ClientMockGetServiceParams, len(mmGetService.callArgs))
	copy(argCopy, mmGetService.callArgs)

	mmGetService.mutex.RUnlock()

	return argCopy
}

// MinimockGetServiceDone returns true if the count of the GetService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetServiceDone() bool {
	if m.GetServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetServiceMock.invocationsDone()
}

// MinimockGetServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockGetServiceInspect() {
	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetServiceCounter := mm_atomic.LoadUint64(&m.afterGetServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetServiceMock.defaultExpectation != nil && afterGetServiceCounter < 1 {
		if m.GetServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetService at\n%s", m.GetServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetService at\n%s with params: %#v", m.GetServiceMock.defaultExpectation.expectationOrigins.origin, *m.GetServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetService != nil && afterGetServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetService at\n%s", m.funcGetServiceOrigin)
	}

	if !m.GetServiceMock.invocationsDone() && afterGetServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetServiceMock.expectedInvocations), m.GetServiceMock.expectedInvocationsOrigin, afterGetServiceCounter)
	}
}

type mClientMockPauseClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockPauseClickPipeExpectation
	expectations       []*ClientMockPauseClickPipeExpectation

	callArgs []*ClientMockPauseClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockPauseClickPipeExpectation specifies expectation struct of the Client.PauseClickPipe
type ClientMockPauseClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockPauseClickPipeParams
	paramPtrs          *ClientMockPauseClickPipeParamPtrs
	expectationOrigins ClientMockPauseClickPipeExpectationOrigins
	results            *ClientMockPauseClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockPauseClickPipeParams contains parameters of the Client.PauseClickPipe
type ClientMockPauseClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockPauseClickPipeParamPtrs contains pointers to parameters of the Client.PauseClickPipe
type ClientMockPauseClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockPauseClickPipeResults contains results of the Client.PauseClickPipe
type ClientMockPauseClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockPauseClickPipeOrigins contains origins of expectations of the Client.PauseClickPipe
type ClientMockPauseClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPauseClickPipe *mClientMockPauseClickPipe) Optional() *mClientMockPauseClickPipe {
	mmPauseClickPipe.optional = true
	return mmPauseClickPipe
}

// Expect sets up expected params for Client.PauseClickPipe
func (mmPauseClickPipe *mClientMockPauseClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockPauseClickPipe {
	if mmPauseClickPipe.mock.funcPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmPauseClickPipe.defaultExpectation == nil {
		mmPauseClickPipe.defaultExpectation = &ClientMockPauseClickPipeExpectation{}
	}

	if mmPauseClickPipe.defaultExpectation.paramPtrs != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by ExpectParams functions")
	}

	mmPauseClickPipe.defaultExpectation.params = &ClientMockPauseClickPipeParams{ctx, serviceId, clickPipeId}
	mmPauseClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPauseClickPipe.expectations {
		if minimock.Equal(e.params, mmPauseClickPipe.defaultExpectation.params) {
			mmPauseClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPauseClickPipe.defaultExpectation.params)
		}
	}

	return mmPauseClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.PauseClickPipe
func (mmPauseClickPipe *mClientMockPauseClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockPauseClickPipe {
	if mmPauseClickPipe.mock.funcPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmPauseClickPipe.defaultExpectation == nil {
		mmPauseClickPipe.defaultExpectation = &ClientMockPauseClickPipeExpectation{}
	}

	if mmPauseClickPipe.defaultExpectation.params != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmPauseClickPipe.defaultExpectation.paramPtrs == nil {
		mmPauseClickPipe.defaultExpectation.paramPtrs = &ClientMockPauseClickPipeParamPtrs{}
	}
	mmPauseClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmPauseClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPauseClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.PauseClickPipe
func (mmPauseClickPipe *mClientMockPauseClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockPauseClickPipe {
	if mmPauseClickPipe.mock.funcPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmPauseClickPipe.defaultExpectation == nil {
		mmPauseClickPipe.defaultExpectation = &ClientMockPauseClickPipeExpectation{}
	}

	if mmPauseClickPipe.defaultExpectation.params != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmPauseClickPipe.defaultExpectation.paramPtrs == nil {
		mmPauseClickPipe.defaultExpectation.paramPtrs = &ClientMockPauseClickPipeParamPtrs{}
	}
	mmPauseClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmPauseClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmPauseClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.PauseClickPipe
func (mmPauseClickPipe *mClientMockPauseClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockPauseClickPipe {
	if mmPauseClickPipe.mock.funcPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmPauseClickPipe.defaultExpectation == nil {
		mmPauseClickPipe.defaultExpectation = &ClientMockPauseClickPipeExpectation{}
	}

	if mmPauseClickPipe.defaultExpectation.params != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmPauseClickPipe.defaultExpectation.paramPtrs == nil {
		mmPauseClickPipe.defaultExpectation.paramPtrs = &ClientMockPauseClickPipeParamPtrs{}
	}
	mmPauseClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmPauseClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmPauseClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.PauseClickPipe
func (mmPauseClickPipe *mClientMockPauseClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockPauseClickPipe {
	if mmPauseClickPipe.mock.inspectFuncPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.ChangeClickPipeState")
	}

	mmPauseClickPipe.mock.inspectFuncPauseClickPipe = f

	return mmPauseClickPipe
}

// Return sets up results that will be returned by Client.PauseClickPipe
func (mmPauseClickPipe *mClientMockPauseClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmPauseClickPipe.mock.funcPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmPauseClickPipe.defaultExpectation == nil {
		mmPauseClickPipe.defaultExpectation = &ClientMockPauseClickPipeExpectation{mock: mmPauseClickPipe.mock}
	}
	mmPauseClickPipe.defaultExpectation.results = &ClientMockPauseClickPipeResults{cp1, err}
	mmPauseClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPauseClickPipe.mock
}

// Set uses given function f to mock the Client.PauseClickPipe method
func (mmPauseClickPipe *mClientMockPauseClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmPauseClickPipe.defaultExpectation != nil {
		mmPauseClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.ChangeClickPipeState method")
	}

	if len(mmPauseClickPipe.expectations) > 0 {
		mmPauseClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.ChangeClickPipeState method")
	}

	mmPauseClickPipe.mock.funcPauseClickPipe = f
	mmPauseClickPipe.mock.funcPauseClickPipeOrigin = minimock.CallerInfo(1)
	return mmPauseClickPipe.mock
}

// When sets expectation for the Client.PauseClickPipe which will trigger the result defined by the following
// Then helper
func (mmPauseClickPipe *mClientMockPauseClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockPauseClickPipeExpectation {
	if mmPauseClickPipe.mock.funcPauseClickPipe != nil {
		mmPauseClickPipe.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockPauseClickPipeExpectation{
		mock:               mmPauseClickPipe.mock,
		params:             &ClientMockPauseClickPipeParams{ctx, serviceId, clickPipeId},
		expectationOrigins: ClientMockPauseClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPauseClickPipe.expectations = append(mmPauseClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.PauseClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockPauseClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockPauseClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.PauseClickPipe should be invoked
func (mmPauseClickPipe *mClientMockPauseClickPipe) Times(n uint64) *mClientMockPauseClickPipe {
	if n == 0 {
		mmPauseClickPipe.mock.t.Fatalf("Times of ClientMock.ChangeClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPauseClickPipe.expectedInvocations, n)
	mmPauseClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPauseClickPipe
}

func (mmPauseClickPipe *mClientMockPauseClickPipe) invocationsDone() bool {
	if len(mmPauseClickPipe.expectations) == 0 && mmPauseClickPipe.defaultExpectation == nil && mmPauseClickPipe.mock.funcPauseClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPauseClickPipe.mock.afterPauseClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPauseClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PauseClickPipe implements Client
func (mmPauseClickPipe *ClientMock) PauseClickPipe(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmPauseClickPipe.beforePauseClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmPauseClickPipe.afterPauseClickPipeCounter, 1)

	mmPauseClickPipe.t.Helper()

	if mmPauseClickPipe.inspectFuncPauseClickPipe != nil {
		mmPauseClickPipe.inspectFuncPauseClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockPauseClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmPauseClickPipe.PauseClickPipeMock.mutex.Lock()
	mmPauseClickPipe.PauseClickPipeMock.callArgs = append(mmPauseClickPipe.PauseClickPipeMock.callArgs, &mm_params)
	mmPauseClickPipe.PauseClickPipeMock.mutex.Unlock()

	for _, e := range mmPauseClickPipe.PauseClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmPauseClickPipe.PauseClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockPauseClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPauseClickPipe.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmPauseClickPipe.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmPauseClickPipe.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPauseClickPipe.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPauseClickPipe.PauseClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmPauseClickPipe.t.Fatal("No results are set for the ClientMock.ChangeClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmPauseClickPipe.funcPauseClickPipe != nil {
		return mmPauseClickPipe.funcPauseClickPipe(ctx, serviceId, clickPipeId)
	}
	mmPauseClickPipe.t.Fatalf("Unexpected call to ClientMock.ChangeClickPipeState. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// PauseClickPipeAfterCounter returns a count of finished ClientMock.PauseClickPipe invocations
func (mmPauseClickPipe *ClientMock) PauseClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPauseClickPipe.afterPauseClickPipeCounter)
}

// PauseClickPipeBeforeCounter returns a count of ClientMock.PauseClickPipe invocations
func (mmPauseClickPipe *ClientMock) PauseClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPauseClickPipe.beforePauseClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.PauseClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPauseClickPipe *mClientMockPauseClickPipe) Calls() []*ClientMockPauseClickPipeParams {
	mmPauseClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockPauseClickPipeParams, len(mmPauseClickPipe.callArgs))
	copy(argCopy, mmPauseClickPipe.callArgs)

	mmPauseClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockPauseClickPipeDone returns true if the count of the PauseClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockPauseClickPipeDone() bool {
	if m.PauseClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PauseClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PauseClickPipeMock.invocationsDone()
}

// MinimockPauseClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockPauseClickPipeInspect() {
	for _, e := range m.PauseClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPauseClickPipeCounter := mm_atomic.LoadUint64(&m.afterPauseClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PauseClickPipeMock.defaultExpectation != nil && afterPauseClickPipeCounter < 1 {
		if m.PauseClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s", m.PauseClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s with params: %#v", m.PauseClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.PauseClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPauseClickPipe != nil && afterPauseClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState at\n%s", m.funcPauseClickPipeOrigin)
	}

	if !m.PauseClickPipeMock.invocationsDone() && afterPauseClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ChangeClickPipeState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PauseClickPipeMock.expectedInvocations), m.PauseClickPipeMock.expectedInvocationsOrigin, afterPauseClickPipeCounter)
	}
}

type mClientMockResumeClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockResumeClickPipeExpectation
	expectations       []*ClientMockResumeClickPipeExpectation

	callArgs []*ClientMockResumeClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockResumeClickPipeExpectation specifies expectation struct of the Client.ResumeClickPipe
type ClientMockResumeClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockResumeClickPipeParams
	paramPtrs          *ClientMockResumeClickPipeParamPtrs
	expectationOrigins ClientMockResumeClickPipeExpectationOrigins
	results            *ClientMockResumeClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockResumeClickPipeParams contains parameters of the Client.ResumeClickPipe
type ClientMockResumeClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockResumeClickPipeParamPtrs contains pointers to parameters of the Client.ResumeClickPipe
type ClientMockResumeClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockResumeClickPipeResults contains results of the Client.ResumeClickPipe
type ClientMockResumeClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockResumeClickPipeOrigins contains origins of expectations of the Client.ResumeClickPipe
type ClientMockResumeClickPipeExpectationOrigins struct {
	origin            string
	originCtx         string
	originServiceId   string
	originClickPipeId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmResumeClickPipe *mClientMockResumeClickPipe) Optional() *mClientMockResumeClickPipe {
	mmResumeClickPipe.optional = true
	return mmResumeClickPipe
}

// Expect sets up expected params for Client.ResumeClickPipe
func (mmResumeClickPipe *mClientMockResumeClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockResumeClickPipe {
	if mmResumeClickPipe.mock.funcResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Set")
	}

	if mmResumeClickPipe.defaultExpectation == nil {
		mmResumeClickPipe.defaultExpectation = &ClientMockResumeClickPipeExpectation{}
	}

	if mmResumeClickPipe.defaultExpectation.paramPtrs != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by ExpectParams functions")
	}

	mmResumeClickPipe.defaultExpectation.params = &ClientMockResumeClickPipeParams{ctx, serviceId, clickPipeId}
	mmResumeClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmResumeClickPipe.expectations {
		if minimock.Equal(e.params, mmResumeClickPipe.defaultExpectation.params) {
			mmResumeClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResumeClickPipe.defaultExpectation.params)
		}
	}

	return mmResumeClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.ResumeClickPipe
func (mmResumeClickPipe *mClientMockResumeClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockResumeClickPipe {
	if mmResumeClickPipe.mock.funcResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Set")
	}

	if mmResumeClickPipe.defaultExpectation == nil {
		mmResumeClickPipe.defaultExpectation = &ClientMockResumeClickPipeExpectation{}
	}

	if mmResumeClickPipe.defaultExpectation.params != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Expect")
	}

	if mmResumeClickPipe.defaultExpectation.paramPtrs == nil {
		mmResumeClickPipe.defaultExpectation.paramPtrs = &ClientMockResumeClickPipeParamPtrs{}
	}
	mmResumeClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmResumeClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmResumeClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ResumeClickPipe
func (mmResumeClickPipe *mClientMockResumeClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockResumeClickPipe {
	if mmResumeClickPipe.mock.funcResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Set")
	}

	if mmResumeClickPipe.defaultExpectation == nil {
		mmResumeClickPipe.defaultExpectation = &ClientMockResumeClickPipeExpectation{}
	}

	if mmResumeClickPipe.defaultExpectation.params != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Expect")
	}

	if mmResumeClickPipe.defaultExpectation.paramPtrs == nil {
		mmResumeClickPipe.defaultExpectation.paramPtrs = &ClientMockResumeClickPipeParamPtrs{}
	}
	mmResumeClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmResumeClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmResumeClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ResumeClickPipe
func (mmResumeClickPipe *mClientMockResumeClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockResumeClickPipe {
	if mmResumeClickPipe.mock.funcResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Set")
	}

	if mmResumeClickPipe.defaultExpectation == nil {
		mmResumeClickPipe.defaultExpectation = &ClientMockResumeClickPipeExpectation{}
	}

	if mmResumeClickPipe.defaultExpectation.params != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Expect")
	}

	if mmResumeClickPipe.defaultExpectation.paramPtrs == nil {
		mmResumeClickPipe.defaultExpectation.paramPtrs = &ClientMockResumeClickPipeParamPtrs{}
	}
	mmResumeClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmResumeClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmResumeClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.ResumeClickPipe
func (mmResumeClickPipe *mClientMockResumeClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockResumeClickPipe {
	if mmResumeClickPipe.mock.inspectFuncResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.ResumeClickPipe")
	}

	mmResumeClickPipe.mock.inspectFuncResumeClickPipe = f

	return mmResumeClickPipe
}

// Return sets up results that will be returned by Client.ResumeClickPipe
func (mmResumeClickPipe *mClientMockResumeClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmResumeClickPipe.mock.funcResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Set")
	}

	if mmResumeClickPipe.defaultExpectation == nil {
		mmResumeClickPipe.defaultExpectation = &ClientMockResumeClickPipeExpectation{mock: mmResumeClickPipe.mock}
	}
	mmResumeClickPipe.defaultExpectation.results = &ClientMockResumeClickPipeResults{cp1, err}
	mmResumeClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmResumeClickPipe.mock
}

// Set uses given function f to mock the Client.ResumeClickPipe method
func (mmResumeClickPipe *mClientMockResumeClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmResumeClickPipe.defaultExpectation != nil {
		mmResumeClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.ResumeClickPipe method")
	}

	if len(mmResumeClickPipe.expectations) > 0 {
		mmResumeClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.ResumeClickPipe method")
	}

	mmResumeClickPipe.mock.funcResumeClickPipe = f
	mmResumeClickPipe.mock.funcResumeClickPipeOrigin = minimock.CallerInfo(1)
	return mmResumeClickPipe.mock
}

// When sets expectation for the Client.ResumeClickPipe which will trigger the result defined by the following
// Then helper
func (mmResumeClickPipe *mClientMockResumeClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockResumeClickPipeExpectation {
	if mmResumeClickPipe.mock.funcResumeClickPipe != nil {
		mmResumeClickPipe.mock.t.Fatalf("ClientMock.ResumeClickPipe mock is already set by Set")
	}

	expectation := &ClientMockResumeClickPipeExpectation{
		mock:               mmResumeClickPipe.mock,
		params:             &ClientMockResumeClickPipeParams{ctx, serviceId, clickPipeId},
		expectationOrigins: ClientMockResumeClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmResumeClickPipe.expectations = append(mmResumeClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.ResumeClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockResumeClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockResumeClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ResumeClickPipe should be invoked
func (mmResumeClickPipe *mClientMockResumeClickPipe) Times(n uint64) *mClientMockResumeClickPipe {
	if n == 0 {
		mmResumeClickPipe.mock.t.Fatalf("Times of ClientMock.ResumeClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmResumeClickPipe.expectedInvocations, n)
	mmResumeClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmResumeClickPipe
}

func (mmResumeClickPipe *mClientMockResumeClickPipe) invocationsDone() bool {
	if len(mmResumeClickPipe.expectations) == 0 && mmResumeClickPipe.defaultExpectation == nil && mmResumeClickPipe.mock.funcResumeClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmResumeClickPipe.mock.afterResumeClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmResumeClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ResumeClickPipe implements Client
func (mmResumeClickPipe *ClientMock) ResumeClickPipe(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmResumeClickPipe.beforeResumeClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmResumeClickPipe.afterResumeClickPipeCounter, 1)

	mmResumeClickPipe.t.Helper()

	if mmResumeClickPipe.inspectFuncResumeClickPipe != nil {
		mmResumeClickPipe.inspectFuncResumeClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockResumeClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmResumeClickPipe.ResumeClickPipeMock.mutex.Lock()
	mmResumeClickPipe.ResumeClickPipeMock.callArgs = append(mmResumeClickPipe.ResumeClickPipeMock.callArgs, &mm_params)
	mmResumeClickPipe.ResumeClickPipeMock.mutex.Unlock()

	for _, e := range mmResumeClickPipe.ResumeClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockResumeClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmResumeClickPipe.t.Errorf("ClientMock.ResumeClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmResumeClickPipe.t.Errorf("ClientMock.ResumeClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmResumeClickPipe.t.Errorf("ClientMock.ResumeClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResumeClickPipe.t.Errorf("ClientMock.ResumeClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmResumeClickPipe.ResumeClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmResumeClickPipe.t.Fatal("No results are set for the ClientMock.ResumeClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmResumeClickPipe.funcResumeClickPipe != nil {
		return mmResumeClickPipe.funcResumeClickPipe(ctx, serviceId, clickPipeId)
	}
	mmResumeClickPipe.t.Fatalf("Unexpected call to ClientMock.ResumeClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// ResumeClickPipeAfterCounter returns a count of finished ClientMock.ResumeClickPipe invocations
func (mmResumeClickPipe *ClientMock) ResumeClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResumeClickPipe.afterResumeClickPipeCounter)
}

// ResumeClickPipeBeforeCounter returns a count of ClientMock.ResumeClickPipe invocations
func (mmResumeClickPipe *ClientMock) ResumeClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResumeClickPipe.beforeResumeClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ResumeClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResumeClickPipe *mClientMockResumeClickPipe) Calls() []*ClientMockResumeClickPipeParams {
	mmResumeClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockResumeClickPipeParams, len(mmResumeClickPipe.callArgs))
	copy(argCopy, mmResumeClickPipe.callArgs)

	mmResumeClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockResumeClickPipeDone returns true if the count of the ResumeClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockResumeClickPipeDone() bool {
	if m.ResumeClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ResumeClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ResumeClickPipeMock.invocationsDone()
}

// MinimockResumeClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockResumeClickPipeInspect() {
	for _, e := range m.ResumeClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ResumeClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterResumeClickPipeCounter := mm_atomic.LoadUint64(&m.afterResumeClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ResumeClickPipeMock.defaultExpectation != nil && afterResumeClickPipeCounter < 1 {
		if m.ResumeClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ResumeClickPipe at\n%s", m.ResumeClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ResumeClickPipe at\n%s with params: %#v", m.ResumeClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.ResumeClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResumeClickPipe != nil && afterResumeClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ResumeClickPipe at\n%s", m.funcResumeClickPipeOrigin)
	}

	if !m.ResumeClickPipeMock.invocationsDone() && afterResumeClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ResumeClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ResumeClickPipeMock.expectedInvocations), m.ResumeClickPipeMock.expectedInvocationsOrigin, afterResumeClickPipeCounter)
	}
}

type mClientMockScaleClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockScaleClickPipeExpectation
	expectations       []*ClientMockScaleClickPipeExpectation

	callArgs []*ClientMockScaleClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockScaleClickPipeExpectation specifies expectation struct of the Client.ScaleClickPipe
type ClientMockScaleClickPipeExpectation struct {
	mock               *ClientMock
	params             *ClientMockScaleClickPipeParams
	paramPtrs          *ClientMockScaleClickPipeParamPtrs
	expectationOrigins ClientMockScaleClickPipeExpectationOrigins
	results            *ClientMockScaleClickPipeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockScaleClickPipeParams contains parameters of the Client.ScaleClickPipe
type ClientMockScaleClickPipeParams struct {
	ctx             context.Context
	serviceId       string
	clickPipeId     string
	desiredReplicas int64
}

// ClientMockScaleClickPipeParamPtrs contains pointers to parameters of the Client.ScaleClickPipe
type ClientMockScaleClickPipeParamPtrs struct {
	ctx             *context.Context
	serviceId       *string
	clickPipeId     *string
	desiredReplicas *int64
}

// ClientMockScaleClickPipeResults contains results of the Client.ScaleClickPipe
type ClientMockScaleClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// ClientMockScaleClickPipeOrigins contains origins of expectations of the Client.ScaleClickPipe
type ClientMockScaleClickPipeExpectationOrigins struct {
	origin                string
	originCtx             string
	originServiceId       string
	originClickPipeId     string
	originDesiredReplicas string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScaleClickPipe *mClientMockScaleClickPipe) Optional() *mClientMockScaleClickPipe {
	mmScaleClickPipe.optional = true
	return mmScaleClickPipe
}

// Expect sets up expected params for Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64) *mClientMockScaleClickPipe {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScaleClickPipe.defaultExpectation == nil {
		mmScaleClickPipe.defaultExpectation = &ClientMockScaleClickPipeExpectation{}
	}

	if mmScaleClickPipe.defaultExpectation.paramPtrs != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by ExpectParams functions")
	}

	mmScaleClickPipe.defaultExpectation.params = &ClientMockScaleClickPipeParams{ctx, serviceId, clickPipeId, desiredReplicas}
	mmScaleClickPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScaleClickPipe.expectations {
		if minimock.Equal(e.params, mmScaleClickPipe.defaultExpectation.params) {
			mmScaleClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScaleClickPipe.defaultExpectation.params)
		}
	}

	return mmScaleClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockScaleClickPipe {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScaleClickPipe.defaultExpectation == nil {
		mmScaleClickPipe.defaultExpectation = &ClientMockScaleClickPipeExpectation{}
	}

	if mmScaleClickPipe.defaultExpectation.params != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScaleClickPipe.defaultExpectation.paramPtrs == nil {
		mmScaleClickPipe.defaultExpectation.paramPtrs = &ClientMockScaleClickPipeParamPtrs{}
	}
	mmScaleClickPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmScaleClickPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScaleClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockScaleClickPipe {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScaleClickPipe.defaultExpectation == nil {
		mmScaleClickPipe.defaultExpectation = &ClientMockScaleClickPipeExpectation{}
	}

	if mmScaleClickPipe.defaultExpectation.params != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScaleClickPipe.defaultExpectation.paramPtrs == nil {
		mmScaleClickPipe.defaultExpectation.paramPtrs = &ClientMockScaleClickPipeParamPtrs{}
	}
	mmScaleClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmScaleClickPipe.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmScaleClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockScaleClickPipe {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScaleClickPipe.defaultExpectation == nil {
		mmScaleClickPipe.defaultExpectation = &ClientMockScaleClickPipeExpectation{}
	}

	if mmScaleClickPipe.defaultExpectation.params != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScaleClickPipe.defaultExpectation.paramPtrs == nil {
		mmScaleClickPipe.defaultExpectation.paramPtrs = &ClientMockScaleClickPipeParamPtrs{}
	}
	mmScaleClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId
	mmScaleClickPipe.defaultExpectation.expectationOrigins.originClickPipeId = minimock.CallerInfo(1)

	return mmScaleClickPipe
}

// ExpectDesiredReplicasParam4 sets up expected param desiredReplicas for Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) ExpectDesiredReplicasParam4(desiredReplicas int64) *mClientMockScaleClickPipe {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScaleClickPipe.defaultExpectation == nil {
		mmScaleClickPipe.defaultExpectation = &ClientMockScaleClickPipeExpectation{}
	}

	if mmScaleClickPipe.defaultExpectation.params != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScaleClickPipe.defaultExpectation.paramPtrs == nil {
		mmScaleClickPipe.defaultExpectation.paramPtrs = &ClientMockScaleClickPipeParamPtrs{}
	}
	mmScaleClickPipe.defaultExpectation.paramPtrs.desiredReplicas = &desiredReplicas
	mmScaleClickPipe.defaultExpectation.expectationOrigins.originDesiredReplicas = minimock.CallerInfo(1)

	return mmScaleClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64)) *mClientMockScaleClickPipe {
	if mmScaleClickPipe.mock.inspectFuncScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.ScalingClickPipe")
	}

	mmScaleClickPipe.mock.inspectFuncScaleClickPipe = f

	return mmScaleClickPipe
}

// Return sets up results that will be returned by Client.ScaleClickPipe
func (mmScaleClickPipe *mClientMockScaleClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScaleClickPipe.defaultExpectation == nil {
		mmScaleClickPipe.defaultExpectation = &ClientMockScaleClickPipeExpectation{mock: mmScaleClickPipe.mock}
	}
	mmScaleClickPipe.defaultExpectation.results = &ClientMockScaleClickPipeResults{cp1, err}
	mmScaleClickPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScaleClickPipe.mock
}

// Set uses given function f to mock the Client.ScaleClickPipe method
func (mmScaleClickPipe *mClientMockScaleClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmScaleClickPipe.defaultExpectation != nil {
		mmScaleClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.ScalingClickPipe method")
	}

	if len(mmScaleClickPipe.expectations) > 0 {
		mmScaleClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.ScalingClickPipe method")
	}

	mmScaleClickPipe.mock.funcScaleClickPipe = f
	mmScaleClickPipe.mock.funcScaleClickPipeOrigin = minimock.CallerInfo(1)
	return mmScaleClickPipe.mock
}

// When sets expectation for the Client.ScaleClickPipe which will trigger the result defined by the following
// Then helper
func (mmScaleClickPipe *mClientMockScaleClickPipe) When(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64) *ClientMockScaleClickPipeExpectation {
	if mmScaleClickPipe.mock.funcScaleClickPipe != nil {
		mmScaleClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	expectation := &ClientMockScaleClickPipeExpectation{
		mock:               mmScaleClickPipe.mock,
		params:             &ClientMockScaleClickPipeParams{ctx, serviceId, clickPipeId, desiredReplicas},
		expectationOrigins: ClientMockScaleClickPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScaleClickPipe.expectations = append(mmScaleClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.ScaleClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockScaleClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockScaleClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ScaleClickPipe should be invoked
func (mmScaleClickPipe *mClientMockScaleClickPipe) Times(n uint64) *mClientMockScaleClickPipe {
	if n == 0 {
		mmScaleClickPipe.mock.t.Fatalf("Times of ClientMock.ScalingClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScaleClickPipe.expectedInvocations, n)
	mmScaleClickPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScaleClickPipe
}

func (mmScaleClickPipe *mClientMockScaleClickPipe) invocationsDone() bool {
	if len(mmScaleClickPipe.expectations) == 0 && mmScaleClickPipe.defaultExpectation == nil && mmScaleClickPipe.mock.funcScaleClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScaleClickPipe.mock.afterScaleClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScaleClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScaleClickPipe implements Client
func (mmScaleClickPipe *ClientMock) ScaleClickPipe(ctx context.Context, serviceId string, clickPipeId string, desiredReplicas int64) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmScaleClickPipe.beforeScaleClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmScaleClickPipe.afterScaleClickPipeCounter, 1)

	mmScaleClickPipe.t.Helper()

	if mmScaleClickPipe.inspectFuncScaleClickPipe != nil {
		mmScaleClickPipe.inspectFuncScaleClickPipe(ctx, serviceId, clickPipeId, desiredReplicas)
	}

	mm_params := ClientMockScaleClickPipeParams{ctx, serviceId, clickPipeId, desiredReplicas}

	// Record call args
	mmScaleClickPipe.ScaleClickPipeMock.mutex.Lock()
	mmScaleClickPipe.ScaleClickPipeMock.callArgs = append(mmScaleClickPipe.ScaleClickPipeMock.callArgs, &mm_params)
	mmScaleClickPipe.ScaleClickPipeMock.mutex.Unlock()

	for _, e := range mmScaleClickPipe.ScaleClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockScaleClickPipeParams{ctx, serviceId, clickPipeId, desiredReplicas}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScaleClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmScaleClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmScaleClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter clickPipeId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.expectationOrigins.originClickPipeId, *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.desiredReplicas != nil && !minimock.Equal(*mm_want_ptrs.desiredReplicas, mm_got.desiredReplicas) {
				mmScaleClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter desiredReplicas, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.expectationOrigins.originDesiredReplicas, *mm_want_ptrs.desiredReplicas, mm_got.desiredReplicas, minimock.Diff(*mm_want_ptrs.desiredReplicas, mm_got.desiredReplicas))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScaleClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScaleClickPipe.ScaleClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmScaleClickPipe.t.Fatal("No results are set for the ClientMock.ScalingClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmScaleClickPipe.funcScaleClickPipe != nil {
		return mmScaleClickPipe.funcScaleClickPipe(ctx, serviceId, clickPipeId, desiredReplicas)
	}
	mmScaleClickPipe.t.Fatalf("Unexpected call to ClientMock.ScalingClickPipe. %v %v %v %v", ctx, serviceId, clickPipeId, desiredReplicas)
	return
}

// ScaleClickPipeAfterCounter returns a count of finished ClientMock.ScaleClickPipe invocations
func (mmScaleClickPipe *ClientMock) ScaleClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScaleClickPipe.afterScaleClickPipeCounter)
}

// ScaleClickPipeBeforeCounter returns a count of ClientMock.ScaleClickPipe invocations
func (mmScaleClickPipe *ClientMock) ScaleClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScaleClickPipe.beforeScaleClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ScaleClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScaleClickPipe *mClientMockScaleClickPipe) Calls() []*ClientMockScaleClickPipeParams {
	mmScaleClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockScaleClickPipeParams, len(mmScaleClickPipe.callArgs))
	copy(argCopy, mmScaleClickPipe.callArgs)

	mmScaleClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockScaleClickPipeDone returns true if the count of the ScaleClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockScaleClickPipeDone() bool {
	if m.ScaleClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScaleClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScaleClickPipeMock.invocationsDone()
}

// MinimockScaleClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockScaleClickPipeInspect() {
	for _, e := range m.ScaleClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScaleClickPipeCounter := mm_atomic.LoadUint64(&m.afterScaleClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScaleClickPipeMock.defaultExpectation != nil && afterScaleClickPipeCounter < 1 {
		if m.ScaleClickPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s", m.ScaleClickPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s with params: %#v", m.ScaleClickPipeMock.defaultExpectation.expectationOrigins.origin, *m.ScaleClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScaleClickPipe != nil && afterScaleClickPipeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ScalingClickPipe at\n%s", m.funcScaleClickPipeOrigin)
	}

	if !m.ScaleClickPipeMock.invocationsDone() && afterScaleClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ScalingClickPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScaleClickPipeMock.expectedInvocations), m.ScaleClickPipeMock.expectedInvocationsOrigin, afterScaleClickPipeCounter)
	}
}

type mClientMockUpdateBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateBackupConfigurationExpectation
	expectations       []*ClientMockUpdateBackupConfigurationExpectation

	callArgs []*ClientMockUpdateBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateBackupConfigurationExpectation specifies expectation struct of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateBackupConfigurationParams
	paramPtrs          *ClientMockUpdateBackupConfigurationParamPtrs
	expectationOrigins ClientMockUpdateBackupConfigurationExpectationOrigins
	results            *ClientMockUpdateBackupConfigurationResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateBackupConfigurationParams contains parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
	b         BackupConfiguration
}

// ClientMockUpdateBackupConfigurationParamPtrs contains pointers to parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	b         *BackupConfiguration
}

// ClientMockUpdateBackupConfigurationResults contains results of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// ClientMockUpdateBackupConfigurationOrigins contains origins of expectations of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originB         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Optional() *mClientMockUpdateBackupConfiguration {
	mmUpdateBackupConfiguration.optional = true
	return mmUpdateBackupConfiguration
}

// Expect sets up expected params for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Expect(ctx context.Context, serviceId string, b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmUpdateBackupConfiguration.defaultExpectation.params = &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmUpdateBackupConfiguration.defaultExpectation.params) {
			mmUpdateBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmUpdateBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateBackupConfiguration
}

// ExpectBParam3 sets up expected param b for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectBParam3(b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.b = &b
	mmUpdateBackupConfiguration.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmUpdateBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string, b BackupConfiguration)) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateBackupConfiguration")
	}

	mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration = f

	return mmUpdateBackupConfiguration
}

// Return sets up results that will be returned by Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{mock: mmUpdateBackupConfiguration.mock}
	}
	mmUpdateBackupConfiguration.defaultExpectation.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	mmUpdateBackupConfiguration.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateBackupConfiguration.mock
}

// Set uses given function f to mock the Client.UpdateBackupConfiguration method
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Set(f func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmUpdateBackupConfiguration.defaultExpectation != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.UpdateBackupConfiguration method")
	}

	if len(mmUpdateBackupConfiguration.expectations) > 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.UpdateBackupConfiguration method")
	}

	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration = f
	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfigurationOrigin = minimock.CallerInfo(1)
	return mmUpdateBackupConfiguration.mock
}

// When sets expectation for the Client.UpdateBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) When(ctx context.Context, serviceId string, b BackupConfiguration) *ClientMockUpdateBackupConfigurationExpectation {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockUpdateBackupConfigurationExpectation{
		mock:               mmUpdateBackupConfiguration.mock,
		params:             &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b},
		expectationOrigins: ClientMockUpdateBackupConfigurationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateBackupConfiguration.expectations = append(mmUpdateBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateBackupConfiguration should be invoked
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Times(n uint64) *mClientMockUpdateBackupConfiguration {
	if n == 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Times of ClientMock.UpdateBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateBackupConfiguration.expectedInvocations, n)
	mmUpdateBackupConfiguration.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateBackupConfiguration
}

func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) invocationsDone() bool {
	if len(mmUpdateBackupConfiguration.expectations) == 0 && mmUpdateBackupConfiguration.defaultExpectation == nil && mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.mock.afterUpdateBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateBackupConfiguration implements Client
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfiguration(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter, 1)

	mmUpdateBackupConfiguration.t.Helper()

	if mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration(ctx, serviceId, b)
	}

	mm_params := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

	// Record call args
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Lock()
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs = append(mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs, &mm_params)
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBackupConfiguration.t.Fatal("No results are set for the ClientMock.UpdateBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmUpdateBackupConfiguration.funcUpdateBackupConfiguration != nil {
		return mmUpdateBackupConfiguration.funcUpdateBackupConfiguration(ctx, serviceId, b)
	}
	mmUpdateBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.UpdateBackupConfiguration. %v %v %v", ctx, serviceId, b)
	return
}

// UpdateBackupConfigurationAfterCounter returns a count of finished ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter)
}

// UpdateBackupConfigurationBeforeCounter returns a count of ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Calls() []*ClientMockUpdateBackupConfigurationParams {
	mmUpdateBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockUpdateBackupConfigurationParams, len(mmUpdateBackupConfiguration.callArgs))
	copy(argCopy, mmUpdateBackupConfiguration.callArgs)

	mmUpdateBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBackupConfigurationDone returns true if the count of the UpdateBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateBackupConfigurationDone() bool {
	if m.UpdateBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateBackupConfigurationMock.invocationsDone()
}

// MinimockUpdateBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateBackupConfigurationInspect() {
	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterUpdateBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBackupConfigurationMock.defaultExpectation != nil && afterUpdateBackupConfigurationCounter < 1 {
		if m.UpdateBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s", m.UpdateBackupConfigurationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s with params: %#v", m.UpdateBackupConfigurationMock.defaultExpectation.expectationOrigins.origin, *m.UpdateBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBackupConfiguration != nil && afterUpdateBackupConfigurationCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration at\n%s", m.funcUpdateBackupConfigurationOrigin)
	}

	if !m.UpdateBackupConfigurationMock.invocationsDone() && afterUpdateBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateBackupConfiguration at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateBackupConfigurationMock.expectedInvocations), m.UpdateBackupConfigurationMock.expectedInvocationsOrigin, afterUpdateBackupConfigurationCounter)
	}
}

type mClientMockUpdateOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockUpdateOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockUpdateOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateOrganizationPrivateEndpointsParams
	paramPtrs          *ClientMockUpdateOrganizationPrivateEndpointsParamPtrs
	expectationOrigins ClientMockUpdateOrganizationPrivateEndpointsExpectationOrigins
	results            *ClientMockUpdateOrganizationPrivateEndpointsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsParams contains parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParams struct {
	ctx       context.Context
	orgUpdate OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	orgUpdate *OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsResults contains results of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// ClientMockUpdateOrganizationPrivateEndpointsOrigins contains origins of expectations of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectationOrigins struct {
	origin          string
	originCtx       string
	originOrgUpdate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Optional() *mClientMockUpdateOrganizationPrivateEndpoints {
	mmUpdateOrganizationPrivateEndpoints.optional = true
	return mmUpdateOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Expect(ctx context.Context, orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectOrgUpdateParam2 sets up expected param orgUpdate for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectOrgUpdateParam2(orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.orgUpdate = &orgUpdate
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.expectationOrigins.originOrgUpdate = minimock.CallerInfo(1)

	return mmUpdateOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context, orgUpdate OrganizationUpdate)) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints = f

	return mmUpdateOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{mock: mmUpdateOrganizationPrivateEndpoints.mock}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.UpdateOrganizationPrivateEndpoints method
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Set(f func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	if len(mmUpdateOrganizationPrivateEndpoints.expectations) > 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints = f
	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpointsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.UpdateOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) When(ctx context.Context, orgUpdate OrganizationUpdate) *ClientMockUpdateOrganizationPrivateEndpointsExpectation {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockUpdateOrganizationPrivateEndpointsExpectation{
		mock:               mmUpdateOrganizationPrivateEndpoints.mock,
		params:             &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate},
		expectationOrigins: ClientMockUpdateOrganizationPrivateEndpointsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrganizationPrivateEndpoints.expectations = append(mmUpdateOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.UpdateOrganizationPrivateEndpoints should be invoked
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Times(n uint64) *mClientMockUpdateOrganizationPrivateEndpoints {
	if n == 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.UpdateOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations, n)
	mmUpdateOrganizationPrivateEndpoints.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationPrivateEndpoints
}

func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmUpdateOrganizationPrivateEndpoints.expectations) == 0 && mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil && mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.mock.afterUpdateOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrganizationPrivateEndpoints implements Client
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpoints(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter, 1)

	mmUpdateOrganizationPrivateEndpoints.t.Helper()

	if mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}

	mm_params := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

	// Record call args
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Lock()
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs = append(mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orgUpdate != nil && !minimock.Equal(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter orgUpdate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.originOrgUpdate, *mm_want_ptrs.orgUpdate, mm_got.orgUpdate, minimock.Diff(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.UpdateOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints != nil {
		return mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}
	mmUpdateOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.UpdateOrganizationPrivateEndpoints. %v %v", ctx, orgUpdate)
	return
}

// UpdateOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter)
}

// UpdateOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Calls() []*ClientMockUpdateOrganizationPrivateEndpointsParams {
	mmUpdateOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockUpdateOrganizationPrivateEndpointsParams, len(mmUpdateOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmUpdateOrganizationPrivateEndpoints.callArgs)

	mmUpdateOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrganizationPrivateEndpointsDone returns true if the count of the UpdateOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsDone() bool {
	if m.UpdateOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockUpdateOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsInspect() {
	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterUpdateOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s", m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s with params: %#v", m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrganizationPrivateEndpoints != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s", m.funcUpdateOrganizationPrivateEndpointsOrigin)
	}

	if !m.UpdateOrganizationPrivateEndpointsMock.invocationsDone() && afterUpdateOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateOrganizationPrivateEndpoints at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrganizationPrivateEndpointsMock.expectedInvocations), m.UpdateOrganizationPrivateEndpointsMock.expectedInvocationsOrigin, afterUpdateOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockUpdateReplicaScaling struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateReplicaScalingExpectation
	expectations       []*ClientMockUpdateReplicaScalingExpectation

	callArgs []*ClientMockUpdateReplicaScalingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateReplicaScalingExpectation specifies expectation struct of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateReplicaScalingParams
	paramPtrs          *ClientMockUpdateReplicaScalingParamPtrs
	expectationOrigins ClientMockUpdateReplicaScalingExpectationOrigins
	results            *ClientMockUpdateReplicaScalingResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateReplicaScalingParams contains parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParams struct {
	ctx       context.Context
	serviceId string
	s         ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingParamPtrs contains pointers to parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingResults contains results of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingResults struct {
	sp1 *Service
	err error
}

// ClientMockUpdateReplicaScalingOrigins contains origins of expectations of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originS         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Optional() *mClientMockUpdateReplicaScaling {
	mmUpdateReplicaScaling.optional = true
	return mmUpdateReplicaScaling
}

// Expect sets up expected params for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Expect(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by ExpectParams functions")
	}

	mmUpdateReplicaScaling.defaultExpectation.params = &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateReplicaScaling.expectations {
		if minimock.Equal(e.params, mmUpdateReplicaScaling.defaultExpectation.params) {
			mmUpdateReplicaScaling.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReplicaScaling.defaultExpectation.params)
		}
	}

	return mmUpdateReplicaScaling
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateReplicaScaling
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateReplicaScaling
}

// ExpectSParam3 sets up expected param s for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectSParam3(s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.s = &s
	mmUpdateReplicaScaling.defaultExpectation.expectationOrigins.originS = minimock.CallerInfo(1)

	return mmUpdateReplicaScaling
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Inspect(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateReplicaScaling")
	}

	mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling = f

	return mmUpdateReplicaScaling
}

// Return sets up results that will be returned by Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{mock: mmUpdateReplicaScaling.mock}
	}
	mmUpdateReplicaScaling.defaultExpectation.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	mmUpdateReplicaScaling.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateReplicaScaling.mock
}

// Set uses given function f to mock the Client.UpdateReplicaScaling method
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Set(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateReplicaScaling.defaultExpectation != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Default expectation is already set for the Client.UpdateReplicaScaling method")
	}

	if len(mmUpdateReplicaScaling.expectations) > 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Some expectations are already set for the Client.UpdateReplicaScaling method")
	}

	mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling = f
	mmUpdateReplicaScaling.mock.funcUpdateReplicaScalingOrigin = minimock.CallerInfo(1)
	return mmUpdateReplicaScaling.mock
}

// When sets expectation for the Client.UpdateReplicaScaling which will trigger the result defined by the following
// Then helper
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) When(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *ClientMockUpdateReplicaScalingExpectation {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	expectation := &ClientMockUpdateReplicaScalingExpectation{
		mock:               mmUpdateReplicaScaling.mock,
		params:             &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s},
		expectationOrigins: ClientMockUpdateReplicaScalingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateReplicaScaling.expectations = append(mmUpdateReplicaScaling.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateReplicaScaling return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateReplicaScalingExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateReplicaScaling should be invoked
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Times(n uint64) *mClientMockUpdateReplicaScaling {
	if n == 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Times of ClientMock.UpdateReplicaScaling mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReplicaScaling.expectedInvocations, n)
	mmUpdateReplicaScaling.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateReplicaScaling
}

func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) invocationsDone() bool {
	if len(mmUpdateReplicaScaling.expectations) == 0 && mmUpdateReplicaScaling.defaultExpectation == nil && mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.mock.afterUpdateReplicaScalingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReplicaScaling implements Client
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScaling(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter, 1)

	mmUpdateReplicaScaling.t.Helper()

	if mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

	// Record call args
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Lock()
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs = append(mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs, &mm_params)
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Unlock()

	for _, e := range mmUpdateReplicaScaling.UpdateReplicaScalingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter s, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.originS, *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReplicaScaling.t.Fatal("No results are set for the ClientMock.UpdateReplicaScaling")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateReplicaScaling.funcUpdateReplicaScaling != nil {
		return mmUpdateReplicaScaling.funcUpdateReplicaScaling(ctx, serviceId, s)
	}
	mmUpdateReplicaScaling.t.Fatalf("Unexpected call to ClientMock.UpdateReplicaScaling. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateReplicaScalingAfterCounter returns a count of finished ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter)
}

// UpdateReplicaScalingBeforeCounter returns a count of ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateReplicaScaling.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Calls() []*ClientMockUpdateReplicaScalingParams {
	mmUpdateReplicaScaling.mutex.RLock()

	argCopy := make([]*ClientMockUpdateReplicaScalingParams, len(mmUpdateReplicaScaling.callArgs))
	copy(argCopy, mmUpdateReplicaScaling.callArgs)

	mmUpdateReplicaScaling.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReplicaScalingDone returns true if the count of the UpdateReplicaScaling invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateReplicaScalingDone() bool {
	if m.UpdateReplicaScalingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReplicaScalingMock.invocationsDone()
}

// MinimockUpdateReplicaScalingInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateReplicaScalingInspect() {
	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateReplicaScalingCounter := mm_atomic.LoadUint64(&m.afterUpdateReplicaScalingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReplicaScalingMock.defaultExpectation != nil && afterUpdateReplicaScalingCounter < 1 {
		if m.UpdateReplicaScalingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s", m.UpdateReplicaScalingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s with params: %#v", m.UpdateReplicaScalingMock.defaultExpectation.expectationOrigins.origin, *m.UpdateReplicaScalingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReplicaScaling != nil && afterUpdateReplicaScalingCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling at\n%s", m.funcUpdateReplicaScalingOrigin)
	}

	if !m.UpdateReplicaScalingMock.invocationsDone() && afterUpdateReplicaScalingCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateReplicaScaling at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReplicaScalingMock.expectedInvocations), m.UpdateReplicaScalingMock.expectedInvocationsOrigin, afterUpdateReplicaScalingCounter)
	}
}

type mClientMockUpdateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServiceExpectation
	expectations       []*ClientMockUpdateServiceExpectation

	callArgs []*ClientMockUpdateServiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateServiceExpectation specifies expectation struct of the Client.UpdateService
type ClientMockUpdateServiceExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateServiceParams
	paramPtrs          *ClientMockUpdateServiceParamPtrs
	expectationOrigins ClientMockUpdateServiceExpectationOrigins
	results            *ClientMockUpdateServiceResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateServiceParams contains parameters of the Client.UpdateService
type ClientMockUpdateServiceParams struct {
	ctx       context.Context
	serviceId string
	s         ServiceUpdate
}

// ClientMockUpdateServiceParamPtrs contains pointers to parameters of the Client.UpdateService
type ClientMockUpdateServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ServiceUpdate
}

// ClientMockUpdateServiceResults contains results of the Client.UpdateService
type ClientMockUpdateServiceResults struct {
	sp1 *Service
	err error
}

// ClientMockUpdateServiceOrigins contains origins of expectations of the Client.UpdateService
type ClientMockUpdateServiceExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originS         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateService *mClientMockUpdateService) Optional() *mClientMockUpdateService {
	mmUpdateService.optional = true
	return mmUpdateService
}

// Expect sets up expected params for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Expect(ctx context.Context, serviceId string, s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.paramPtrs != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by ExpectParams functions")
	}

	mmUpdateService.defaultExpectation.params = &ClientMockUpdateServiceParams{ctx, serviceId, s}
	mmUpdateService.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateService.expectations {
		if minimock.Equal(e.params, mmUpdateService.defaultExpectation.params) {
			mmUpdateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateService.defaultExpectation.params)
		}
	}

	return mmUpdateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateService.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateService.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateService
}

// ExpectSParam3 sets up expected param s for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectSParam3(s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.s = &s
	mmUpdateService.defaultExpectation.expectationOrigins.originS = minimock.CallerInfo(1)

	return mmUpdateService
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Inspect(f func(ctx context.Context, serviceId string, s ServiceUpdate)) *mClientMockUpdateService {
	if mmUpdateService.mock.inspectFuncUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateService")
	}

	mmUpdateService.mock.inspectFuncUpdateService = f

	return mmUpdateService
}

// Return sets up results that will be returned by Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{mock: mmUpdateService.mock}
	}
	mmUpdateService.defaultExpectation.results = &ClientMockUpdateServiceResults{sp1, err}
	mmUpdateService.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateService.mock
}

// Set uses given function f to mock the Client.UpdateService method
func (mmUpdateService *mClientMockUpdateService) Set(f func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateService.defaultExpectation != nil {
		mmUpdateService.mock.t.Fatalf("Default expectation is already set for the Client.UpdateService method")
	}

	if len(mmUpdateService.expectations) > 0 {
		mmUpdateService.mock.t.Fatalf("Some expectations are already set for the Client.UpdateService method")
	}

	mmUpdateService.mock.funcUpdateService = f
	mmUpdateService.mock.funcUpdateServiceOrigin = minimock.CallerInfo(1)
	return mmUpdateService.mock
}

// When sets expectation for the Client.UpdateService which will trigger the result defined by the following
// Then helper
func (mmUpdateService *mClientMockUpdateService) When(ctx context.Context, serviceId string, s ServiceUpdate) *ClientMockUpdateServiceExpectation {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	expectation := &ClientMockUpdateServiceExpectation{
		mock:               mmUpdateService.mock,
		params:             &ClientMockUpdateServiceParams{ctx, serviceId, s},
		expectationOrigins: ClientMockUpdateServiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateService.expectations = append(mmUpdateService.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateService return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateService should be invoked
func (mmUpdateService *mClientMockUpdateService) Times(n uint64) *mClientMockUpdateService {
	if n == 0 {
		mmUpdateService.mock.t.Fatalf("Times of ClientMock.UpdateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateService.expectedInvocations, n)
	mmUpdateService.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateService
}

func (mmUpdateService *mClientMockUpdateService) invocationsDone() bool {
	if len(mmUpdateService.expectations) == 0 && mmUpdateService.defaultExpectation == nil && mmUpdateService.mock.funcUpdateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateService.mock.afterUpdateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateService implements Client
func (mmUpdateService *ClientMock) UpdateService(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateService.beforeUpdateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateService.afterUpdateServiceCounter, 1)

	mmUpdateService.t.Helper()

	if mmUpdateService.inspectFuncUpdateService != nil {
		mmUpdateService.inspectFuncUpdateService(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateServiceParams{ctx, serviceId, s}

	// Record call args
	mmUpdateService.UpdateServiceMock.mutex.Lock()
	mmUpdateService.UpdateServiceMock.callArgs = append(mmUpdateService.UpdateServiceMock.callArgs, &mm_params)
	mmUpdateService.UpdateServiceMock.mutex.Unlock()

	for _, e := range mmUpdateService.UpdateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateService.UpdateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateService.UpdateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateService.UpdateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateService.UpdateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServiceParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter s, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.originS, *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateService.UpdateServiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateService.UpdateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateService.t.Fatal("No results are set for the ClientMock.UpdateService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateService.funcUpdateService != nil {
		return mmUpdateService.funcUpdateService(ctx, serviceId, s)
	}
	mmUpdateService.t.Fatalf("Unexpected call to ClientMock.UpdateService. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateServiceAfterCounter returns a count of finished ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.afterUpdateServiceCounter)
}

// UpdateServiceBeforeCounter returns a count of ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.beforeUpdateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateService *mClientMockUpdateService) Calls() []*ClientMockUpdateServiceParams {
	mmUpdateService.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServiceParams, len(mmUpdateService.callArgs))
	copy(argCopy, mmUpdateService.callArgs)

	mmUpdateService.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServiceDone returns true if the count of the UpdateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServiceDone() bool {
	if m.UpdateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServiceMock.invocationsDone()
}

// MinimockUpdateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServiceInspect() {
	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateServiceCounter := mm_atomic.LoadUint64(&m.afterUpdateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServiceMock.defaultExpectation != nil && afterUpdateServiceCounter < 1 {
		if m.UpdateServiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s", m.UpdateServiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s with params: %#v", m.UpdateServiceMock.defaultExpectation.expectationOrigins.origin, *m.UpdateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateService != nil && afterUpdateServiceCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateService at\n%s", m.funcUpdateServiceOrigin)
	}

	if !m.UpdateServiceMock.invocationsDone() && afterUpdateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateService at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServiceMock.expectedInvocations), m.UpdateServiceMock.expectedInvocationsOrigin, afterUpdateServiceCounter)
	}
}

type mClientMockUpdateServicePassword struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServicePasswordExpectation
	expectations       []*ClientMockUpdateServicePasswordExpectation

	callArgs []*ClientMockUpdateServicePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateServicePasswordExpectation specifies expectation struct of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateServicePasswordParams
	paramPtrs          *ClientMockUpdateServicePasswordParamPtrs
	expectationOrigins ClientMockUpdateServicePasswordExpectationOrigins
	results            *ClientMockUpdateServicePasswordResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateServicePasswordParams contains parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParams struct {
	ctx       context.Context
	serviceId string
	u         ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordParamPtrs contains pointers to parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	u         *ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordResults contains results of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordResults struct {
	sp1 *ServicePasswordUpdateResult
	err error
}

// ClientMockUpdateServicePasswordOrigins contains origins of expectations of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectationOrigins struct {
	origin          string
	originCtx       string
	originServiceId string
	originU         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Optional() *mClientMockUpdateServicePassword {
	mmUpdateServicePassword.optional = true
	return mmUpdateServicePassword
}

// Expect sets up expected params for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Expect(ctx context.Context, serviceId string, u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by ExpectParams functions")
	}

	mmUpdateServicePassword.defaultExpectation.params = &ClientMockUpdateServicePasswordParams{ctx, serviceId, u}
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateServicePassword.expectations {
		if minimock.Equal(e.params, mmUpdateServicePassword.defaultExpectation.params) {
			mmUpdateServicePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateServicePassword.defaultExpectation.params)
		}
	}

	return mmUpdateServicePassword
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateServicePassword
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmUpdateServicePassword
}

// ExpectUParam3 sets up expected param u for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectUParam3(u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.u = &u
	mmUpdateServicePassword.defaultExpectation.expectationOrigins.originU = minimock.CallerInfo(1)

	return mmUpdateServicePassword
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Inspect(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate)) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateServicePassword")
	}

	mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword = f

	return mmUpdateServicePassword
}

// Return sets up results that will be returned by Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Return(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{mock: mmUpdateServicePassword.mock}
	}
	mmUpdateServicePassword.defaultExpectation.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	mmUpdateServicePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateServicePassword.mock
}

// Set uses given function f to mock the Client.UpdateServicePassword method
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Set(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)) *ClientMock {
	if mmUpdateServicePassword.defaultExpectation != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Default expectation is already set for the Client.UpdateServicePassword method")
	}

	if len(mmUpdateServicePassword.expectations) > 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Some expectations are already set for the Client.UpdateServicePassword method")
	}

	mmUpdateServicePassword.mock.funcUpdateServicePassword = f
	mmUpdateServicePassword.mock.funcUpdateServicePasswordOrigin = minimock.CallerInfo(1)
	return mmUpdateServicePassword.mock
}

// When sets expectation for the Client.UpdateServicePassword which will trigger the result defined by the following
// Then helper
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) When(ctx context.Context, serviceId string, u ServicePasswordUpdate) *ClientMockUpdateServicePasswordExpectation {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	expectation := &ClientMockUpdateServicePasswordExpectation{
		mock:               mmUpdateServicePassword.mock,
		params:             &ClientMockUpdateServicePasswordParams{ctx, serviceId, u},
		expectationOrigins: ClientMockUpdateServicePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateServicePassword.expectations = append(mmUpdateServicePassword.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateServicePassword return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServicePasswordExpectation) Then(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	e.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateServicePassword should be invoked
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Times(n uint64) *mClientMockUpdateServicePassword {
	if n == 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Times of ClientMock.UpdateServicePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateServicePassword.expectedInvocations, n)
	mmUpdateServicePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateServicePassword
}

func (mmUpdateServicePassword *mClientMockUpdateServicePassword) invocationsDone() bool {
	if len(mmUpdateServicePassword.expectations) == 0 && mmUpdateServicePassword.defaultExpectation == nil && mmUpdateServicePassword.mock.funcUpdateServicePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.mock.afterUpdateServicePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateServicePassword implements Client
func (mmUpdateServicePassword *ClientMock) UpdateServicePassword(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error) {
	mm_atomic.AddUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter, 1)

	mmUpdateServicePassword.t.Helper()

	if mmUpdateServicePassword.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.inspectFuncUpdateServicePassword(ctx, serviceId, u)
	}

	mm_params := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

	// Record call args
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Lock()
	mmUpdateServicePassword.UpdateServicePasswordMock.callArgs = append(mmUpdateServicePassword.UpdateServicePasswordMock.callArgs, &mm_params)
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Unlock()

	for _, e := range mmUpdateServicePassword.UpdateServicePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.u != nil && !minimock.Equal(*mm_want_ptrs.u, mm_got.u) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter u, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.originU, *mm_want_ptrs.u, mm_got.u, minimock.Diff(*mm_want_ptrs.u, mm_got.u))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateServicePassword.t.Fatal("No results are set for the ClientMock.UpdateServicePassword")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateServicePassword.funcUpdateServicePassword != nil {
		return mmUpdateServicePassword.funcUpdateServicePassword(ctx, serviceId, u)
	}
	mmUpdateServicePassword.t.Fatalf("Unexpected call to ClientMock.UpdateServicePassword. %v %v %v", ctx, serviceId, u)
	return
}

// UpdateServicePasswordAfterCounter returns a count of finished ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter)
}

// UpdateServicePasswordBeforeCounter returns a count of ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateServicePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Calls() []*ClientMockUpdateServicePasswordParams {
	mmUpdateServicePassword.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServicePasswordParams, len(mmUpdateServicePassword.callArgs))
	copy(argCopy, mmUpdateServicePassword.callArgs)

	mmUpdateServicePassword.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServicePasswordDone returns true if the count of the UpdateServicePassword invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServicePasswordDone() bool {
	if m.UpdateServicePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServicePasswordMock.invocationsDone()
}

// MinimockUpdateServicePasswordInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServicePasswordInspect() {
	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateServicePasswordCounter := mm_atomic.LoadUint64(&m.afterUpdateServicePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServicePasswordMock.defaultExpectation != nil && afterUpdateServicePasswordCounter < 1 {
		if m.UpdateServicePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s", m.UpdateServicePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s with params: %#v", m.UpdateServicePasswordMock.defaultExpectation.expectationOrigins.origin, *m.UpdateServicePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateServicePassword != nil && afterUpdateServicePasswordCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateServicePassword at\n%s", m.funcUpdateServicePasswordOrigin)
	}

	if !m.UpdateServicePasswordMock.invocationsDone() && afterUpdateServicePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateServicePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServicePasswordMock.expectedInvocations), m.UpdateServicePasswordMock.expectedInvocationsOrigin, afterUpdateServicePasswordCounter)
	}
}

type mClientMockWaitForServiceState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForServiceStateExpectation
	expectations       []*ClientMockWaitForServiceStateExpectation

	callArgs []*ClientMockWaitForServiceStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockWaitForServiceStateExpectation specifies expectation struct of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectation struct {
	mock               *ClientMock
	params             *ClientMockWaitForServiceStateParams
	paramPtrs          *ClientMockWaitForServiceStateParamPtrs
	expectationOrigins ClientMockWaitForServiceStateExpectationOrigins
	results            *ClientMockWaitForServiceStateResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockWaitForServiceStateParams contains parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParams struct {
	ctx            context.Context
	serviceId      string
	stateChecker   func(string) bool
	maxWaitSeconds int
}

// ClientMockWaitForServiceStateParamPtrs contains pointers to parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	stateChecker   *func(string) bool
	maxWaitSeconds *int
}

// ClientMockWaitForServiceStateResults contains results of the Client.WaitForServiceState
type ClientMockWaitForServiceStateResults struct {
	err error
}

// ClientMockWaitForServiceStateOrigins contains origins of expectations of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectationOrigins struct {
	origin               string
	originCtx            string
	originServiceId      string
	originStateChecker   string
	originMaxWaitSeconds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForServiceState *mClientMockWaitForServiceState) Optional() *mClientMockWaitForServiceState {
	mmWaitForServiceState.optional = true
	return mmWaitForServiceState
}

// Expect sets up expected params for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Expect(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by ExpectParams functions")
	}

	mmWaitForServiceState.defaultExpectation.params = &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}
	mmWaitForServiceState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWaitForServiceState.expectations {
		if minimock.Equal(e.params, mmWaitForServiceState.defaultExpectation.params) {
			mmWaitForServiceState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForServiceState.defaultExpectation.params)
		}
	}

	return mmWaitForServiceState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.ctx = &ctx
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.serviceId = &serviceId
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originServiceId = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// ExpectStateCheckerParam3 sets up expected param stateChecker for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectStateCheckerParam3(stateChecker func(string) bool) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.stateChecker = &stateChecker
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originStateChecker = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// ExpectMaxWaitSecondsParam4 sets up expected param maxWaitSeconds for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectMaxWaitSecondsParam4(maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds
	mmWaitForServiceState.defaultExpectation.expectationOrigins.originMaxWaitSeconds = minimock.CallerInfo(1)

	return mmWaitForServiceState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Inspect(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForServiceState")
	}

	mmWaitForServiceState.mock.inspectFuncWaitForServiceState = f

	return mmWaitForServiceState
}

// Return sets up results that will be returned by Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Return(err error) *ClientMock {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{mock: mmWaitForServiceState.mock}
	}
	mmWaitForServiceState.defaultExpectation.results = &ClientMockWaitForServiceStateResults{err}
	mmWaitForServiceState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWaitForServiceState.mock
}

// Set uses given function f to mock the Client.WaitForServiceState method
func (mmWaitForServiceState *mClientMockWaitForServiceState) Set(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)) *ClientMock {
	if mmWaitForServiceState.defaultExpectation != nil {
		mmWaitForServiceState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForServiceState method")
	}

	if len(mmWaitForServiceState.expectations) > 0 {
		mmWaitForServiceState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForServiceState method")
	}

	mmWaitForServiceState.mock.funcWaitForServiceState = f
	mmWaitForServiceState.mock.funcWaitForServiceStateOrigin = minimock.CallerInfo(1)
	return mmWaitForServiceState.mock
}

// When sets expectation for the Client.WaitForServiceState which will trigger the result defined by the following
// Then helper
func (mmWaitForServiceState *mClientMockWaitForServiceState) When(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *ClientMockWaitForServiceStateExpectation {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	expectation := &ClientMockWaitForServiceStateExpectation{
		mock:               mmWaitForServiceState.mock,
		params:             &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds},
		expectationOrigins: ClientMockWaitForServiceStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWaitForServiceState.expectations = append(mmWaitForServiceState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForServiceState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForServiceStateExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockWaitForServiceStateResults{err}
	return e.mock
}

// Times sets number of times Client.WaitForServiceState should be invoked
func (mmWaitForServiceState *mClientMockWaitForServiceState) Times(n uint64) *mClientMockWaitForServiceState {
	if n == 0 {
		mmWaitForServiceState.mock.t.Fatalf("Times of ClientMock.WaitForServiceState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForServiceState.expectedInvocations, n)
	mmWaitForServiceState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWaitForServiceState
}

func (mmWaitForServiceState *mClientMockWaitForServiceState) invocationsDone() bool {
	if len(mmWaitForServiceState.expectations) == 0 && mmWaitForServiceState.defaultExpectation == nil && mmWaitForServiceState.mock.funcWaitForServiceState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.mock.afterWaitForServiceStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForServiceState implements Client
func (mmWaitForServiceState *ClientMock) WaitForServiceState(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error) {
	mm_atomic.AddUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter, 1)

	mmWaitForServiceState.t.Helper()

	if mmWaitForServiceState.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.inspectFuncWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Lock()
	mmWaitForServiceState.WaitForServiceStateMock.callArgs = append(mmWaitForServiceState.WaitForServiceStateMock.callArgs, &mm_params)
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Unlock()

	for _, e := range mmWaitForServiceState.WaitForServiceStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter serviceId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originServiceId, *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter stateChecker, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originStateChecker, *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter maxWaitSeconds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.originMaxWaitSeconds, *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForServiceState.t.Fatal("No results are set for the ClientMock.WaitForServiceState")
		}
		return (*mm_results).err
	}
	if mmWaitForServiceState.funcWaitForServiceState != nil {
		return mmWaitForServiceState.funcWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}
	mmWaitForServiceState.t.Fatalf("Unexpected call to ClientMock.WaitForServiceState. %v %v %v %v", ctx, serviceId, stateChecker, maxWaitSeconds)
	return
}

// WaitForServiceStateAfterCounter returns a count of finished ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter)
}

// WaitForServiceStateBeforeCounter returns a count of ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForServiceState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForServiceState *mClientMockWaitForServiceState) Calls() []*ClientMockWaitForServiceStateParams {
	mmWaitForServiceState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForServiceStateParams, len(mmWaitForServiceState.callArgs))
	copy(argCopy, mmWaitForServiceState.callArgs)

	mmWaitForServiceState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForServiceStateDone returns true if the count of the WaitForServiceState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForServiceStateDone() bool {
	if m.WaitForServiceStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForServiceStateMock.invocationsDone()
}

// MinimockWaitForServiceStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForServiceStateInspect() {
	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWaitForServiceStateCounter := mm_atomic.LoadUint64(&m.afterWaitForServiceStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForServiceStateMock.defaultExpectation != nil && afterWaitForServiceStateCounter < 1 {
		if m.WaitForServiceStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s", m.WaitForServiceStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s with params: %#v", m.WaitForServiceStateMock.defaultExpectation.expectationOrigins.origin, *m.WaitForServiceStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForServiceState != nil && afterWaitForServiceStateCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.WaitForServiceState at\n%s", m.funcWaitForServiceStateOrigin)
	}

	if !m.WaitForServiceStateMock.invocationsDone() && afterWaitForServiceStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForServiceState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForServiceStateMock.expectedInvocations), m.WaitForServiceStateMock.expectedInvocationsOrigin, afterWaitForServiceStateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateClickPipeInspect()

			m.MinimockCreateServiceInspect()

			m.MinimockDeleteClickPipeInspect()

			m.MinimockDeleteServiceInspect()

			m.MinimockGetBackupConfigurationInspect()

			m.MinimockGetClickPipeInspect()

			m.MinimockGetOrgPrivateEndpointConfigInspect()

			m.MinimockGetOrganizationPrivateEndpointsInspect()

			m.MinimockGetServiceInspect()

			m.MinimockPauseClickPipeInspect()

			m.MinimockResumeClickPipeInspect()

			m.MinimockScaleClickPipeInspect()

			m.MinimockUpdateBackupConfigurationInspect()

			m.MinimockUpdateOrganizationPrivateEndpointsInspect()

			m.MinimockUpdateReplicaScalingInspect()

			m.MinimockUpdateServiceInspect()

			m.MinimockUpdateServicePasswordInspect()

			m.MinimockWaitForServiceStateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateClickPipeDone() &&
		m.MinimockCreateServiceDone() &&
		m.MinimockDeleteClickPipeDone() &&
		m.MinimockDeleteServiceDone() &&
		m.MinimockGetBackupConfigurationDone() &&
		m.MinimockGetClickPipeDone() &&
		m.MinimockGetOrgPrivateEndpointConfigDone() &&
		m.MinimockGetOrganizationPrivateEndpointsDone() &&
		m.MinimockGetServiceDone() &&
		m.MinimockPauseClickPipeDone() &&
		m.MinimockResumeClickPipeDone() &&
		m.MinimockScaleClickPipeDone() &&
		m.MinimockUpdateBackupConfigurationDone() &&
		m.MinimockUpdateOrganizationPrivateEndpointsDone() &&
		m.MinimockUpdateReplicaScalingDone() &&
		m.MinimockUpdateServiceDone() &&
		m.MinimockUpdateServicePasswordDone() &&
		m.MinimockWaitForServiceStateDone()
}
