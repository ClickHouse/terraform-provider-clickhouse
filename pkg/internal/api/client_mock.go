// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package api

//go:generate minimock -i github.com/ClickHouse/terraform-provider-clickhouse/pkg/internal/api.Client -o client_mock.go -n ClientMock -p api

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangeClickPipeState          func(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error)
	inspectFuncChangeClickPipeState   func(ctx context.Context, serviceId string, clickPipeId string, command string)
	afterChangeClickPipeStateCounter  uint64
	beforeChangeClickPipeStateCounter uint64
	ChangeClickPipeStateMock          mClientMockChangeClickPipeState

	funcCreateClickPipe          func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)
	inspectFuncCreateClickPipe   func(ctx context.Context, serviceId string, clickPipe ClickPipe)
	afterCreateClickPipeCounter  uint64
	beforeCreateClickPipeCounter uint64
	CreateClickPipeMock          mClientMockCreateClickPipe

	funcCreateQueryEndpoint          func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error)
	inspectFuncCreateQueryEndpoint   func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint)
	afterCreateQueryEndpointCounter  uint64
	beforeCreateQueryEndpointCounter uint64
	CreateQueryEndpointMock          mClientMockCreateQueryEndpoint

	funcCreateService          func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)
	inspectFuncCreateService   func(ctx context.Context, s Service)
	afterCreateServiceCounter  uint64
	beforeCreateServiceCounter uint64
	CreateServiceMock          mClientMockCreateService

	funcCreateUser          func(ctx context.Context, serviceId string, user User) (up1 *User, err error)
	inspectFuncCreateUser   func(ctx context.Context, serviceId string, user User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mClientMockCreateUser

	funcDeleteClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (err error)
	inspectFuncDeleteClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterDeleteClickPipeCounter  uint64
	beforeDeleteClickPipeCounter uint64
	DeleteClickPipeMock          mClientMockDeleteClickPipe

	funcDeleteQueryEndpoint          func(ctx context.Context, serviceID string) (err error)
	inspectFuncDeleteQueryEndpoint   func(ctx context.Context, serviceID string)
	afterDeleteQueryEndpointCounter  uint64
	beforeDeleteQueryEndpointCounter uint64
	DeleteQueryEndpointMock          mClientMockDeleteQueryEndpoint

	funcDeleteService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	inspectFuncDeleteService   func(ctx context.Context, serviceId string)
	afterDeleteServiceCounter  uint64
	beforeDeleteServiceCounter uint64
	DeleteServiceMock          mClientMockDeleteService

	funcDeleteUser          func(ctx context.Context, serviceID string, name string) (err error)
	inspectFuncDeleteUser   func(ctx context.Context, serviceID string, name string)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mClientMockDeleteUser

	funcGetApiKeyID          func(ctx context.Context, name *string) (ap1 *ApiKey, err error)
	inspectFuncGetApiKeyID   func(ctx context.Context, name *string)
	afterGetApiKeyIDCounter  uint64
	beforeGetApiKeyIDCounter uint64
	GetApiKeyIDMock          mClientMockGetApiKeyID

	funcGetBackupConfiguration          func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)
	inspectFuncGetBackupConfiguration   func(ctx context.Context, serviceId string)
	afterGetBackupConfigurationCounter  uint64
	beforeGetBackupConfigurationCounter uint64
	GetBackupConfigurationMock          mClientMockGetBackupConfiguration

	funcGetClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)
	inspectFuncGetClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterGetClickPipeCounter  uint64
	beforeGetClickPipeCounter uint64
	GetClickPipeMock          mClientMockGetClickPipe

	funcGetOrgPrivateEndpointConfig          func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)
	inspectFuncGetOrgPrivateEndpointConfig   func(ctx context.Context, cloudProvider string, region string)
	afterGetOrgPrivateEndpointConfigCounter  uint64
	beforeGetOrgPrivateEndpointConfigCounter uint64
	GetOrgPrivateEndpointConfigMock          mClientMockGetOrgPrivateEndpointConfig

	funcGetOrganizationPrivateEndpoints          func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)
	inspectFuncGetOrganizationPrivateEndpoints   func(ctx context.Context)
	afterGetOrganizationPrivateEndpointsCounter  uint64
	beforeGetOrganizationPrivateEndpointsCounter uint64
	GetOrganizationPrivateEndpointsMock          mClientMockGetOrganizationPrivateEndpoints

	funcGetQueryEndpoint          func(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error)
	inspectFuncGetQueryEndpoint   func(ctx context.Context, serviceID string)
	afterGetQueryEndpointCounter  uint64
	beforeGetQueryEndpointCounter uint64
	GetQueryEndpointMock          mClientMockGetQueryEndpoint

	funcGetService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	inspectFuncGetService   func(ctx context.Context, serviceId string)
	afterGetServiceCounter  uint64
	beforeGetServiceCounter uint64
	GetServiceMock          mClientMockGetService

	funcGetUser          func(ctx context.Context, serviceID string, name string) (up1 *User, err error)
	inspectFuncGetUser   func(ctx context.Context, serviceID string, name string)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mClientMockGetUser

	funcScalingClickPipe          func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) (cp1 *ClickPipe, err error)
	inspectFuncScalingClickPipe   func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling)
	afterScalingClickPipeCounter  uint64
	beforeScalingClickPipeCounter uint64
	ScalingClickPipeMock          mClientMockScalingClickPipe

	funcUpdateBackupConfiguration          func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)
	inspectFuncUpdateBackupConfiguration   func(ctx context.Context, serviceId string, b BackupConfiguration)
	afterUpdateBackupConfigurationCounter  uint64
	beforeUpdateBackupConfigurationCounter uint64
	UpdateBackupConfigurationMock          mClientMockUpdateBackupConfiguration

	funcUpdateOrganizationPrivateEndpoints          func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)
	inspectFuncUpdateOrganizationPrivateEndpoints   func(ctx context.Context, orgUpdate OrganizationUpdate)
	afterUpdateOrganizationPrivateEndpointsCounter  uint64
	beforeUpdateOrganizationPrivateEndpointsCounter uint64
	UpdateOrganizationPrivateEndpointsMock          mClientMockUpdateOrganizationPrivateEndpoints

	funcUpdateReplicaScaling          func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)
	inspectFuncUpdateReplicaScaling   func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)
	afterUpdateReplicaScalingCounter  uint64
	beforeUpdateReplicaScalingCounter uint64
	UpdateReplicaScalingMock          mClientMockUpdateReplicaScaling

	funcUpdateService          func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)
	inspectFuncUpdateService   func(ctx context.Context, serviceId string, s ServiceUpdate)
	afterUpdateServiceCounter  uint64
	beforeUpdateServiceCounter uint64
	UpdateServiceMock          mClientMockUpdateService

	funcUpdateServicePassword          func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)
	inspectFuncUpdateServicePassword   func(ctx context.Context, serviceId string, u ServicePasswordUpdate)
	afterUpdateServicePasswordCounter  uint64
	beforeUpdateServicePasswordCounter uint64
	UpdateServicePasswordMock          mClientMockUpdateServicePassword

	funcWaitForClickPipeState          func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error)
	inspectFuncWaitForClickPipeState   func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64)
	afterWaitForClickPipeStateCounter  uint64
	beforeWaitForClickPipeStateCounter uint64
	WaitForClickPipeStateMock          mClientMockWaitForClickPipeState

	funcWaitForServiceState          func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)
	inspectFuncWaitForServiceState   func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)
	afterWaitForServiceStateCounter  uint64
	beforeWaitForServiceStateCounter uint64
	WaitForServiceStateMock          mClientMockWaitForServiceState
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangeClickPipeStateMock = mClientMockChangeClickPipeState{mock: m}
	m.ChangeClickPipeStateMock.callArgs = []*ClientMockChangeClickPipeStateParams{}

	m.CreateClickPipeMock = mClientMockCreateClickPipe{mock: m}
	m.CreateClickPipeMock.callArgs = []*ClientMockCreateClickPipeParams{}

	m.CreateQueryEndpointMock = mClientMockCreateQueryEndpoint{mock: m}
	m.CreateQueryEndpointMock.callArgs = []*ClientMockCreateQueryEndpointParams{}

	m.CreateServiceMock = mClientMockCreateService{mock: m}
	m.CreateServiceMock.callArgs = []*ClientMockCreateServiceParams{}

	m.CreateUserMock = mClientMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*ClientMockCreateUserParams{}

	m.DeleteClickPipeMock = mClientMockDeleteClickPipe{mock: m}
	m.DeleteClickPipeMock.callArgs = []*ClientMockDeleteClickPipeParams{}

	m.DeleteQueryEndpointMock = mClientMockDeleteQueryEndpoint{mock: m}
	m.DeleteQueryEndpointMock.callArgs = []*ClientMockDeleteQueryEndpointParams{}

	m.DeleteServiceMock = mClientMockDeleteService{mock: m}
	m.DeleteServiceMock.callArgs = []*ClientMockDeleteServiceParams{}

	m.DeleteUserMock = mClientMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*ClientMockDeleteUserParams{}

	m.GetApiKeyIDMock = mClientMockGetApiKeyID{mock: m}
	m.GetApiKeyIDMock.callArgs = []*ClientMockGetApiKeyIDParams{}

	m.GetBackupConfigurationMock = mClientMockGetBackupConfiguration{mock: m}
	m.GetBackupConfigurationMock.callArgs = []*ClientMockGetBackupConfigurationParams{}

	m.GetClickPipeMock = mClientMockGetClickPipe{mock: m}
	m.GetClickPipeMock.callArgs = []*ClientMockGetClickPipeParams{}

	m.GetOrgPrivateEndpointConfigMock = mClientMockGetOrgPrivateEndpointConfig{mock: m}
	m.GetOrgPrivateEndpointConfigMock.callArgs = []*ClientMockGetOrgPrivateEndpointConfigParams{}

	m.GetOrganizationPrivateEndpointsMock = mClientMockGetOrganizationPrivateEndpoints{mock: m}
	m.GetOrganizationPrivateEndpointsMock.callArgs = []*ClientMockGetOrganizationPrivateEndpointsParams{}

	m.GetQueryEndpointMock = mClientMockGetQueryEndpoint{mock: m}
	m.GetQueryEndpointMock.callArgs = []*ClientMockGetQueryEndpointParams{}

	m.GetServiceMock = mClientMockGetService{mock: m}
	m.GetServiceMock.callArgs = []*ClientMockGetServiceParams{}

	m.GetUserMock = mClientMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*ClientMockGetUserParams{}

	m.ScalingClickPipeMock = mClientMockScalingClickPipe{mock: m}
	m.ScalingClickPipeMock.callArgs = []*ClientMockScalingClickPipeParams{}

	m.UpdateBackupConfigurationMock = mClientMockUpdateBackupConfiguration{mock: m}
	m.UpdateBackupConfigurationMock.callArgs = []*ClientMockUpdateBackupConfigurationParams{}

	m.UpdateOrganizationPrivateEndpointsMock = mClientMockUpdateOrganizationPrivateEndpoints{mock: m}
	m.UpdateOrganizationPrivateEndpointsMock.callArgs = []*ClientMockUpdateOrganizationPrivateEndpointsParams{}

	m.UpdateReplicaScalingMock = mClientMockUpdateReplicaScaling{mock: m}
	m.UpdateReplicaScalingMock.callArgs = []*ClientMockUpdateReplicaScalingParams{}

	m.UpdateServiceMock = mClientMockUpdateService{mock: m}
	m.UpdateServiceMock.callArgs = []*ClientMockUpdateServiceParams{}

	m.UpdateServicePasswordMock = mClientMockUpdateServicePassword{mock: m}
	m.UpdateServicePasswordMock.callArgs = []*ClientMockUpdateServicePasswordParams{}

	m.WaitForClickPipeStateMock = mClientMockWaitForClickPipeState{mock: m}
	m.WaitForClickPipeStateMock.callArgs = []*ClientMockWaitForClickPipeStateParams{}

	m.WaitForServiceStateMock = mClientMockWaitForServiceState{mock: m}
	m.WaitForServiceStateMock.callArgs = []*ClientMockWaitForServiceStateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockChangeClickPipeState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockChangeClickPipeStateExpectation
	expectations       []*ClientMockChangeClickPipeStateExpectation

	callArgs []*ClientMockChangeClickPipeStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockChangeClickPipeStateExpectation specifies expectation struct of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockChangeClickPipeStateParams
	paramPtrs *ClientMockChangeClickPipeStateParamPtrs
	results   *ClientMockChangeClickPipeStateResults
	Counter   uint64
}

// ClientMockChangeClickPipeStateParams contains parameters of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	command     string
}

// ClientMockChangeClickPipeStateParamPtrs contains pointers to parameters of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	command     *string
}

// ClientMockChangeClickPipeStateResults contains results of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Optional() *mClientMockChangeClickPipeState {
	mmChangeClickPipeState.optional = true
	return mmChangeClickPipeState
}

// Expect sets up expected params for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Expect(ctx context.Context, serviceId string, clickPipeId string, command string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by ExpectParams functions")
	}

	mmChangeClickPipeState.defaultExpectation.params = &ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}
	for _, e := range mmChangeClickPipeState.expectations {
		if minimock.Equal(e.params, mmChangeClickPipeState.defaultExpectation.params) {
			mmChangeClickPipeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeClickPipeState.defaultExpectation.params)
		}
	}

	return mmChangeClickPipeState
}

// ExpectCtxParam1 sets up expected param ctx for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectCtxParam1(ctx context.Context) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmChangeClickPipeState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectServiceIdParam2(serviceId string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmChangeClickPipeState
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmChangeClickPipeState
}

// ExpectCommandParam4 sets up expected param command for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectCommandParam4(command string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.command = &command

	return mmChangeClickPipeState
}

// Inspect accepts an inspector function that has same arguments as the Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, command string)) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.inspectFuncChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("Inspect function is already set for ClientMock.ChangeClickPipeState")
	}

	mmChangeClickPipeState.mock.inspectFuncChangeClickPipeState = f

	return mmChangeClickPipeState
}

// Return sets up results that will be returned by Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{mock: mmChangeClickPipeState.mock}
	}
	mmChangeClickPipeState.defaultExpectation.results = &ClientMockChangeClickPipeStateResults{cp1, err}
	return mmChangeClickPipeState.mock
}

// Set uses given function f to mock the Client.ChangeClickPipeState method
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Set(f func(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmChangeClickPipeState.defaultExpectation != nil {
		mmChangeClickPipeState.mock.t.Fatalf("Default expectation is already set for the Client.ChangeClickPipeState method")
	}

	if len(mmChangeClickPipeState.expectations) > 0 {
		mmChangeClickPipeState.mock.t.Fatalf("Some expectations are already set for the Client.ChangeClickPipeState method")
	}

	mmChangeClickPipeState.mock.funcChangeClickPipeState = f
	return mmChangeClickPipeState.mock
}

// When sets expectation for the Client.ChangeClickPipeState which will trigger the result defined by the following
// Then helper
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) When(ctx context.Context, serviceId string, clickPipeId string, command string) *ClientMockChangeClickPipeStateExpectation {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockChangeClickPipeStateExpectation{
		mock:   mmChangeClickPipeState.mock,
		params: &ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command},
	}
	mmChangeClickPipeState.expectations = append(mmChangeClickPipeState.expectations, expectation)
	return expectation
}

// Then sets up Client.ChangeClickPipeState return parameters for the expectation previously defined by the When method
func (e *ClientMockChangeClickPipeStateExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockChangeClickPipeStateResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ChangeClickPipeState should be invoked
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Times(n uint64) *mClientMockChangeClickPipeState {
	if n == 0 {
		mmChangeClickPipeState.mock.t.Fatalf("Times of ClientMock.ChangeClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangeClickPipeState.expectedInvocations, n)
	return mmChangeClickPipeState
}

func (mmChangeClickPipeState *mClientMockChangeClickPipeState) invocationsDone() bool {
	if len(mmChangeClickPipeState.expectations) == 0 && mmChangeClickPipeState.defaultExpectation == nil && mmChangeClickPipeState.mock.funcChangeClickPipeState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangeClickPipeState.mock.afterChangeClickPipeStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangeClickPipeState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangeClickPipeState implements Client
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeState(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmChangeClickPipeState.beforeChangeClickPipeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeClickPipeState.afterChangeClickPipeStateCounter, 1)

	if mmChangeClickPipeState.inspectFuncChangeClickPipeState != nil {
		mmChangeClickPipeState.inspectFuncChangeClickPipeState(ctx, serviceId, clickPipeId, command)
	}

	mm_params := ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}

	// Record call args
	mmChangeClickPipeState.ChangeClickPipeStateMock.mutex.Lock()
	mmChangeClickPipeState.ChangeClickPipeStateMock.callArgs = append(mmChangeClickPipeState.ChangeClickPipeStateMock.callArgs, &mm_params)
	mmChangeClickPipeState.ChangeClickPipeStateMock.mutex.Unlock()

	for _, e := range mmChangeClickPipeState.ChangeClickPipeStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.params
		mm_want_ptrs := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.command != nil && !minimock.Equal(*mm_want_ptrs.command, mm_got.command) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter command, want: %#v, got: %#v%s\n", *mm_want_ptrs.command, mm_got.command, minimock.Diff(*mm_want_ptrs.command, mm_got.command))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeClickPipeState.t.Fatal("No results are set for the ClientMock.ChangeClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChangeClickPipeState.funcChangeClickPipeState != nil {
		return mmChangeClickPipeState.funcChangeClickPipeState(ctx, serviceId, clickPipeId, command)
	}
	mmChangeClickPipeState.t.Fatalf("Unexpected call to ClientMock.ChangeClickPipeState. %v %v %v %v", ctx, serviceId, clickPipeId, command)
	return
}

// ChangeClickPipeStateAfterCounter returns a count of finished ClientMock.ChangeClickPipeState invocations
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeClickPipeState.afterChangeClickPipeStateCounter)
}

// ChangeClickPipeStateBeforeCounter returns a count of ClientMock.ChangeClickPipeState invocations
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeClickPipeState.beforeChangeClickPipeStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ChangeClickPipeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Calls() []*ClientMockChangeClickPipeStateParams {
	mmChangeClickPipeState.mutex.RLock()

	argCopy := make([]*ClientMockChangeClickPipeStateParams, len(mmChangeClickPipeState.callArgs))
	copy(argCopy, mmChangeClickPipeState.callArgs)

	mmChangeClickPipeState.mutex.RUnlock()

	return argCopy
}

// MinimockChangeClickPipeStateDone returns true if the count of the ChangeClickPipeState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockChangeClickPipeStateDone() bool {
	if m.ChangeClickPipeStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangeClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangeClickPipeStateMock.invocationsDone()
}

// MinimockChangeClickPipeStateInspect logs each unmet expectation
func (m *ClientMock) MinimockChangeClickPipeStateInspect() {
	for _, e := range m.ChangeClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState with params: %#v", *e.params)
		}
	}

	afterChangeClickPipeStateCounter := mm_atomic.LoadUint64(&m.afterChangeClickPipeStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeClickPipeStateMock.defaultExpectation != nil && afterChangeClickPipeStateCounter < 1 {
		if m.ChangeClickPipeStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ChangeClickPipeState")
		} else {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState with params: %#v", *m.ChangeClickPipeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeClickPipeState != nil && afterChangeClickPipeStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.ChangeClickPipeState")
	}

	if !m.ChangeClickPipeStateMock.invocationsDone() && afterChangeClickPipeStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ChangeClickPipeState but found %d calls",
			mm_atomic.LoadUint64(&m.ChangeClickPipeStateMock.expectedInvocations), afterChangeClickPipeStateCounter)
	}
}

type mClientMockCreateClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateClickPipeExpectation
	expectations       []*ClientMockCreateClickPipeExpectation

	callArgs []*ClientMockCreateClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateClickPipeExpectation specifies expectation struct of the Client.CreateClickPipe
type ClientMockCreateClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateClickPipeParams
	paramPtrs *ClientMockCreateClickPipeParamPtrs
	results   *ClientMockCreateClickPipeResults
	Counter   uint64
}

// ClientMockCreateClickPipeParams contains parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParams struct {
	ctx       context.Context
	serviceId string
	clickPipe ClickPipe
}

// ClientMockCreateClickPipeParamPtrs contains pointers to parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	clickPipe *ClickPipe
}

// ClientMockCreateClickPipeResults contains results of the Client.CreateClickPipe
type ClientMockCreateClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateClickPipe *mClientMockCreateClickPipe) Optional() *mClientMockCreateClickPipe {
	mmCreateClickPipe.optional = true
	return mmCreateClickPipe
}

// Expect sets up expected params for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Expect(ctx context.Context, serviceId string, clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by ExpectParams functions")
	}

	mmCreateClickPipe.defaultExpectation.params = &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}
	for _, e := range mmCreateClickPipe.expectations {
		if minimock.Equal(e.params, mmCreateClickPipe.defaultExpectation.params) {
			mmCreateClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClickPipe.defaultExpectation.params)
		}
	}

	return mmCreateClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmCreateClickPipe
}

// ExpectClickPipeParam3 sets up expected param clickPipe for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectClickPipeParam3(clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.clickPipe = &clickPipe

	return mmCreateClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipe ClickPipe)) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateClickPipe")
	}

	mmCreateClickPipe.mock.inspectFuncCreateClickPipe = f

	return mmCreateClickPipe
}

// Return sets up results that will be returned by Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{mock: mmCreateClickPipe.mock}
	}
	mmCreateClickPipe.defaultExpectation.results = &ClientMockCreateClickPipeResults{cp1, err}
	return mmCreateClickPipe.mock
}

// Set uses given function f to mock the Client.CreateClickPipe method
func (mmCreateClickPipe *mClientMockCreateClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmCreateClickPipe.defaultExpectation != nil {
		mmCreateClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.CreateClickPipe method")
	}

	if len(mmCreateClickPipe.expectations) > 0 {
		mmCreateClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.CreateClickPipe method")
	}

	mmCreateClickPipe.mock.funcCreateClickPipe = f
	return mmCreateClickPipe.mock
}

// When sets expectation for the Client.CreateClickPipe which will trigger the result defined by the following
// Then helper
func (mmCreateClickPipe *mClientMockCreateClickPipe) When(ctx context.Context, serviceId string, clickPipe ClickPipe) *ClientMockCreateClickPipeExpectation {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	expectation := &ClientMockCreateClickPipeExpectation{
		mock:   mmCreateClickPipe.mock,
		params: &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe},
	}
	mmCreateClickPipe.expectations = append(mmCreateClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockCreateClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.CreateClickPipe should be invoked
func (mmCreateClickPipe *mClientMockCreateClickPipe) Times(n uint64) *mClientMockCreateClickPipe {
	if n == 0 {
		mmCreateClickPipe.mock.t.Fatalf("Times of ClientMock.CreateClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateClickPipe.expectedInvocations, n)
	return mmCreateClickPipe
}

func (mmCreateClickPipe *mClientMockCreateClickPipe) invocationsDone() bool {
	if len(mmCreateClickPipe.expectations) == 0 && mmCreateClickPipe.defaultExpectation == nil && mmCreateClickPipe.mock.funcCreateClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.mock.afterCreateClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateClickPipe implements Client
func (mmCreateClickPipe *ClientMock) CreateClickPipe(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClickPipe.afterCreateClickPipeCounter, 1)

	if mmCreateClickPipe.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.inspectFuncCreateClickPipe(ctx, serviceId, clickPipe)
	}

	mm_params := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

	// Record call args
	mmCreateClickPipe.CreateClickPipeMock.mutex.Lock()
	mmCreateClickPipe.CreateClickPipeMock.callArgs = append(mmCreateClickPipe.CreateClickPipeMock.callArgs, &mm_params)
	mmCreateClickPipe.CreateClickPipeMock.mutex.Unlock()

	for _, e := range mmCreateClickPipe.CreateClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateClickPipe.CreateClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipe != nil && !minimock.Equal(*mm_want_ptrs.clickPipe, mm_got.clickPipe) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter clickPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipe, mm_got.clickPipe, minimock.Diff(*mm_want_ptrs.clickPipe, mm_got.clickPipe))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClickPipe.t.Fatal("No results are set for the ClientMock.CreateClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateClickPipe.funcCreateClickPipe != nil {
		return mmCreateClickPipe.funcCreateClickPipe(ctx, serviceId, clickPipe)
	}
	mmCreateClickPipe.t.Fatalf("Unexpected call to ClientMock.CreateClickPipe. %v %v %v", ctx, serviceId, clickPipe)
	return
}

// CreateClickPipeAfterCounter returns a count of finished ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.afterCreateClickPipeCounter)
}

// CreateClickPipeBeforeCounter returns a count of ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClickPipe *mClientMockCreateClickPipe) Calls() []*ClientMockCreateClickPipeParams {
	mmCreateClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockCreateClickPipeParams, len(mmCreateClickPipe.callArgs))
	copy(argCopy, mmCreateClickPipe.callArgs)

	mmCreateClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClickPipeDone returns true if the count of the CreateClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateClickPipeDone() bool {
	if m.CreateClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateClickPipeMock.invocationsDone()
}

// MinimockCreateClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateClickPipeInspect() {
	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe with params: %#v", *e.params)
		}
	}

	afterCreateClickPipeCounter := mm_atomic.LoadUint64(&m.afterCreateClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClickPipeMock.defaultExpectation != nil && afterCreateClickPipeCounter < 1 {
		if m.CreateClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe with params: %#v", *m.CreateClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClickPipe != nil && afterCreateClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateClickPipe")
	}

	if !m.CreateClickPipeMock.invocationsDone() && afterCreateClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.CreateClickPipeMock.expectedInvocations), afterCreateClickPipeCounter)
	}
}

type mClientMockCreateQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateQueryEndpointExpectation
	expectations       []*ClientMockCreateQueryEndpointExpectation

	callArgs []*ClientMockCreateQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateQueryEndpointExpectation specifies expectation struct of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateQueryEndpointParams
	paramPtrs *ClientMockCreateQueryEndpointParamPtrs
	results   *ClientMockCreateQueryEndpointResults
	Counter   uint64
}

// ClientMockCreateQueryEndpointParams contains parameters of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
	endpoint  ServiceQueryEndpoint
}

// ClientMockCreateQueryEndpointParamPtrs contains pointers to parameters of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	endpoint  *ServiceQueryEndpoint
}

// ClientMockCreateQueryEndpointResults contains results of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointResults struct {
	sp1 *ServiceQueryEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Optional() *mClientMockCreateQueryEndpoint {
	mmCreateQueryEndpoint.optional = true
	return mmCreateQueryEndpoint
}

// Expect sets up expected params for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Expect(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmCreateQueryEndpoint.defaultExpectation.params = &ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}
	for _, e := range mmCreateQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmCreateQueryEndpoint.defaultExpectation.params) {
			mmCreateQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmCreateQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmCreateQueryEndpoint
}

// ExpectEndpointParam3 sets up expected param endpoint for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectEndpointParam3(endpoint ServiceQueryEndpoint) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.endpoint = &endpoint

	return mmCreateQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint)) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.inspectFuncCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateQueryEndpoint")
	}

	mmCreateQueryEndpoint.mock.inspectFuncCreateQueryEndpoint = f

	return mmCreateQueryEndpoint
}

// Return sets up results that will be returned by Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Return(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{mock: mmCreateQueryEndpoint.mock}
	}
	mmCreateQueryEndpoint.defaultExpectation.results = &ClientMockCreateQueryEndpointResults{sp1, err}
	return mmCreateQueryEndpoint.mock
}

// Set uses given function f to mock the Client.CreateQueryEndpoint method
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Set(f func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error)) *ClientMock {
	if mmCreateQueryEndpoint.defaultExpectation != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.CreateQueryEndpoint method")
	}

	if len(mmCreateQueryEndpoint.expectations) > 0 {
		mmCreateQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.CreateQueryEndpoint method")
	}

	mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint = f
	return mmCreateQueryEndpoint.mock
}

// When sets expectation for the Client.CreateQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) When(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) *ClientMockCreateQueryEndpointExpectation {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockCreateQueryEndpointExpectation{
		mock:   mmCreateQueryEndpoint.mock,
		params: &ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint},
	}
	mmCreateQueryEndpoint.expectations = append(mmCreateQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateQueryEndpointExpectation) Then(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	e.results = &ClientMockCreateQueryEndpointResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.CreateQueryEndpoint should be invoked
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Times(n uint64) *mClientMockCreateQueryEndpoint {
	if n == 0 {
		mmCreateQueryEndpoint.mock.t.Fatalf("Times of ClientMock.CreateQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateQueryEndpoint.expectedInvocations, n)
	return mmCreateQueryEndpoint
}

func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) invocationsDone() bool {
	if len(mmCreateQueryEndpoint.expectations) == 0 && mmCreateQueryEndpoint.defaultExpectation == nil && mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateQueryEndpoint.mock.afterCreateQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateQueryEndpoint implements Client
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpoint(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error) {
	mm_atomic.AddUint64(&mmCreateQueryEndpoint.beforeCreateQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateQueryEndpoint.afterCreateQueryEndpointCounter, 1)

	if mmCreateQueryEndpoint.inspectFuncCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.inspectFuncCreateQueryEndpoint(ctx, serviceID, endpoint)
	}

	mm_params := ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}

	// Record call args
	mmCreateQueryEndpoint.CreateQueryEndpointMock.mutex.Lock()
	mmCreateQueryEndpoint.CreateQueryEndpointMock.callArgs = append(mmCreateQueryEndpoint.CreateQueryEndpointMock.callArgs, &mm_params)
	mmCreateQueryEndpoint.CreateQueryEndpointMock.mutex.Unlock()

	for _, e := range mmCreateQueryEndpoint.CreateQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.endpoint != nil && !minimock.Equal(*mm_want_ptrs.endpoint, mm_got.endpoint) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter endpoint, want: %#v, got: %#v%s\n", *mm_want_ptrs.endpoint, mm_got.endpoint, minimock.Diff(*mm_want_ptrs.endpoint, mm_got.endpoint))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateQueryEndpoint.t.Fatal("No results are set for the ClientMock.CreateQueryEndpoint")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmCreateQueryEndpoint.funcCreateQueryEndpoint != nil {
		return mmCreateQueryEndpoint.funcCreateQueryEndpoint(ctx, serviceID, endpoint)
	}
	mmCreateQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.CreateQueryEndpoint. %v %v %v", ctx, serviceID, endpoint)
	return
}

// CreateQueryEndpointAfterCounter returns a count of finished ClientMock.CreateQueryEndpoint invocations
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateQueryEndpoint.afterCreateQueryEndpointCounter)
}

// CreateQueryEndpointBeforeCounter returns a count of ClientMock.CreateQueryEndpoint invocations
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateQueryEndpoint.beforeCreateQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Calls() []*ClientMockCreateQueryEndpointParams {
	mmCreateQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockCreateQueryEndpointParams, len(mmCreateQueryEndpoint.callArgs))
	copy(argCopy, mmCreateQueryEndpoint.callArgs)

	mmCreateQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockCreateQueryEndpointDone returns true if the count of the CreateQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateQueryEndpointDone() bool {
	if m.CreateQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateQueryEndpointMock.invocationsDone()
}

// MinimockCreateQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateQueryEndpointInspect() {
	for _, e := range m.CreateQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint with params: %#v", *e.params)
		}
	}

	afterCreateQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterCreateQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateQueryEndpointMock.defaultExpectation != nil && afterCreateQueryEndpointCounter < 1 {
		if m.CreateQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateQueryEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint with params: %#v", *m.CreateQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateQueryEndpoint != nil && afterCreateQueryEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateQueryEndpoint")
	}

	if !m.CreateQueryEndpointMock.invocationsDone() && afterCreateQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateQueryEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.CreateQueryEndpointMock.expectedInvocations), afterCreateQueryEndpointCounter)
	}
}

type mClientMockCreateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateServiceExpectation
	expectations       []*ClientMockCreateServiceExpectation

	callArgs []*ClientMockCreateServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateServiceExpectation specifies expectation struct of the Client.CreateService
type ClientMockCreateServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateServiceParams
	paramPtrs *ClientMockCreateServiceParamPtrs
	results   *ClientMockCreateServiceResults
	Counter   uint64
}

// ClientMockCreateServiceParams contains parameters of the Client.CreateService
type ClientMockCreateServiceParams struct {
	ctx context.Context
	s   Service
}

// ClientMockCreateServiceParamPtrs contains pointers to parameters of the Client.CreateService
type ClientMockCreateServiceParamPtrs struct {
	ctx *context.Context
	s   *Service
}

// ClientMockCreateServiceResults contains results of the Client.CreateService
type ClientMockCreateServiceResults struct {
	sp1 *Service
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateService *mClientMockCreateService) Optional() *mClientMockCreateService {
	mmCreateService.optional = true
	return mmCreateService
}

// Expect sets up expected params for Client.CreateService
func (mmCreateService *mClientMockCreateService) Expect(ctx context.Context, s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.paramPtrs != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by ExpectParams functions")
	}

	mmCreateService.defaultExpectation.params = &ClientMockCreateServiceParams{ctx, s}
	for _, e := range mmCreateService.expectations {
		if minimock.Equal(e.params, mmCreateService.defaultExpectation.params) {
			mmCreateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateService.defaultExpectation.params)
		}
	}

	return mmCreateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectCtxParam1(ctx context.Context) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateService
}

// ExpectSParam2 sets up expected param s for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectSParam2(s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.s = &s

	return mmCreateService
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateService
func (mmCreateService *mClientMockCreateService) Inspect(f func(ctx context.Context, s Service)) *mClientMockCreateService {
	if mmCreateService.mock.inspectFuncCreateService != nil {
		mmCreateService.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateService")
	}

	mmCreateService.mock.inspectFuncCreateService = f

	return mmCreateService
}

// Return sets up results that will be returned by Client.CreateService
func (mmCreateService *mClientMockCreateService) Return(sp1 *Service, s1 string, err error) *ClientMock {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{mock: mmCreateService.mock}
	}
	mmCreateService.defaultExpectation.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return mmCreateService.mock
}

// Set uses given function f to mock the Client.CreateService method
func (mmCreateService *mClientMockCreateService) Set(f func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)) *ClientMock {
	if mmCreateService.defaultExpectation != nil {
		mmCreateService.mock.t.Fatalf("Default expectation is already set for the Client.CreateService method")
	}

	if len(mmCreateService.expectations) > 0 {
		mmCreateService.mock.t.Fatalf("Some expectations are already set for the Client.CreateService method")
	}

	mmCreateService.mock.funcCreateService = f
	return mmCreateService.mock
}

// When sets expectation for the Client.CreateService which will trigger the result defined by the following
// Then helper
func (mmCreateService *mClientMockCreateService) When(ctx context.Context, s Service) *ClientMockCreateServiceExpectation {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	expectation := &ClientMockCreateServiceExpectation{
		mock:   mmCreateService.mock,
		params: &ClientMockCreateServiceParams{ctx, s},
	}
	mmCreateService.expectations = append(mmCreateService.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateService return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateServiceExpectation) Then(sp1 *Service, s1 string, err error) *ClientMock {
	e.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return e.mock
}

// Times sets number of times Client.CreateService should be invoked
func (mmCreateService *mClientMockCreateService) Times(n uint64) *mClientMockCreateService {
	if n == 0 {
		mmCreateService.mock.t.Fatalf("Times of ClientMock.CreateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateService.expectedInvocations, n)
	return mmCreateService
}

func (mmCreateService *mClientMockCreateService) invocationsDone() bool {
	if len(mmCreateService.expectations) == 0 && mmCreateService.defaultExpectation == nil && mmCreateService.mock.funcCreateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateService.mock.afterCreateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateService implements Client
func (mmCreateService *ClientMock) CreateService(ctx context.Context, s Service) (sp1 *Service, s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateService.beforeCreateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateService.afterCreateServiceCounter, 1)

	if mmCreateService.inspectFuncCreateService != nil {
		mmCreateService.inspectFuncCreateService(ctx, s)
	}

	mm_params := ClientMockCreateServiceParams{ctx, s}

	// Record call args
	mmCreateService.CreateServiceMock.mutex.Lock()
	mmCreateService.CreateServiceMock.callArgs = append(mmCreateService.CreateServiceMock.callArgs, &mm_params)
	mmCreateService.CreateServiceMock.mutex.Unlock()

	for _, e := range mmCreateService.CreateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.err
		}
	}

	if mmCreateService.CreateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateService.CreateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateService.CreateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmCreateService.CreateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateServiceParams{ctx, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateService.CreateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateService.t.Fatal("No results are set for the ClientMock.CreateService")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).err
	}
	if mmCreateService.funcCreateService != nil {
		return mmCreateService.funcCreateService(ctx, s)
	}
	mmCreateService.t.Fatalf("Unexpected call to ClientMock.CreateService. %v %v", ctx, s)
	return
}

// CreateServiceAfterCounter returns a count of finished ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.afterCreateServiceCounter)
}

// CreateServiceBeforeCounter returns a count of ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.beforeCreateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateService *mClientMockCreateService) Calls() []*ClientMockCreateServiceParams {
	mmCreateService.mutex.RLock()

	argCopy := make([]*ClientMockCreateServiceParams, len(mmCreateService.callArgs))
	copy(argCopy, mmCreateService.callArgs)

	mmCreateService.mutex.RUnlock()

	return argCopy
}

// MinimockCreateServiceDone returns true if the count of the CreateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateServiceDone() bool {
	if m.CreateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateServiceMock.invocationsDone()
}

// MinimockCreateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateServiceInspect() {
	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateService with params: %#v", *e.params)
		}
	}

	afterCreateServiceCounter := mm_atomic.LoadUint64(&m.afterCreateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceMock.defaultExpectation != nil && afterCreateServiceCounter < 1 {
		if m.CreateServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateService")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateService with params: %#v", *m.CreateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateService != nil && afterCreateServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateService")
	}

	if !m.CreateServiceMock.invocationsDone() && afterCreateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateService but found %d calls",
			mm_atomic.LoadUint64(&m.CreateServiceMock.expectedInvocations), afterCreateServiceCounter)
	}
}

type mClientMockCreateUser struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateUserExpectation
	expectations       []*ClientMockCreateUserExpectation

	callArgs []*ClientMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateUserExpectation specifies expectation struct of the Client.CreateUser
type ClientMockCreateUserExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateUserParams
	paramPtrs *ClientMockCreateUserParamPtrs
	results   *ClientMockCreateUserResults
	Counter   uint64
}

// ClientMockCreateUserParams contains parameters of the Client.CreateUser
type ClientMockCreateUserParams struct {
	ctx       context.Context
	serviceId string
	user      User
}

// ClientMockCreateUserParamPtrs contains pointers to parameters of the Client.CreateUser
type ClientMockCreateUserParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	user      *User
}

// ClientMockCreateUserResults contains results of the Client.CreateUser
type ClientMockCreateUserResults struct {
	up1 *User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mClientMockCreateUser) Optional() *mClientMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) Expect(ctx context.Context, serviceId string, user User) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &ClientMockCreateUserParams{ctx, serviceId, user}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) ExpectCtxParam1(ctx context.Context) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ClientMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateUser
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) ExpectServiceIdParam2(serviceId string) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ClientMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmCreateUser
}

// ExpectUserParam3 sets up expected param user for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) ExpectUserParam3(user User) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ClientMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) Inspect(f func(ctx context.Context, serviceId string, user User)) *mClientMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) Return(up1 *User, err error) *ClientMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &ClientMockCreateUserResults{up1, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the Client.CreateUser method
func (mmCreateUser *mClientMockCreateUser) Set(f func(ctx context.Context, serviceId string, user User) (up1 *User, err error)) *ClientMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Client.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Client.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Client.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mClientMockCreateUser) When(ctx context.Context, serviceId string, user User) *ClientMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	expectation := &ClientMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &ClientMockCreateUserParams{ctx, serviceId, user},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateUser return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateUserExpectation) Then(up1 *User, err error) *ClientMock {
	e.results = &ClientMockCreateUserResults{up1, err}
	return e.mock
}

// Times sets number of times Client.CreateUser should be invoked
func (mmCreateUser *mClientMockCreateUser) Times(n uint64) *mClientMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of ClientMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	return mmCreateUser
}

func (mmCreateUser *mClientMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements Client
func (mmCreateUser *ClientMock) CreateUser(ctx context.Context, serviceId string, user User) (up1 *User, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, serviceId, user)
	}

	mm_params := ClientMockCreateUserParams{ctx, serviceId, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateUserParams{ctx, serviceId, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the ClientMock.CreateUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, serviceId, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to ClientMock.CreateUser. %v %v %v", ctx, serviceId, user)
	return
}

// CreateUserAfterCounter returns a count of finished ClientMock.CreateUser invocations
func (mmCreateUser *ClientMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of ClientMock.CreateUser invocations
func (mmCreateUser *ClientMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mClientMockCreateUser) Calls() []*ClientMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*ClientMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateUser with params: %#v", *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateUser")
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
	}
}

type mClientMockDeleteClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteClickPipeExpectation
	expectations       []*ClientMockDeleteClickPipeExpectation

	callArgs []*ClientMockDeleteClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteClickPipeExpectation specifies expectation struct of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteClickPipeParams
	paramPtrs *ClientMockDeleteClickPipeParamPtrs
	results   *ClientMockDeleteClickPipeResults
	Counter   uint64
}

// ClientMockDeleteClickPipeParams contains parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockDeleteClickPipeParamPtrs contains pointers to parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockDeleteClickPipeResults contains results of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Optional() *mClientMockDeleteClickPipe {
	mmDeleteClickPipe.optional = true
	return mmDeleteClickPipe
}

// Expect sets up expected params for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by ExpectParams functions")
	}

	mmDeleteClickPipe.defaultExpectation.params = &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}
	for _, e := range mmDeleteClickPipe.expectations {
		if minimock.Equal(e.params, mmDeleteClickPipe.defaultExpectation.params) {
			mmDeleteClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteClickPipe.defaultExpectation.params)
		}
	}

	return mmDeleteClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmDeleteClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmDeleteClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteClickPipe")
	}

	mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe = f

	return mmDeleteClickPipe
}

// Return sets up results that will be returned by Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Return(err error) *ClientMock {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{mock: mmDeleteClickPipe.mock}
	}
	mmDeleteClickPipe.defaultExpectation.results = &ClientMockDeleteClickPipeResults{err}
	return mmDeleteClickPipe.mock
}

// Set uses given function f to mock the Client.DeleteClickPipe method
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (err error)) *ClientMock {
	if mmDeleteClickPipe.defaultExpectation != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.DeleteClickPipe method")
	}

	if len(mmDeleteClickPipe.expectations) > 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.DeleteClickPipe method")
	}

	mmDeleteClickPipe.mock.funcDeleteClickPipe = f
	return mmDeleteClickPipe.mock
}

// When sets expectation for the Client.DeleteClickPipe which will trigger the result defined by the following
// Then helper
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockDeleteClickPipeExpectation {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	expectation := &ClientMockDeleteClickPipeExpectation{
		mock:   mmDeleteClickPipe.mock,
		params: &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId},
	}
	mmDeleteClickPipe.expectations = append(mmDeleteClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteClickPipeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteClickPipeResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteClickPipe should be invoked
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Times(n uint64) *mClientMockDeleteClickPipe {
	if n == 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Times of ClientMock.DeleteClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteClickPipe.expectedInvocations, n)
	return mmDeleteClickPipe
}

func (mmDeleteClickPipe *mClientMockDeleteClickPipe) invocationsDone() bool {
	if len(mmDeleteClickPipe.expectations) == 0 && mmDeleteClickPipe.defaultExpectation == nil && mmDeleteClickPipe.mock.funcDeleteClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.mock.afterDeleteClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteClickPipe implements Client
func (mmDeleteClickPipe *ClientMock) DeleteClickPipe(ctx context.Context, serviceId string, clickPipeId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter, 1)

	if mmDeleteClickPipe.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.inspectFuncDeleteClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Lock()
	mmDeleteClickPipe.DeleteClickPipeMock.callArgs = append(mmDeleteClickPipe.DeleteClickPipeMock.callArgs, &mm_params)
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Unlock()

	for _, e := range mmDeleteClickPipe.DeleteClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteClickPipe.t.Fatal("No results are set for the ClientMock.DeleteClickPipe")
		}
		return (*mm_results).err
	}
	if mmDeleteClickPipe.funcDeleteClickPipe != nil {
		return mmDeleteClickPipe.funcDeleteClickPipe(ctx, serviceId, clickPipeId)
	}
	mmDeleteClickPipe.t.Fatalf("Unexpected call to ClientMock.DeleteClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// DeleteClickPipeAfterCounter returns a count of finished ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter)
}

// DeleteClickPipeBeforeCounter returns a count of ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Calls() []*ClientMockDeleteClickPipeParams {
	mmDeleteClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockDeleteClickPipeParams, len(mmDeleteClickPipe.callArgs))
	copy(argCopy, mmDeleteClickPipe.callArgs)

	mmDeleteClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteClickPipeDone returns true if the count of the DeleteClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteClickPipeDone() bool {
	if m.DeleteClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteClickPipeMock.invocationsDone()
}

// MinimockDeleteClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteClickPipeInspect() {
	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe with params: %#v", *e.params)
		}
	}

	afterDeleteClickPipeCounter := mm_atomic.LoadUint64(&m.afterDeleteClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClickPipeMock.defaultExpectation != nil && afterDeleteClickPipeCounter < 1 {
		if m.DeleteClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe with params: %#v", *m.DeleteClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClickPipe != nil && afterDeleteClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteClickPipe")
	}

	if !m.DeleteClickPipeMock.invocationsDone() && afterDeleteClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteClickPipeMock.expectedInvocations), afterDeleteClickPipeCounter)
	}
}

type mClientMockDeleteQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteQueryEndpointExpectation
	expectations       []*ClientMockDeleteQueryEndpointExpectation

	callArgs []*ClientMockDeleteQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteQueryEndpointExpectation specifies expectation struct of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteQueryEndpointParams
	paramPtrs *ClientMockDeleteQueryEndpointParamPtrs
	results   *ClientMockDeleteQueryEndpointResults
	Counter   uint64
}

// ClientMockDeleteQueryEndpointParams contains parameters of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
}

// ClientMockDeleteQueryEndpointParamPtrs contains pointers to parameters of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
}

// ClientMockDeleteQueryEndpointResults contains results of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Optional() *mClientMockDeleteQueryEndpoint {
	mmDeleteQueryEndpoint.optional = true
	return mmDeleteQueryEndpoint
}

// Expect sets up expected params for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Expect(ctx context.Context, serviceID string) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmDeleteQueryEndpoint.defaultExpectation.params = &ClientMockDeleteQueryEndpointParams{ctx, serviceID}
	for _, e := range mmDeleteQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmDeleteQueryEndpoint.defaultExpectation.params) {
			mmDeleteQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmDeleteQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.params != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Expect")
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteQueryEndpointParamPtrs{}
	}
	mmDeleteQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.params != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Expect")
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteQueryEndpointParamPtrs{}
	}
	mmDeleteQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmDeleteQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string)) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.inspectFuncDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteQueryEndpoint")
	}

	mmDeleteQueryEndpoint.mock.inspectFuncDeleteQueryEndpoint = f

	return mmDeleteQueryEndpoint
}

// Return sets up results that will be returned by Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Return(err error) *ClientMock {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{mock: mmDeleteQueryEndpoint.mock}
	}
	mmDeleteQueryEndpoint.defaultExpectation.results = &ClientMockDeleteQueryEndpointResults{err}
	return mmDeleteQueryEndpoint.mock
}

// Set uses given function f to mock the Client.DeleteQueryEndpoint method
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Set(f func(ctx context.Context, serviceID string) (err error)) *ClientMock {
	if mmDeleteQueryEndpoint.defaultExpectation != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.DeleteQueryEndpoint method")
	}

	if len(mmDeleteQueryEndpoint.expectations) > 0 {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.DeleteQueryEndpoint method")
	}

	mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint = f
	return mmDeleteQueryEndpoint.mock
}

// When sets expectation for the Client.DeleteQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) When(ctx context.Context, serviceID string) *ClientMockDeleteQueryEndpointExpectation {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockDeleteQueryEndpointExpectation{
		mock:   mmDeleteQueryEndpoint.mock,
		params: &ClientMockDeleteQueryEndpointParams{ctx, serviceID},
	}
	mmDeleteQueryEndpoint.expectations = append(mmDeleteQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteQueryEndpointExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteQueryEndpointResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteQueryEndpoint should be invoked
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Times(n uint64) *mClientMockDeleteQueryEndpoint {
	if n == 0 {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Times of ClientMock.DeleteQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteQueryEndpoint.expectedInvocations, n)
	return mmDeleteQueryEndpoint
}

func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) invocationsDone() bool {
	if len(mmDeleteQueryEndpoint.expectations) == 0 && mmDeleteQueryEndpoint.defaultExpectation == nil && mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.mock.afterDeleteQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteQueryEndpoint implements Client
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpoint(ctx context.Context, serviceID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteQueryEndpoint.beforeDeleteQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteQueryEndpoint.afterDeleteQueryEndpointCounter, 1)

	if mmDeleteQueryEndpoint.inspectFuncDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.inspectFuncDeleteQueryEndpoint(ctx, serviceID)
	}

	mm_params := ClientMockDeleteQueryEndpointParams{ctx, serviceID}

	// Record call args
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.mutex.Lock()
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.callArgs = append(mmDeleteQueryEndpoint.DeleteQueryEndpointMock.callArgs, &mm_params)
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.mutex.Unlock()

	for _, e := range mmDeleteQueryEndpoint.DeleteQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteQueryEndpointParams{ctx, serviceID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteQueryEndpoint.t.Fatal("No results are set for the ClientMock.DeleteQueryEndpoint")
		}
		return (*mm_results).err
	}
	if mmDeleteQueryEndpoint.funcDeleteQueryEndpoint != nil {
		return mmDeleteQueryEndpoint.funcDeleteQueryEndpoint(ctx, serviceID)
	}
	mmDeleteQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.DeleteQueryEndpoint. %v %v", ctx, serviceID)
	return
}

// DeleteQueryEndpointAfterCounter returns a count of finished ClientMock.DeleteQueryEndpoint invocations
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.afterDeleteQueryEndpointCounter)
}

// DeleteQueryEndpointBeforeCounter returns a count of ClientMock.DeleteQueryEndpoint invocations
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.beforeDeleteQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Calls() []*ClientMockDeleteQueryEndpointParams {
	mmDeleteQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockDeleteQueryEndpointParams, len(mmDeleteQueryEndpoint.callArgs))
	copy(argCopy, mmDeleteQueryEndpoint.callArgs)

	mmDeleteQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteQueryEndpointDone returns true if the count of the DeleteQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteQueryEndpointDone() bool {
	if m.DeleteQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteQueryEndpointMock.invocationsDone()
}

// MinimockDeleteQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteQueryEndpointInspect() {
	for _, e := range m.DeleteQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint with params: %#v", *e.params)
		}
	}

	afterDeleteQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterDeleteQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteQueryEndpointMock.defaultExpectation != nil && afterDeleteQueryEndpointCounter < 1 {
		if m.DeleteQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteQueryEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint with params: %#v", *m.DeleteQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteQueryEndpoint != nil && afterDeleteQueryEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteQueryEndpoint")
	}

	if !m.DeleteQueryEndpointMock.invocationsDone() && afterDeleteQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteQueryEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteQueryEndpointMock.expectedInvocations), afterDeleteQueryEndpointCounter)
	}
}

type mClientMockDeleteService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteServiceExpectation
	expectations       []*ClientMockDeleteServiceExpectation

	callArgs []*ClientMockDeleteServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteServiceExpectation specifies expectation struct of the Client.DeleteService
type ClientMockDeleteServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteServiceParams
	paramPtrs *ClientMockDeleteServiceParamPtrs
	results   *ClientMockDeleteServiceResults
	Counter   uint64
}

// ClientMockDeleteServiceParams contains parameters of the Client.DeleteService
type ClientMockDeleteServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockDeleteServiceParamPtrs contains pointers to parameters of the Client.DeleteService
type ClientMockDeleteServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockDeleteServiceResults contains results of the Client.DeleteService
type ClientMockDeleteServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteService *mClientMockDeleteService) Optional() *mClientMockDeleteService {
	mmDeleteService.optional = true
	return mmDeleteService
}

// Expect sets up expected params for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Expect(ctx context.Context, serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.paramPtrs != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by ExpectParams functions")
	}

	mmDeleteService.defaultExpectation.params = &ClientMockDeleteServiceParams{ctx, serviceId}
	for _, e := range mmDeleteService.expectations {
		if minimock.Equal(e.params, mmDeleteService.defaultExpectation.params) {
			mmDeleteService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteService.defaultExpectation.params)
		}
	}

	return mmDeleteService
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmDeleteService
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockDeleteService {
	if mmDeleteService.mock.inspectFuncDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteService")
	}

	mmDeleteService.mock.inspectFuncDeleteService = f

	return mmDeleteService
}

// Return sets up results that will be returned by Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Return(sp1 *Service, err error) *ClientMock {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{mock: mmDeleteService.mock}
	}
	mmDeleteService.defaultExpectation.results = &ClientMockDeleteServiceResults{sp1, err}
	return mmDeleteService.mock
}

// Set uses given function f to mock the Client.DeleteService method
func (mmDeleteService *mClientMockDeleteService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmDeleteService.defaultExpectation != nil {
		mmDeleteService.mock.t.Fatalf("Default expectation is already set for the Client.DeleteService method")
	}

	if len(mmDeleteService.expectations) > 0 {
		mmDeleteService.mock.t.Fatalf("Some expectations are already set for the Client.DeleteService method")
	}

	mmDeleteService.mock.funcDeleteService = f
	return mmDeleteService.mock
}

// When sets expectation for the Client.DeleteService which will trigger the result defined by the following
// Then helper
func (mmDeleteService *mClientMockDeleteService) When(ctx context.Context, serviceId string) *ClientMockDeleteServiceExpectation {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	expectation := &ClientMockDeleteServiceExpectation{
		mock:   mmDeleteService.mock,
		params: &ClientMockDeleteServiceParams{ctx, serviceId},
	}
	mmDeleteService.expectations = append(mmDeleteService.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteService return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockDeleteServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.DeleteService should be invoked
func (mmDeleteService *mClientMockDeleteService) Times(n uint64) *mClientMockDeleteService {
	if n == 0 {
		mmDeleteService.mock.t.Fatalf("Times of ClientMock.DeleteService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteService.expectedInvocations, n)
	return mmDeleteService
}

func (mmDeleteService *mClientMockDeleteService) invocationsDone() bool {
	if len(mmDeleteService.expectations) == 0 && mmDeleteService.defaultExpectation == nil && mmDeleteService.mock.funcDeleteService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteService.mock.afterDeleteServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteService implements Client
func (mmDeleteService *ClientMock) DeleteService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmDeleteService.beforeDeleteServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteService.afterDeleteServiceCounter, 1)

	if mmDeleteService.inspectFuncDeleteService != nil {
		mmDeleteService.inspectFuncDeleteService(ctx, serviceId)
	}

	mm_params := ClientMockDeleteServiceParams{ctx, serviceId}

	// Record call args
	mmDeleteService.DeleteServiceMock.mutex.Lock()
	mmDeleteService.DeleteServiceMock.callArgs = append(mmDeleteService.DeleteServiceMock.callArgs, &mm_params)
	mmDeleteService.DeleteServiceMock.mutex.Unlock()

	for _, e := range mmDeleteService.DeleteServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDeleteService.DeleteServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteService.DeleteServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteService.DeleteServiceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteService.DeleteServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteService.DeleteServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteService.t.Fatal("No results are set for the ClientMock.DeleteService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDeleteService.funcDeleteService != nil {
		return mmDeleteService.funcDeleteService(ctx, serviceId)
	}
	mmDeleteService.t.Fatalf("Unexpected call to ClientMock.DeleteService. %v %v", ctx, serviceId)
	return
}

// DeleteServiceAfterCounter returns a count of finished ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.afterDeleteServiceCounter)
}

// DeleteServiceBeforeCounter returns a count of ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.beforeDeleteServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteService *mClientMockDeleteService) Calls() []*ClientMockDeleteServiceParams {
	mmDeleteService.mutex.RLock()

	argCopy := make([]*ClientMockDeleteServiceParams, len(mmDeleteService.callArgs))
	copy(argCopy, mmDeleteService.callArgs)

	mmDeleteService.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteServiceDone returns true if the count of the DeleteService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteServiceDone() bool {
	if m.DeleteServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteServiceMock.invocationsDone()
}

// MinimockDeleteServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteServiceInspect() {
	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteService with params: %#v", *e.params)
		}
	}

	afterDeleteServiceCounter := mm_atomic.LoadUint64(&m.afterDeleteServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteServiceMock.defaultExpectation != nil && afterDeleteServiceCounter < 1 {
		if m.DeleteServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteService")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteService with params: %#v", *m.DeleteServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteService != nil && afterDeleteServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteService")
	}

	if !m.DeleteServiceMock.invocationsDone() && afterDeleteServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteService but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteServiceMock.expectedInvocations), afterDeleteServiceCounter)
	}
}

type mClientMockDeleteUser struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteUserExpectation
	expectations       []*ClientMockDeleteUserExpectation

	callArgs []*ClientMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteUserExpectation specifies expectation struct of the Client.DeleteUser
type ClientMockDeleteUserExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteUserParams
	paramPtrs *ClientMockDeleteUserParamPtrs
	results   *ClientMockDeleteUserResults
	Counter   uint64
}

// ClientMockDeleteUserParams contains parameters of the Client.DeleteUser
type ClientMockDeleteUserParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockDeleteUserParamPtrs contains pointers to parameters of the Client.DeleteUser
type ClientMockDeleteUserParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockDeleteUserResults contains results of the Client.DeleteUser
type ClientMockDeleteUserResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mClientMockDeleteUser) Optional() *mClientMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) Expect(ctx context.Context, serviceID string, name string) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &ClientMockDeleteUserParams{ctx, serviceID, name}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ClientMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteUser
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ClientMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmDeleteUser
}

// ExpectNameParam3 sets up expected param name for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) ExpectNameParam3(name string) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ClientMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.name = &name

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) Return(err error) *ClientMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &ClientMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

// Set uses given function f to mock the Client.DeleteUser method
func (mmDeleteUser *mClientMockDeleteUser) Set(f func(ctx context.Context, serviceID string, name string) (err error)) *ClientMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Client.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Client.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the Client.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mClientMockDeleteUser) When(ctx context.Context, serviceID string, name string) *ClientMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	expectation := &ClientMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &ClientMockDeleteUserParams{ctx, serviceID, name},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteUser return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteUserExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteUser should be invoked
func (mmDeleteUser *mClientMockDeleteUser) Times(n uint64) *mClientMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of ClientMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	return mmDeleteUser
}

func (mmDeleteUser *mClientMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements Client
func (mmDeleteUser *ClientMock) DeleteUser(ctx context.Context, serviceID string, name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, serviceID, name)
	}

	mm_params := ClientMockDeleteUserParams{ctx, serviceID, name}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteUserParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the ClientMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, serviceID, name)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to ClientMock.DeleteUser. %v %v %v", ctx, serviceID, name)
	return
}

// DeleteUserAfterCounter returns a count of finished ClientMock.DeleteUser invocations
func (mmDeleteUser *ClientMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of ClientMock.DeleteUser invocations
func (mmDeleteUser *ClientMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mClientMockDeleteUser) Calls() []*ClientMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*ClientMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteUser with params: %#v", *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteUser")
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteUser but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
	}
}

type mClientMockGetApiKeyID struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetApiKeyIDExpectation
	expectations       []*ClientMockGetApiKeyIDExpectation

	callArgs []*ClientMockGetApiKeyIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetApiKeyIDExpectation specifies expectation struct of the Client.GetApiKeyID
type ClientMockGetApiKeyIDExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetApiKeyIDParams
	paramPtrs *ClientMockGetApiKeyIDParamPtrs
	results   *ClientMockGetApiKeyIDResults
	Counter   uint64
}

// ClientMockGetApiKeyIDParams contains parameters of the Client.GetApiKeyID
type ClientMockGetApiKeyIDParams struct {
	ctx  context.Context
	name *string
}

// ClientMockGetApiKeyIDParamPtrs contains pointers to parameters of the Client.GetApiKeyID
type ClientMockGetApiKeyIDParamPtrs struct {
	ctx  *context.Context
	name **string
}

// ClientMockGetApiKeyIDResults contains results of the Client.GetApiKeyID
type ClientMockGetApiKeyIDResults struct {
	ap1 *ApiKey
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApiKeyID *mClientMockGetApiKeyID) Optional() *mClientMockGetApiKeyID {
	mmGetApiKeyID.optional = true
	return mmGetApiKeyID
}

// Expect sets up expected params for Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) Expect(ctx context.Context, name *string) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{}
	}

	if mmGetApiKeyID.defaultExpectation.paramPtrs != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by ExpectParams functions")
	}

	mmGetApiKeyID.defaultExpectation.params = &ClientMockGetApiKeyIDParams{ctx, name}
	for _, e := range mmGetApiKeyID.expectations {
		if minimock.Equal(e.params, mmGetApiKeyID.defaultExpectation.params) {
			mmGetApiKeyID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApiKeyID.defaultExpectation.params)
		}
	}

	return mmGetApiKeyID
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) ExpectCtxParam1(ctx context.Context) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{}
	}

	if mmGetApiKeyID.defaultExpectation.params != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Expect")
	}

	if mmGetApiKeyID.defaultExpectation.paramPtrs == nil {
		mmGetApiKeyID.defaultExpectation.paramPtrs = &ClientMockGetApiKeyIDParamPtrs{}
	}
	mmGetApiKeyID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApiKeyID
}

// ExpectNameParam2 sets up expected param name for Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) ExpectNameParam2(name *string) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{}
	}

	if mmGetApiKeyID.defaultExpectation.params != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Expect")
	}

	if mmGetApiKeyID.defaultExpectation.paramPtrs == nil {
		mmGetApiKeyID.defaultExpectation.paramPtrs = &ClientMockGetApiKeyIDParamPtrs{}
	}
	mmGetApiKeyID.defaultExpectation.paramPtrs.name = &name

	return mmGetApiKeyID
}

// Inspect accepts an inspector function that has same arguments as the Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) Inspect(f func(ctx context.Context, name *string)) *mClientMockGetApiKeyID {
	if mmGetApiKeyID.mock.inspectFuncGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("Inspect function is already set for ClientMock.GetApiKeyID")
	}

	mmGetApiKeyID.mock.inspectFuncGetApiKeyID = f

	return mmGetApiKeyID
}

// Return sets up results that will be returned by Client.GetApiKeyID
func (mmGetApiKeyID *mClientMockGetApiKeyID) Return(ap1 *ApiKey, err error) *ClientMock {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	if mmGetApiKeyID.defaultExpectation == nil {
		mmGetApiKeyID.defaultExpectation = &ClientMockGetApiKeyIDExpectation{mock: mmGetApiKeyID.mock}
	}
	mmGetApiKeyID.defaultExpectation.results = &ClientMockGetApiKeyIDResults{ap1, err}
	return mmGetApiKeyID.mock
}

// Set uses given function f to mock the Client.GetApiKeyID method
func (mmGetApiKeyID *mClientMockGetApiKeyID) Set(f func(ctx context.Context, name *string) (ap1 *ApiKey, err error)) *ClientMock {
	if mmGetApiKeyID.defaultExpectation != nil {
		mmGetApiKeyID.mock.t.Fatalf("Default expectation is already set for the Client.GetApiKeyID method")
	}

	if len(mmGetApiKeyID.expectations) > 0 {
		mmGetApiKeyID.mock.t.Fatalf("Some expectations are already set for the Client.GetApiKeyID method")
	}

	mmGetApiKeyID.mock.funcGetApiKeyID = f
	return mmGetApiKeyID.mock
}

// When sets expectation for the Client.GetApiKeyID which will trigger the result defined by the following
// Then helper
func (mmGetApiKeyID *mClientMockGetApiKeyID) When(ctx context.Context, name *string) *ClientMockGetApiKeyIDExpectation {
	if mmGetApiKeyID.mock.funcGetApiKeyID != nil {
		mmGetApiKeyID.mock.t.Fatalf("ClientMock.GetApiKeyID mock is already set by Set")
	}

	expectation := &ClientMockGetApiKeyIDExpectation{
		mock:   mmGetApiKeyID.mock,
		params: &ClientMockGetApiKeyIDParams{ctx, name},
	}
	mmGetApiKeyID.expectations = append(mmGetApiKeyID.expectations, expectation)
	return expectation
}

// Then sets up Client.GetApiKeyID return parameters for the expectation previously defined by the When method
func (e *ClientMockGetApiKeyIDExpectation) Then(ap1 *ApiKey, err error) *ClientMock {
	e.results = &ClientMockGetApiKeyIDResults{ap1, err}
	return e.mock
}

// Times sets number of times Client.GetApiKeyID should be invoked
func (mmGetApiKeyID *mClientMockGetApiKeyID) Times(n uint64) *mClientMockGetApiKeyID {
	if n == 0 {
		mmGetApiKeyID.mock.t.Fatalf("Times of ClientMock.GetApiKeyID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApiKeyID.expectedInvocations, n)
	return mmGetApiKeyID
}

func (mmGetApiKeyID *mClientMockGetApiKeyID) invocationsDone() bool {
	if len(mmGetApiKeyID.expectations) == 0 && mmGetApiKeyID.defaultExpectation == nil && mmGetApiKeyID.mock.funcGetApiKeyID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApiKeyID.mock.afterGetApiKeyIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApiKeyID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApiKeyID implements Client
func (mmGetApiKeyID *ClientMock) GetApiKeyID(ctx context.Context, name *string) (ap1 *ApiKey, err error) {
	mm_atomic.AddUint64(&mmGetApiKeyID.beforeGetApiKeyIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApiKeyID.afterGetApiKeyIDCounter, 1)

	if mmGetApiKeyID.inspectFuncGetApiKeyID != nil {
		mmGetApiKeyID.inspectFuncGetApiKeyID(ctx, name)
	}

	mm_params := ClientMockGetApiKeyIDParams{ctx, name}

	// Record call args
	mmGetApiKeyID.GetApiKeyIDMock.mutex.Lock()
	mmGetApiKeyID.GetApiKeyIDMock.callArgs = append(mmGetApiKeyID.GetApiKeyIDMock.callArgs, &mm_params)
	mmGetApiKeyID.GetApiKeyIDMock.mutex.Unlock()

	for _, e := range mmGetApiKeyID.GetApiKeyIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetApiKeyIDParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApiKeyID.t.Errorf("ClientMock.GetApiKeyID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetApiKeyID.t.Errorf("ClientMock.GetApiKeyID got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApiKeyID.t.Errorf("ClientMock.GetApiKeyID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApiKeyID.GetApiKeyIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApiKeyID.t.Fatal("No results are set for the ClientMock.GetApiKeyID")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApiKeyID.funcGetApiKeyID != nil {
		return mmGetApiKeyID.funcGetApiKeyID(ctx, name)
	}
	mmGetApiKeyID.t.Fatalf("Unexpected call to ClientMock.GetApiKeyID. %v %v", ctx, name)
	return
}

// GetApiKeyIDAfterCounter returns a count of finished ClientMock.GetApiKeyID invocations
func (mmGetApiKeyID *ClientMock) GetApiKeyIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApiKeyID.afterGetApiKeyIDCounter)
}

// GetApiKeyIDBeforeCounter returns a count of ClientMock.GetApiKeyID invocations
func (mmGetApiKeyID *ClientMock) GetApiKeyIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApiKeyID.beforeGetApiKeyIDCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetApiKeyID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApiKeyID *mClientMockGetApiKeyID) Calls() []*ClientMockGetApiKeyIDParams {
	mmGetApiKeyID.mutex.RLock()

	argCopy := make([]*ClientMockGetApiKeyIDParams, len(mmGetApiKeyID.callArgs))
	copy(argCopy, mmGetApiKeyID.callArgs)

	mmGetApiKeyID.mutex.RUnlock()

	return argCopy
}

// MinimockGetApiKeyIDDone returns true if the count of the GetApiKeyID invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetApiKeyIDDone() bool {
	if m.GetApiKeyIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApiKeyIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApiKeyIDMock.invocationsDone()
}

// MinimockGetApiKeyIDInspect logs each unmet expectation
func (m *ClientMock) MinimockGetApiKeyIDInspect() {
	for _, e := range m.GetApiKeyIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetApiKeyID with params: %#v", *e.params)
		}
	}

	afterGetApiKeyIDCounter := mm_atomic.LoadUint64(&m.afterGetApiKeyIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApiKeyIDMock.defaultExpectation != nil && afterGetApiKeyIDCounter < 1 {
		if m.GetApiKeyIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetApiKeyID")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetApiKeyID with params: %#v", *m.GetApiKeyIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApiKeyID != nil && afterGetApiKeyIDCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetApiKeyID")
	}

	if !m.GetApiKeyIDMock.invocationsDone() && afterGetApiKeyIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetApiKeyID but found %d calls",
			mm_atomic.LoadUint64(&m.GetApiKeyIDMock.expectedInvocations), afterGetApiKeyIDCounter)
	}
}

type mClientMockGetBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetBackupConfigurationExpectation
	expectations       []*ClientMockGetBackupConfigurationExpectation

	callArgs []*ClientMockGetBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetBackupConfigurationExpectation specifies expectation struct of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetBackupConfigurationParams
	paramPtrs *ClientMockGetBackupConfigurationParamPtrs
	results   *ClientMockGetBackupConfigurationResults
	Counter   uint64
}

// ClientMockGetBackupConfigurationParams contains parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetBackupConfigurationParamPtrs contains pointers to parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetBackupConfigurationResults contains results of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Optional() *mClientMockGetBackupConfiguration {
	mmGetBackupConfiguration.optional = true
	return mmGetBackupConfiguration
}

// Expect sets up expected params for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Expect(ctx context.Context, serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmGetBackupConfiguration.defaultExpectation.params = &ClientMockGetBackupConfigurationParams{ctx, serviceId}
	for _, e := range mmGetBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmGetBackupConfiguration.defaultExpectation.params) {
			mmGetBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmGetBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.GetBackupConfiguration")
	}

	mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration = f

	return mmGetBackupConfiguration
}

// Return sets up results that will be returned by Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{mock: mmGetBackupConfiguration.mock}
	}
	mmGetBackupConfiguration.defaultExpectation.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return mmGetBackupConfiguration.mock
}

// Set uses given function f to mock the Client.GetBackupConfiguration method
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Set(f func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmGetBackupConfiguration.defaultExpectation != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.GetBackupConfiguration method")
	}

	if len(mmGetBackupConfiguration.expectations) > 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.GetBackupConfiguration method")
	}

	mmGetBackupConfiguration.mock.funcGetBackupConfiguration = f
	return mmGetBackupConfiguration.mock
}

// When sets expectation for the Client.GetBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) When(ctx context.Context, serviceId string) *ClientMockGetBackupConfigurationExpectation {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockGetBackupConfigurationExpectation{
		mock:   mmGetBackupConfiguration.mock,
		params: &ClientMockGetBackupConfigurationParams{ctx, serviceId},
	}
	mmGetBackupConfiguration.expectations = append(mmGetBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.GetBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockGetBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.GetBackupConfiguration should be invoked
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Times(n uint64) *mClientMockGetBackupConfiguration {
	if n == 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Times of ClientMock.GetBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBackupConfiguration.expectedInvocations, n)
	return mmGetBackupConfiguration
}

func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) invocationsDone() bool {
	if len(mmGetBackupConfiguration.expectations) == 0 && mmGetBackupConfiguration.defaultExpectation == nil && mmGetBackupConfiguration.mock.funcGetBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.mock.afterGetBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBackupConfiguration implements Client
func (mmGetBackupConfiguration *ClientMock) GetBackupConfiguration(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter, 1)

	if mmGetBackupConfiguration.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.inspectFuncGetBackupConfiguration(ctx, serviceId)
	}

	mm_params := ClientMockGetBackupConfigurationParams{ctx, serviceId}

	// Record call args
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Lock()
	mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs = append(mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs, &mm_params)
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmGetBackupConfiguration.GetBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetBackupConfigurationParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBackupConfiguration.t.Fatal("No results are set for the ClientMock.GetBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBackupConfiguration.funcGetBackupConfiguration != nil {
		return mmGetBackupConfiguration.funcGetBackupConfiguration(ctx, serviceId)
	}
	mmGetBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.GetBackupConfiguration. %v %v", ctx, serviceId)
	return
}

// GetBackupConfigurationAfterCounter returns a count of finished ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter)
}

// GetBackupConfigurationBeforeCounter returns a count of ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Calls() []*ClientMockGetBackupConfigurationParams {
	mmGetBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockGetBackupConfigurationParams, len(mmGetBackupConfiguration.callArgs))
	copy(argCopy, mmGetBackupConfiguration.callArgs)

	mmGetBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockGetBackupConfigurationDone returns true if the count of the GetBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetBackupConfigurationDone() bool {
	if m.GetBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBackupConfigurationMock.invocationsDone()
}

// MinimockGetBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockGetBackupConfigurationInspect() {
	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration with params: %#v", *e.params)
		}
	}

	afterGetBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterGetBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBackupConfigurationMock.defaultExpectation != nil && afterGetBackupConfigurationCounter < 1 {
		if m.GetBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetBackupConfiguration")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration with params: %#v", *m.GetBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBackupConfiguration != nil && afterGetBackupConfigurationCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetBackupConfiguration")
	}

	if !m.GetBackupConfigurationMock.invocationsDone() && afterGetBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetBackupConfiguration but found %d calls",
			mm_atomic.LoadUint64(&m.GetBackupConfigurationMock.expectedInvocations), afterGetBackupConfigurationCounter)
	}
}

type mClientMockGetClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetClickPipeExpectation
	expectations       []*ClientMockGetClickPipeExpectation

	callArgs []*ClientMockGetClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetClickPipeExpectation specifies expectation struct of the Client.GetClickPipe
type ClientMockGetClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetClickPipeParams
	paramPtrs *ClientMockGetClickPipeParamPtrs
	results   *ClientMockGetClickPipeResults
	Counter   uint64
}

// ClientMockGetClickPipeParams contains parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockGetClickPipeParamPtrs contains pointers to parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockGetClickPipeResults contains results of the Client.GetClickPipe
type ClientMockGetClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClickPipe *mClientMockGetClickPipe) Optional() *mClientMockGetClickPipe {
	mmGetClickPipe.optional = true
	return mmGetClickPipe
}

// Expect sets up expected params for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by ExpectParams functions")
	}

	mmGetClickPipe.defaultExpectation.params = &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}
	for _, e := range mmGetClickPipe.expectations {
		if minimock.Equal(e.params, mmGetClickPipe.defaultExpectation.params) {
			mmGetClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClickPipe.defaultExpectation.params)
		}
	}

	return mmGetClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmGetClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.GetClickPipe")
	}

	mmGetClickPipe.mock.inspectFuncGetClickPipe = f

	return mmGetClickPipe
}

// Return sets up results that will be returned by Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{mock: mmGetClickPipe.mock}
	}
	mmGetClickPipe.defaultExpectation.results = &ClientMockGetClickPipeResults{cp1, err}
	return mmGetClickPipe.mock
}

// Set uses given function f to mock the Client.GetClickPipe method
func (mmGetClickPipe *mClientMockGetClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmGetClickPipe.defaultExpectation != nil {
		mmGetClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.GetClickPipe method")
	}

	if len(mmGetClickPipe.expectations) > 0 {
		mmGetClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.GetClickPipe method")
	}

	mmGetClickPipe.mock.funcGetClickPipe = f
	return mmGetClickPipe.mock
}

// When sets expectation for the Client.GetClickPipe which will trigger the result defined by the following
// Then helper
func (mmGetClickPipe *mClientMockGetClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockGetClickPipeExpectation {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	expectation := &ClientMockGetClickPipeExpectation{
		mock:   mmGetClickPipe.mock,
		params: &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId},
	}
	mmGetClickPipe.expectations = append(mmGetClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.GetClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockGetClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockGetClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.GetClickPipe should be invoked
func (mmGetClickPipe *mClientMockGetClickPipe) Times(n uint64) *mClientMockGetClickPipe {
	if n == 0 {
		mmGetClickPipe.mock.t.Fatalf("Times of ClientMock.GetClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClickPipe.expectedInvocations, n)
	return mmGetClickPipe
}

func (mmGetClickPipe *mClientMockGetClickPipe) invocationsDone() bool {
	if len(mmGetClickPipe.expectations) == 0 && mmGetClickPipe.defaultExpectation == nil && mmGetClickPipe.mock.funcGetClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.mock.afterGetClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClickPipe implements Client
func (mmGetClickPipe *ClientMock) GetClickPipe(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmGetClickPipe.beforeGetClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClickPipe.afterGetClickPipeCounter, 1)

	if mmGetClickPipe.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.inspectFuncGetClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmGetClickPipe.GetClickPipeMock.mutex.Lock()
	mmGetClickPipe.GetClickPipeMock.callArgs = append(mmGetClickPipe.GetClickPipeMock.callArgs, &mm_params)
	mmGetClickPipe.GetClickPipeMock.mutex.Unlock()

	for _, e := range mmGetClickPipe.GetClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetClickPipe.GetClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClickPipe.GetClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClickPipe.GetClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmGetClickPipe.GetClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClickPipe.GetClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClickPipe.t.Fatal("No results are set for the ClientMock.GetClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetClickPipe.funcGetClickPipe != nil {
		return mmGetClickPipe.funcGetClickPipe(ctx, serviceId, clickPipeId)
	}
	mmGetClickPipe.t.Fatalf("Unexpected call to ClientMock.GetClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// GetClickPipeAfterCounter returns a count of finished ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.afterGetClickPipeCounter)
}

// GetClickPipeBeforeCounter returns a count of ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.beforeGetClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClickPipe *mClientMockGetClickPipe) Calls() []*ClientMockGetClickPipeParams {
	mmGetClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockGetClickPipeParams, len(mmGetClickPipe.callArgs))
	copy(argCopy, mmGetClickPipe.callArgs)

	mmGetClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockGetClickPipeDone returns true if the count of the GetClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetClickPipeDone() bool {
	if m.GetClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClickPipeMock.invocationsDone()
}

// MinimockGetClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetClickPipeInspect() {
	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe with params: %#v", *e.params)
		}
	}

	afterGetClickPipeCounter := mm_atomic.LoadUint64(&m.afterGetClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClickPipeMock.defaultExpectation != nil && afterGetClickPipeCounter < 1 {
		if m.GetClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe with params: %#v", *m.GetClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClickPipe != nil && afterGetClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetClickPipe")
	}

	if !m.GetClickPipeMock.invocationsDone() && afterGetClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.GetClickPipeMock.expectedInvocations), afterGetClickPipeCounter)
	}
}

type mClientMockGetOrgPrivateEndpointConfig struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrgPrivateEndpointConfigExpectation
	expectations       []*ClientMockGetOrgPrivateEndpointConfigExpectation

	callArgs []*ClientMockGetOrgPrivateEndpointConfigParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetOrgPrivateEndpointConfigExpectation specifies expectation struct of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetOrgPrivateEndpointConfigParams
	paramPtrs *ClientMockGetOrgPrivateEndpointConfigParamPtrs
	results   *ClientMockGetOrgPrivateEndpointConfigResults
	Counter   uint64
}

// ClientMockGetOrgPrivateEndpointConfigParams contains parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParams struct {
	ctx           context.Context
	cloudProvider string
	region        string
}

// ClientMockGetOrgPrivateEndpointConfigParamPtrs contains pointers to parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParamPtrs struct {
	ctx           *context.Context
	cloudProvider *string
	region        *string
}

// ClientMockGetOrgPrivateEndpointConfigResults contains results of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigResults struct {
	op1 *OrgPrivateEndpointConfig
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Optional() *mClientMockGetOrgPrivateEndpointConfig {
	mmGetOrgPrivateEndpointConfig.optional = true
	return mmGetOrgPrivateEndpointConfig
}

// Expect sets up expected params for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Expect(ctx context.Context, cloudProvider string, region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by ExpectParams functions")
	}

	mmGetOrgPrivateEndpointConfig.defaultExpectation.params = &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}
	for _, e := range mmGetOrgPrivateEndpointConfig.expectations {
		if minimock.Equal(e.params, mmGetOrgPrivateEndpointConfig.defaultExpectation.params) {
			mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrgPrivateEndpointConfig.defaultExpectation.params)
		}
	}

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCloudProviderParam2 sets up expected param cloudProvider for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCloudProviderParam2(cloudProvider string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.cloudProvider = &cloudProvider

	return mmGetOrgPrivateEndpointConfig
}

// ExpectRegionParam3 sets up expected param region for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectRegionParam3(region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.region = &region

	return mmGetOrgPrivateEndpointConfig
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Inspect(f func(ctx context.Context, cloudProvider string, region string)) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrgPrivateEndpointConfig")
	}

	mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig = f

	return mmGetOrgPrivateEndpointConfig
}

// Return sets up results that will be returned by Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Return(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{mock: mmGetOrgPrivateEndpointConfig.mock}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return mmGetOrgPrivateEndpointConfig.mock
}

// Set uses given function f to mock the Client.GetOrgPrivateEndpointConfig method
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Set(f func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.defaultExpectation != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Default expectation is already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	if len(mmGetOrgPrivateEndpointConfig.expectations) > 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Some expectations are already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig = f
	return mmGetOrgPrivateEndpointConfig.mock
}

// When sets expectation for the Client.GetOrgPrivateEndpointConfig which will trigger the result defined by the following
// Then helper
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) When(ctx context.Context, cloudProvider string, region string) *ClientMockGetOrgPrivateEndpointConfigExpectation {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	expectation := &ClientMockGetOrgPrivateEndpointConfigExpectation{
		mock:   mmGetOrgPrivateEndpointConfig.mock,
		params: &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region},
	}
	mmGetOrgPrivateEndpointConfig.expectations = append(mmGetOrgPrivateEndpointConfig.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrgPrivateEndpointConfig return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrgPrivateEndpointConfigExpectation) Then(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	e.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return e.mock
}

// Times sets number of times Client.GetOrgPrivateEndpointConfig should be invoked
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Times(n uint64) *mClientMockGetOrgPrivateEndpointConfig {
	if n == 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Times of ClientMock.GetOrgPrivateEndpointConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations, n)
	return mmGetOrgPrivateEndpointConfig
}

func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) invocationsDone() bool {
	if len(mmGetOrgPrivateEndpointConfig.expectations) == 0 && mmGetOrgPrivateEndpointConfig.defaultExpectation == nil && mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.mock.afterGetOrgPrivateEndpointConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrgPrivateEndpointConfig implements Client
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfig(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error) {
	mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter, 1)

	if mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}

	mm_params := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

	// Record call args
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Lock()
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs = append(mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs, &mm_params)
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Unlock()

	for _, e := range mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cloudProvider != nil && !minimock.Equal(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter cloudProvider, want: %#v, got: %#v%s\n", *mm_want_ptrs.cloudProvider, mm_got.cloudProvider, minimock.Diff(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider))
			}

			if mm_want_ptrs.region != nil && !minimock.Equal(*mm_want_ptrs.region, mm_got.region) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter region, want: %#v, got: %#v%s\n", *mm_want_ptrs.region, mm_got.region, minimock.Diff(*mm_want_ptrs.region, mm_got.region))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrgPrivateEndpointConfig.t.Fatal("No results are set for the ClientMock.GetOrgPrivateEndpointConfig")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig != nil {
		return mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}
	mmGetOrgPrivateEndpointConfig.t.Fatalf("Unexpected call to ClientMock.GetOrgPrivateEndpointConfig. %v %v %v", ctx, cloudProvider, region)
	return
}

// GetOrgPrivateEndpointConfigAfterCounter returns a count of finished ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter)
}

// GetOrgPrivateEndpointConfigBeforeCounter returns a count of ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrgPrivateEndpointConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Calls() []*ClientMockGetOrgPrivateEndpointConfigParams {
	mmGetOrgPrivateEndpointConfig.mutex.RLock()

	argCopy := make([]*ClientMockGetOrgPrivateEndpointConfigParams, len(mmGetOrgPrivateEndpointConfig.callArgs))
	copy(argCopy, mmGetOrgPrivateEndpointConfig.callArgs)

	mmGetOrgPrivateEndpointConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrgPrivateEndpointConfigDone returns true if the count of the GetOrgPrivateEndpointConfig invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigDone() bool {
	if m.GetOrgPrivateEndpointConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrgPrivateEndpointConfigMock.invocationsDone()
}

// MinimockGetOrgPrivateEndpointConfigInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigInspect() {
	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig with params: %#v", *e.params)
		}
	}

	afterGetOrgPrivateEndpointConfigCounter := mm_atomic.LoadUint64(&m.afterGetOrgPrivateEndpointConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		if m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetOrgPrivateEndpointConfig")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig with params: %#v", *m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrgPrivateEndpointConfig != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetOrgPrivateEndpointConfig")
	}

	if !m.GetOrgPrivateEndpointConfigMock.invocationsDone() && afterGetOrgPrivateEndpointConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrgPrivateEndpointConfig but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrgPrivateEndpointConfigMock.expectedInvocations), afterGetOrgPrivateEndpointConfigCounter)
	}
}

type mClientMockGetOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockGetOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockGetOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetOrganizationPrivateEndpointsParams
	paramPtrs *ClientMockGetOrganizationPrivateEndpointsParamPtrs
	results   *ClientMockGetOrganizationPrivateEndpointsResults
	Counter   uint64
}

// ClientMockGetOrganizationPrivateEndpointsParams contains parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParams struct {
	ctx context.Context
}

// ClientMockGetOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParamPtrs struct {
	ctx *context.Context
}

// ClientMockGetOrganizationPrivateEndpointsResults contains results of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Optional() *mClientMockGetOrganizationPrivateEndpoints {
	mmGetOrganizationPrivateEndpoints.optional = true
	return mmGetOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Expect(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmGetOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockGetOrganizationPrivateEndpointsParams{ctx}
	for _, e := range mmGetOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmGetOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmGetOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockGetOrganizationPrivateEndpointsParamPtrs{}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context)) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrganizationPrivateEndpoints")
	}

	mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints = f

	return mmGetOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{mock: mmGetOrganizationPrivateEndpoints.mock}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return mmGetOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.GetOrganizationPrivateEndpoints method
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Set(f func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	if len(mmGetOrganizationPrivateEndpoints.expectations) > 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints = f
	return mmGetOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.GetOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) When(ctx context.Context) *ClientMockGetOrganizationPrivateEndpointsExpectation {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockGetOrganizationPrivateEndpointsExpectation{
		mock:   mmGetOrganizationPrivateEndpoints.mock,
		params: &ClientMockGetOrganizationPrivateEndpointsParams{ctx},
	}
	mmGetOrganizationPrivateEndpoints.expectations = append(mmGetOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.GetOrganizationPrivateEndpoints should be invoked
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Times(n uint64) *mClientMockGetOrganizationPrivateEndpoints {
	if n == 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.GetOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations, n)
	return mmGetOrganizationPrivateEndpoints
}

func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmGetOrganizationPrivateEndpoints.expectations) == 0 && mmGetOrganizationPrivateEndpoints.defaultExpectation == nil && mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.mock.afterGetOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationPrivateEndpoints implements Client
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpoints(ctx context.Context) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter, 1)

	if mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints(ctx)
	}

	mm_params := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

	// Record call args
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Lock()
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs = append(mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.GetOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints != nil {
		return mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints(ctx)
	}
	mmGetOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.GetOrganizationPrivateEndpoints. %v", ctx)
	return
}

// GetOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter)
}

// GetOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Calls() []*ClientMockGetOrganizationPrivateEndpointsParams {
	mmGetOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockGetOrganizationPrivateEndpointsParams, len(mmGetOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmGetOrganizationPrivateEndpoints.callArgs)

	mmGetOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationPrivateEndpointsDone returns true if the count of the GetOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsDone() bool {
	if m.GetOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockGetOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsInspect() {
	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterGetOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		if m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetOrganizationPrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints with params: %#v", *m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationPrivateEndpoints != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetOrganizationPrivateEndpoints")
	}

	if !m.GetOrganizationPrivateEndpointsMock.invocationsDone() && afterGetOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrganizationPrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationPrivateEndpointsMock.expectedInvocations), afterGetOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockGetQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetQueryEndpointExpectation
	expectations       []*ClientMockGetQueryEndpointExpectation

	callArgs []*ClientMockGetQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetQueryEndpointExpectation specifies expectation struct of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetQueryEndpointParams
	paramPtrs *ClientMockGetQueryEndpointParamPtrs
	results   *ClientMockGetQueryEndpointResults
	Counter   uint64
}

// ClientMockGetQueryEndpointParams contains parameters of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
}

// ClientMockGetQueryEndpointParamPtrs contains pointers to parameters of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
}

// ClientMockGetQueryEndpointResults contains results of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointResults struct {
	sp1 *ServiceQueryEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Optional() *mClientMockGetQueryEndpoint {
	mmGetQueryEndpoint.optional = true
	return mmGetQueryEndpoint
}

// Expect sets up expected params for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Expect(ctx context.Context, serviceID string) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmGetQueryEndpoint.defaultExpectation.params = &ClientMockGetQueryEndpointParams{ctx, serviceID}
	for _, e := range mmGetQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmGetQueryEndpoint.defaultExpectation.params) {
			mmGetQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmGetQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.params != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Expect")
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockGetQueryEndpointParamPtrs{}
	}
	mmGetQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.params != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Expect")
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockGetQueryEndpointParamPtrs{}
	}
	mmGetQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string)) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.inspectFuncGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.GetQueryEndpoint")
	}

	mmGetQueryEndpoint.mock.inspectFuncGetQueryEndpoint = f

	return mmGetQueryEndpoint
}

// Return sets up results that will be returned by Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Return(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{mock: mmGetQueryEndpoint.mock}
	}
	mmGetQueryEndpoint.defaultExpectation.results = &ClientMockGetQueryEndpointResults{sp1, err}
	return mmGetQueryEndpoint.mock
}

// Set uses given function f to mock the Client.GetQueryEndpoint method
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Set(f func(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error)) *ClientMock {
	if mmGetQueryEndpoint.defaultExpectation != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.GetQueryEndpoint method")
	}

	if len(mmGetQueryEndpoint.expectations) > 0 {
		mmGetQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.GetQueryEndpoint method")
	}

	mmGetQueryEndpoint.mock.funcGetQueryEndpoint = f
	return mmGetQueryEndpoint.mock
}

// When sets expectation for the Client.GetQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) When(ctx context.Context, serviceID string) *ClientMockGetQueryEndpointExpectation {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockGetQueryEndpointExpectation{
		mock:   mmGetQueryEndpoint.mock,
		params: &ClientMockGetQueryEndpointParams{ctx, serviceID},
	}
	mmGetQueryEndpoint.expectations = append(mmGetQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.GetQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockGetQueryEndpointExpectation) Then(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetQueryEndpointResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetQueryEndpoint should be invoked
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Times(n uint64) *mClientMockGetQueryEndpoint {
	if n == 0 {
		mmGetQueryEndpoint.mock.t.Fatalf("Times of ClientMock.GetQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetQueryEndpoint.expectedInvocations, n)
	return mmGetQueryEndpoint
}

func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) invocationsDone() bool {
	if len(mmGetQueryEndpoint.expectations) == 0 && mmGetQueryEndpoint.defaultExpectation == nil && mmGetQueryEndpoint.mock.funcGetQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetQueryEndpoint.mock.afterGetQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetQueryEndpoint implements Client
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpoint(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetQueryEndpoint.beforeGetQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmGetQueryEndpoint.afterGetQueryEndpointCounter, 1)

	if mmGetQueryEndpoint.inspectFuncGetQueryEndpoint != nil {
		mmGetQueryEndpoint.inspectFuncGetQueryEndpoint(ctx, serviceID)
	}

	mm_params := ClientMockGetQueryEndpointParams{ctx, serviceID}

	// Record call args
	mmGetQueryEndpoint.GetQueryEndpointMock.mutex.Lock()
	mmGetQueryEndpoint.GetQueryEndpointMock.callArgs = append(mmGetQueryEndpoint.GetQueryEndpointMock.callArgs, &mm_params)
	mmGetQueryEndpoint.GetQueryEndpointMock.mutex.Unlock()

	for _, e := range mmGetQueryEndpoint.GetQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetQueryEndpointParams{ctx, serviceID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmGetQueryEndpoint.t.Fatal("No results are set for the ClientMock.GetQueryEndpoint")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetQueryEndpoint.funcGetQueryEndpoint != nil {
		return mmGetQueryEndpoint.funcGetQueryEndpoint(ctx, serviceID)
	}
	mmGetQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.GetQueryEndpoint. %v %v", ctx, serviceID)
	return
}

// GetQueryEndpointAfterCounter returns a count of finished ClientMock.GetQueryEndpoint invocations
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQueryEndpoint.afterGetQueryEndpointCounter)
}

// GetQueryEndpointBeforeCounter returns a count of ClientMock.GetQueryEndpoint invocations
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQueryEndpoint.beforeGetQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Calls() []*ClientMockGetQueryEndpointParams {
	mmGetQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockGetQueryEndpointParams, len(mmGetQueryEndpoint.callArgs))
	copy(argCopy, mmGetQueryEndpoint.callArgs)

	mmGetQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockGetQueryEndpointDone returns true if the count of the GetQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetQueryEndpointDone() bool {
	if m.GetQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetQueryEndpointMock.invocationsDone()
}

// MinimockGetQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockGetQueryEndpointInspect() {
	for _, e := range m.GetQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint with params: %#v", *e.params)
		}
	}

	afterGetQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterGetQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetQueryEndpointMock.defaultExpectation != nil && afterGetQueryEndpointCounter < 1 {
		if m.GetQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetQueryEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint with params: %#v", *m.GetQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQueryEndpoint != nil && afterGetQueryEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetQueryEndpoint")
	}

	if !m.GetQueryEndpointMock.invocationsDone() && afterGetQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetQueryEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.GetQueryEndpointMock.expectedInvocations), afterGetQueryEndpointCounter)
	}
}

type mClientMockGetService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetServiceExpectation
	expectations       []*ClientMockGetServiceExpectation

	callArgs []*ClientMockGetServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetServiceExpectation specifies expectation struct of the Client.GetService
type ClientMockGetServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetServiceParams
	paramPtrs *ClientMockGetServiceParamPtrs
	results   *ClientMockGetServiceResults
	Counter   uint64
}

// ClientMockGetServiceParams contains parameters of the Client.GetService
type ClientMockGetServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetServiceParamPtrs contains pointers to parameters of the Client.GetService
type ClientMockGetServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetServiceResults contains results of the Client.GetService
type ClientMockGetServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetService *mClientMockGetService) Optional() *mClientMockGetService {
	mmGetService.optional = true
	return mmGetService
}

// Expect sets up expected params for Client.GetService
func (mmGetService *mClientMockGetService) Expect(ctx context.Context, serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.paramPtrs != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by ExpectParams functions")
	}

	mmGetService.defaultExpectation.params = &ClientMockGetServiceParams{ctx, serviceId}
	for _, e := range mmGetService.expectations {
		if minimock.Equal(e.params, mmGetService.defaultExpectation.params) {
			mmGetService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetService.defaultExpectation.params)
		}
	}

	return mmGetService
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetService
func (mmGetService *mClientMockGetService) ExpectCtxParam1(ctx context.Context) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetService
func (mmGetService *mClientMockGetService) ExpectServiceIdParam2(serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetService
}

// Inspect accepts an inspector function that has same arguments as the Client.GetService
func (mmGetService *mClientMockGetService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetService {
	if mmGetService.mock.inspectFuncGetService != nil {
		mmGetService.mock.t.Fatalf("Inspect function is already set for ClientMock.GetService")
	}

	mmGetService.mock.inspectFuncGetService = f

	return mmGetService
}

// Return sets up results that will be returned by Client.GetService
func (mmGetService *mClientMockGetService) Return(sp1 *Service, err error) *ClientMock {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{mock: mmGetService.mock}
	}
	mmGetService.defaultExpectation.results = &ClientMockGetServiceResults{sp1, err}
	return mmGetService.mock
}

// Set uses given function f to mock the Client.GetService method
func (mmGetService *mClientMockGetService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmGetService.defaultExpectation != nil {
		mmGetService.mock.t.Fatalf("Default expectation is already set for the Client.GetService method")
	}

	if len(mmGetService.expectations) > 0 {
		mmGetService.mock.t.Fatalf("Some expectations are already set for the Client.GetService method")
	}

	mmGetService.mock.funcGetService = f
	return mmGetService.mock
}

// When sets expectation for the Client.GetService which will trigger the result defined by the following
// Then helper
func (mmGetService *mClientMockGetService) When(ctx context.Context, serviceId string) *ClientMockGetServiceExpectation {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	expectation := &ClientMockGetServiceExpectation{
		mock:   mmGetService.mock,
		params: &ClientMockGetServiceParams{ctx, serviceId},
	}
	mmGetService.expectations = append(mmGetService.expectations, expectation)
	return expectation
}

// Then sets up Client.GetService return parameters for the expectation previously defined by the When method
func (e *ClientMockGetServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockGetServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetService should be invoked
func (mmGetService *mClientMockGetService) Times(n uint64) *mClientMockGetService {
	if n == 0 {
		mmGetService.mock.t.Fatalf("Times of ClientMock.GetService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetService.expectedInvocations, n)
	return mmGetService
}

func (mmGetService *mClientMockGetService) invocationsDone() bool {
	if len(mmGetService.expectations) == 0 && mmGetService.defaultExpectation == nil && mmGetService.mock.funcGetService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetService.mock.afterGetServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetService implements Client
func (mmGetService *ClientMock) GetService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmGetService.beforeGetServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetService.afterGetServiceCounter, 1)

	if mmGetService.inspectFuncGetService != nil {
		mmGetService.inspectFuncGetService(ctx, serviceId)
	}

	mm_params := ClientMockGetServiceParams{ctx, serviceId}

	// Record call args
	mmGetService.GetServiceMock.mutex.Lock()
	mmGetService.GetServiceMock.callArgs = append(mmGetService.GetServiceMock.callArgs, &mm_params)
	mmGetService.GetServiceMock.mutex.Unlock()

	for _, e := range mmGetService.GetServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetService.GetServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetService.GetServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetService.GetServiceMock.defaultExpectation.params
		mm_want_ptrs := mmGetService.GetServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetService.t.Errorf("ClientMock.GetService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetService.GetServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetService.t.Fatal("No results are set for the ClientMock.GetService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetService.funcGetService != nil {
		return mmGetService.funcGetService(ctx, serviceId)
	}
	mmGetService.t.Fatalf("Unexpected call to ClientMock.GetService. %v %v", ctx, serviceId)
	return
}

// GetServiceAfterCounter returns a count of finished ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.afterGetServiceCounter)
}

// GetServiceBeforeCounter returns a count of ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.beforeGetServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetService *mClientMockGetService) Calls() []*ClientMockGetServiceParams {
	mmGetService.mutex.RLock()

	argCopy := make([]*ClientMockGetServiceParams, len(mmGetService.callArgs))
	copy(argCopy, mmGetService.callArgs)

	mmGetService.mutex.RUnlock()

	return argCopy
}

// MinimockGetServiceDone returns true if the count of the GetService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetServiceDone() bool {
	if m.GetServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetServiceMock.invocationsDone()
}

// MinimockGetServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockGetServiceInspect() {
	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetService with params: %#v", *e.params)
		}
	}

	afterGetServiceCounter := mm_atomic.LoadUint64(&m.afterGetServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetServiceMock.defaultExpectation != nil && afterGetServiceCounter < 1 {
		if m.GetServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetService")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetService with params: %#v", *m.GetServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetService != nil && afterGetServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetService")
	}

	if !m.GetServiceMock.invocationsDone() && afterGetServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetService but found %d calls",
			mm_atomic.LoadUint64(&m.GetServiceMock.expectedInvocations), afterGetServiceCounter)
	}
}

type mClientMockGetUser struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetUserExpectation
	expectations       []*ClientMockGetUserExpectation

	callArgs []*ClientMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetUserExpectation specifies expectation struct of the Client.GetUser
type ClientMockGetUserExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetUserParams
	paramPtrs *ClientMockGetUserParamPtrs
	results   *ClientMockGetUserResults
	Counter   uint64
}

// ClientMockGetUserParams contains parameters of the Client.GetUser
type ClientMockGetUserParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockGetUserParamPtrs contains pointers to parameters of the Client.GetUser
type ClientMockGetUserParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockGetUserResults contains results of the Client.GetUser
type ClientMockGetUserResults struct {
	up1 *User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mClientMockGetUser) Optional() *mClientMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Client.GetUser
func (mmGetUser *mClientMockGetUser) Expect(ctx context.Context, serviceID string, name string) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &ClientMockGetUserParams{ctx, serviceID, name}
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetUser
func (mmGetUser *mClientMockGetUser) ExpectCtxParam1(ctx context.Context) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ClientMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetUser
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetUser
func (mmGetUser *mClientMockGetUser) ExpectServiceIDParam2(serviceID string) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ClientMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetUser
}

// ExpectNameParam3 sets up expected param name for Client.GetUser
func (mmGetUser *mClientMockGetUser) ExpectNameParam3(name string) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ClientMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.name = &name

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Client.GetUser
func (mmGetUser *mClientMockGetUser) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for ClientMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Client.GetUser
func (mmGetUser *mClientMockGetUser) Return(up1 *User, err error) *ClientMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &ClientMockGetUserResults{up1, err}
	return mmGetUser.mock
}

// Set uses given function f to mock the Client.GetUser method
func (mmGetUser *mClientMockGetUser) Set(f func(ctx context.Context, serviceID string, name string) (up1 *User, err error)) *ClientMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Client.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Client.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// When sets expectation for the Client.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mClientMockGetUser) When(ctx context.Context, serviceID string, name string) *ClientMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	expectation := &ClientMockGetUserExpectation{
		mock:   mmGetUser.mock,
		params: &ClientMockGetUserParams{ctx, serviceID, name},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Client.GetUser return parameters for the expectation previously defined by the When method
func (e *ClientMockGetUserExpectation) Then(up1 *User, err error) *ClientMock {
	e.results = &ClientMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times Client.GetUser should be invoked
func (mmGetUser *mClientMockGetUser) Times(n uint64) *mClientMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of ClientMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	return mmGetUser
}

func (mmGetUser *mClientMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements Client
func (mmGetUser *ClientMock) GetUser(ctx context.Context, serviceID string, name string) (up1 *User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, serviceID, name)
	}

	mm_params := ClientMockGetUserParams{ctx, serviceID, name}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetUserParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the ClientMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, serviceID, name)
	}
	mmGetUser.t.Fatalf("Unexpected call to ClientMock.GetUser. %v %v %v", ctx, serviceID, name)
	return
}

// GetUserAfterCounter returns a count of finished ClientMock.GetUser invocations
func (mmGetUser *ClientMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of ClientMock.GetUser invocations
func (mmGetUser *ClientMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mClientMockGetUser) Calls() []*ClientMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*ClientMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *ClientMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetUser with params: %#v", *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetUser")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetUser")
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetUser but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), afterGetUserCounter)
	}
}

type mClientMockScalingClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockScalingClickPipeExpectation
	expectations       []*ClientMockScalingClickPipeExpectation

	callArgs []*ClientMockScalingClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockScalingClickPipeExpectation specifies expectation struct of the Client.ScalingClickPipe
type ClientMockScalingClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockScalingClickPipeParams
	paramPtrs *ClientMockScalingClickPipeParamPtrs
	results   *ClientMockScalingClickPipeResults
	Counter   uint64
}

// ClientMockScalingClickPipeParams contains parameters of the Client.ScalingClickPipe
type ClientMockScalingClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	request     ClickPipeScaling
}

// ClientMockScalingClickPipeParamPtrs contains pointers to parameters of the Client.ScalingClickPipe
type ClientMockScalingClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	request     *ClickPipeScaling
}

// ClientMockScalingClickPipeResults contains results of the Client.ScalingClickPipe
type ClientMockScalingClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScalingClickPipe *mClientMockScalingClickPipe) Optional() *mClientMockScalingClickPipe {
	mmScalingClickPipe.optional = true
	return mmScalingClickPipe
}

// Expect sets up expected params for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by ExpectParams functions")
	}

	mmScalingClickPipe.defaultExpectation.params = &ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}
	for _, e := range mmScalingClickPipe.expectations {
		if minimock.Equal(e.params, mmScalingClickPipe.defaultExpectation.params) {
			mmScalingClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScalingClickPipe.defaultExpectation.params)
		}
	}

	return mmScalingClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmScalingClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmScalingClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmScalingClickPipe
}

// ExpectRequestParam4 sets up expected param request for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectRequestParam4(request ClickPipeScaling) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.request = &request

	return mmScalingClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling)) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.inspectFuncScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.ScalingClickPipe")
	}

	mmScalingClickPipe.mock.inspectFuncScalingClickPipe = f

	return mmScalingClickPipe
}

// Return sets up results that will be returned by Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{mock: mmScalingClickPipe.mock}
	}
	mmScalingClickPipe.defaultExpectation.results = &ClientMockScalingClickPipeResults{cp1, err}
	return mmScalingClickPipe.mock
}

// Set uses given function f to mock the Client.ScalingClickPipe method
func (mmScalingClickPipe *mClientMockScalingClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmScalingClickPipe.defaultExpectation != nil {
		mmScalingClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.ScalingClickPipe method")
	}

	if len(mmScalingClickPipe.expectations) > 0 {
		mmScalingClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.ScalingClickPipe method")
	}

	mmScalingClickPipe.mock.funcScalingClickPipe = f
	return mmScalingClickPipe.mock
}

// When sets expectation for the Client.ScalingClickPipe which will trigger the result defined by the following
// Then helper
func (mmScalingClickPipe *mClientMockScalingClickPipe) When(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) *ClientMockScalingClickPipeExpectation {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	expectation := &ClientMockScalingClickPipeExpectation{
		mock:   mmScalingClickPipe.mock,
		params: &ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request},
	}
	mmScalingClickPipe.expectations = append(mmScalingClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.ScalingClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockScalingClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockScalingClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ScalingClickPipe should be invoked
func (mmScalingClickPipe *mClientMockScalingClickPipe) Times(n uint64) *mClientMockScalingClickPipe {
	if n == 0 {
		mmScalingClickPipe.mock.t.Fatalf("Times of ClientMock.ScalingClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScalingClickPipe.expectedInvocations, n)
	return mmScalingClickPipe
}

func (mmScalingClickPipe *mClientMockScalingClickPipe) invocationsDone() bool {
	if len(mmScalingClickPipe.expectations) == 0 && mmScalingClickPipe.defaultExpectation == nil && mmScalingClickPipe.mock.funcScalingClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScalingClickPipe.mock.afterScalingClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScalingClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScalingClickPipe implements Client
func (mmScalingClickPipe *ClientMock) ScalingClickPipe(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmScalingClickPipe.beforeScalingClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmScalingClickPipe.afterScalingClickPipeCounter, 1)

	if mmScalingClickPipe.inspectFuncScalingClickPipe != nil {
		mmScalingClickPipe.inspectFuncScalingClickPipe(ctx, serviceId, clickPipeId, request)
	}

	mm_params := ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}

	// Record call args
	mmScalingClickPipe.ScalingClickPipeMock.mutex.Lock()
	mmScalingClickPipe.ScalingClickPipeMock.callArgs = append(mmScalingClickPipe.ScalingClickPipeMock.callArgs, &mm_params)
	mmScalingClickPipe.ScalingClickPipeMock.mutex.Unlock()

	for _, e := range mmScalingClickPipe.ScalingClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter request, want: %#v, got: %#v%s\n", *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmScalingClickPipe.t.Fatal("No results are set for the ClientMock.ScalingClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmScalingClickPipe.funcScalingClickPipe != nil {
		return mmScalingClickPipe.funcScalingClickPipe(ctx, serviceId, clickPipeId, request)
	}
	mmScalingClickPipe.t.Fatalf("Unexpected call to ClientMock.ScalingClickPipe. %v %v %v %v", ctx, serviceId, clickPipeId, request)
	return
}

// ScalingClickPipeAfterCounter returns a count of finished ClientMock.ScalingClickPipe invocations
func (mmScalingClickPipe *ClientMock) ScalingClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScalingClickPipe.afterScalingClickPipeCounter)
}

// ScalingClickPipeBeforeCounter returns a count of ClientMock.ScalingClickPipe invocations
func (mmScalingClickPipe *ClientMock) ScalingClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScalingClickPipe.beforeScalingClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ScalingClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScalingClickPipe *mClientMockScalingClickPipe) Calls() []*ClientMockScalingClickPipeParams {
	mmScalingClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockScalingClickPipeParams, len(mmScalingClickPipe.callArgs))
	copy(argCopy, mmScalingClickPipe.callArgs)

	mmScalingClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockScalingClickPipeDone returns true if the count of the ScalingClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockScalingClickPipeDone() bool {
	if m.ScalingClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScalingClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScalingClickPipeMock.invocationsDone()
}

// MinimockScalingClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockScalingClickPipeInspect() {
	for _, e := range m.ScalingClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe with params: %#v", *e.params)
		}
	}

	afterScalingClickPipeCounter := mm_atomic.LoadUint64(&m.afterScalingClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScalingClickPipeMock.defaultExpectation != nil && afterScalingClickPipeCounter < 1 {
		if m.ScalingClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ScalingClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe with params: %#v", *m.ScalingClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScalingClickPipe != nil && afterScalingClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.ScalingClickPipe")
	}

	if !m.ScalingClickPipeMock.invocationsDone() && afterScalingClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ScalingClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.ScalingClickPipeMock.expectedInvocations), afterScalingClickPipeCounter)
	}
}

type mClientMockUpdateBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateBackupConfigurationExpectation
	expectations       []*ClientMockUpdateBackupConfigurationExpectation

	callArgs []*ClientMockUpdateBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateBackupConfigurationExpectation specifies expectation struct of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateBackupConfigurationParams
	paramPtrs *ClientMockUpdateBackupConfigurationParamPtrs
	results   *ClientMockUpdateBackupConfigurationResults
	Counter   uint64
}

// ClientMockUpdateBackupConfigurationParams contains parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
	b         BackupConfiguration
}

// ClientMockUpdateBackupConfigurationParamPtrs contains pointers to parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	b         *BackupConfiguration
}

// ClientMockUpdateBackupConfigurationResults contains results of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Optional() *mClientMockUpdateBackupConfiguration {
	mmUpdateBackupConfiguration.optional = true
	return mmUpdateBackupConfiguration
}

// Expect sets up expected params for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Expect(ctx context.Context, serviceId string, b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmUpdateBackupConfiguration.defaultExpectation.params = &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}
	for _, e := range mmUpdateBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmUpdateBackupConfiguration.defaultExpectation.params) {
			mmUpdateBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmUpdateBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateBackupConfiguration
}

// ExpectBParam3 sets up expected param b for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectBParam3(b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.b = &b

	return mmUpdateBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string, b BackupConfiguration)) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateBackupConfiguration")
	}

	mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration = f

	return mmUpdateBackupConfiguration
}

// Return sets up results that will be returned by Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{mock: mmUpdateBackupConfiguration.mock}
	}
	mmUpdateBackupConfiguration.defaultExpectation.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return mmUpdateBackupConfiguration.mock
}

// Set uses given function f to mock the Client.UpdateBackupConfiguration method
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Set(f func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmUpdateBackupConfiguration.defaultExpectation != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.UpdateBackupConfiguration method")
	}

	if len(mmUpdateBackupConfiguration.expectations) > 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.UpdateBackupConfiguration method")
	}

	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration = f
	return mmUpdateBackupConfiguration.mock
}

// When sets expectation for the Client.UpdateBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) When(ctx context.Context, serviceId string, b BackupConfiguration) *ClientMockUpdateBackupConfigurationExpectation {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockUpdateBackupConfigurationExpectation{
		mock:   mmUpdateBackupConfiguration.mock,
		params: &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b},
	}
	mmUpdateBackupConfiguration.expectations = append(mmUpdateBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateBackupConfiguration should be invoked
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Times(n uint64) *mClientMockUpdateBackupConfiguration {
	if n == 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Times of ClientMock.UpdateBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateBackupConfiguration.expectedInvocations, n)
	return mmUpdateBackupConfiguration
}

func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) invocationsDone() bool {
	if len(mmUpdateBackupConfiguration.expectations) == 0 && mmUpdateBackupConfiguration.defaultExpectation == nil && mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.mock.afterUpdateBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateBackupConfiguration implements Client
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfiguration(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter, 1)

	if mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration(ctx, serviceId, b)
	}

	mm_params := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

	// Record call args
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Lock()
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs = append(mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs, &mm_params)
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter b, want: %#v, got: %#v%s\n", *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBackupConfiguration.t.Fatal("No results are set for the ClientMock.UpdateBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmUpdateBackupConfiguration.funcUpdateBackupConfiguration != nil {
		return mmUpdateBackupConfiguration.funcUpdateBackupConfiguration(ctx, serviceId, b)
	}
	mmUpdateBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.UpdateBackupConfiguration. %v %v %v", ctx, serviceId, b)
	return
}

// UpdateBackupConfigurationAfterCounter returns a count of finished ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter)
}

// UpdateBackupConfigurationBeforeCounter returns a count of ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Calls() []*ClientMockUpdateBackupConfigurationParams {
	mmUpdateBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockUpdateBackupConfigurationParams, len(mmUpdateBackupConfiguration.callArgs))
	copy(argCopy, mmUpdateBackupConfiguration.callArgs)

	mmUpdateBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBackupConfigurationDone returns true if the count of the UpdateBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateBackupConfigurationDone() bool {
	if m.UpdateBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateBackupConfigurationMock.invocationsDone()
}

// MinimockUpdateBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateBackupConfigurationInspect() {
	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration with params: %#v", *e.params)
		}
	}

	afterUpdateBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterUpdateBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBackupConfigurationMock.defaultExpectation != nil && afterUpdateBackupConfigurationCounter < 1 {
		if m.UpdateBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateBackupConfiguration")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration with params: %#v", *m.UpdateBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBackupConfiguration != nil && afterUpdateBackupConfigurationCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateBackupConfiguration")
	}

	if !m.UpdateBackupConfigurationMock.invocationsDone() && afterUpdateBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateBackupConfiguration but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateBackupConfigurationMock.expectedInvocations), afterUpdateBackupConfigurationCounter)
	}
}

type mClientMockUpdateOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockUpdateOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockUpdateOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateOrganizationPrivateEndpointsParams
	paramPtrs *ClientMockUpdateOrganizationPrivateEndpointsParamPtrs
	results   *ClientMockUpdateOrganizationPrivateEndpointsResults
	Counter   uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsParams contains parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParams struct {
	ctx       context.Context
	orgUpdate OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	orgUpdate *OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsResults contains results of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Optional() *mClientMockUpdateOrganizationPrivateEndpoints {
	mmUpdateOrganizationPrivateEndpoints.optional = true
	return mmUpdateOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Expect(ctx context.Context, orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}
	for _, e := range mmUpdateOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectOrgUpdateParam2 sets up expected param orgUpdate for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectOrgUpdateParam2(orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.orgUpdate = &orgUpdate

	return mmUpdateOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context, orgUpdate OrganizationUpdate)) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints = f

	return mmUpdateOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{mock: mmUpdateOrganizationPrivateEndpoints.mock}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.UpdateOrganizationPrivateEndpoints method
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Set(f func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	if len(mmUpdateOrganizationPrivateEndpoints.expectations) > 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints = f
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.UpdateOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) When(ctx context.Context, orgUpdate OrganizationUpdate) *ClientMockUpdateOrganizationPrivateEndpointsExpectation {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockUpdateOrganizationPrivateEndpointsExpectation{
		mock:   mmUpdateOrganizationPrivateEndpoints.mock,
		params: &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate},
	}
	mmUpdateOrganizationPrivateEndpoints.expectations = append(mmUpdateOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.UpdateOrganizationPrivateEndpoints should be invoked
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Times(n uint64) *mClientMockUpdateOrganizationPrivateEndpoints {
	if n == 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.UpdateOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations, n)
	return mmUpdateOrganizationPrivateEndpoints
}

func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmUpdateOrganizationPrivateEndpoints.expectations) == 0 && mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil && mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.mock.afterUpdateOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrganizationPrivateEndpoints implements Client
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpoints(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter, 1)

	if mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}

	mm_params := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

	// Record call args
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Lock()
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs = append(mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orgUpdate != nil && !minimock.Equal(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter orgUpdate, want: %#v, got: %#v%s\n", *mm_want_ptrs.orgUpdate, mm_got.orgUpdate, minimock.Diff(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.UpdateOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints != nil {
		return mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}
	mmUpdateOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.UpdateOrganizationPrivateEndpoints. %v %v", ctx, orgUpdate)
	return
}

// UpdateOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter)
}

// UpdateOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Calls() []*ClientMockUpdateOrganizationPrivateEndpointsParams {
	mmUpdateOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockUpdateOrganizationPrivateEndpointsParams, len(mmUpdateOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmUpdateOrganizationPrivateEndpoints.callArgs)

	mmUpdateOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrganizationPrivateEndpointsDone returns true if the count of the UpdateOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsDone() bool {
	if m.UpdateOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockUpdateOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsInspect() {
	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterUpdateOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterUpdateOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints with params: %#v", *m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrganizationPrivateEndpoints != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	if !m.UpdateOrganizationPrivateEndpointsMock.invocationsDone() && afterUpdateOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateOrganizationPrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrganizationPrivateEndpointsMock.expectedInvocations), afterUpdateOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockUpdateReplicaScaling struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateReplicaScalingExpectation
	expectations       []*ClientMockUpdateReplicaScalingExpectation

	callArgs []*ClientMockUpdateReplicaScalingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateReplicaScalingExpectation specifies expectation struct of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateReplicaScalingParams
	paramPtrs *ClientMockUpdateReplicaScalingParamPtrs
	results   *ClientMockUpdateReplicaScalingResults
	Counter   uint64
}

// ClientMockUpdateReplicaScalingParams contains parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParams struct {
	ctx       context.Context
	serviceId string
	s         ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingParamPtrs contains pointers to parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingResults contains results of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Optional() *mClientMockUpdateReplicaScaling {
	mmUpdateReplicaScaling.optional = true
	return mmUpdateReplicaScaling
}

// Expect sets up expected params for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Expect(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by ExpectParams functions")
	}

	mmUpdateReplicaScaling.defaultExpectation.params = &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}
	for _, e := range mmUpdateReplicaScaling.expectations {
		if minimock.Equal(e.params, mmUpdateReplicaScaling.defaultExpectation.params) {
			mmUpdateReplicaScaling.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReplicaScaling.defaultExpectation.params)
		}
	}

	return mmUpdateReplicaScaling
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateReplicaScaling
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateReplicaScaling
}

// ExpectSParam3 sets up expected param s for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectSParam3(s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.s = &s

	return mmUpdateReplicaScaling
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Inspect(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateReplicaScaling")
	}

	mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling = f

	return mmUpdateReplicaScaling
}

// Return sets up results that will be returned by Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{mock: mmUpdateReplicaScaling.mock}
	}
	mmUpdateReplicaScaling.defaultExpectation.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return mmUpdateReplicaScaling.mock
}

// Set uses given function f to mock the Client.UpdateReplicaScaling method
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Set(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateReplicaScaling.defaultExpectation != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Default expectation is already set for the Client.UpdateReplicaScaling method")
	}

	if len(mmUpdateReplicaScaling.expectations) > 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Some expectations are already set for the Client.UpdateReplicaScaling method")
	}

	mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling = f
	return mmUpdateReplicaScaling.mock
}

// When sets expectation for the Client.UpdateReplicaScaling which will trigger the result defined by the following
// Then helper
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) When(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *ClientMockUpdateReplicaScalingExpectation {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	expectation := &ClientMockUpdateReplicaScalingExpectation{
		mock:   mmUpdateReplicaScaling.mock,
		params: &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s},
	}
	mmUpdateReplicaScaling.expectations = append(mmUpdateReplicaScaling.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateReplicaScaling return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateReplicaScalingExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateReplicaScaling should be invoked
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Times(n uint64) *mClientMockUpdateReplicaScaling {
	if n == 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Times of ClientMock.UpdateReplicaScaling mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReplicaScaling.expectedInvocations, n)
	return mmUpdateReplicaScaling
}

func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) invocationsDone() bool {
	if len(mmUpdateReplicaScaling.expectations) == 0 && mmUpdateReplicaScaling.defaultExpectation == nil && mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.mock.afterUpdateReplicaScalingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReplicaScaling implements Client
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScaling(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter, 1)

	if mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

	// Record call args
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Lock()
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs = append(mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs, &mm_params)
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Unlock()

	for _, e := range mmUpdateReplicaScaling.UpdateReplicaScalingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReplicaScaling.t.Fatal("No results are set for the ClientMock.UpdateReplicaScaling")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateReplicaScaling.funcUpdateReplicaScaling != nil {
		return mmUpdateReplicaScaling.funcUpdateReplicaScaling(ctx, serviceId, s)
	}
	mmUpdateReplicaScaling.t.Fatalf("Unexpected call to ClientMock.UpdateReplicaScaling. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateReplicaScalingAfterCounter returns a count of finished ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter)
}

// UpdateReplicaScalingBeforeCounter returns a count of ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateReplicaScaling.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Calls() []*ClientMockUpdateReplicaScalingParams {
	mmUpdateReplicaScaling.mutex.RLock()

	argCopy := make([]*ClientMockUpdateReplicaScalingParams, len(mmUpdateReplicaScaling.callArgs))
	copy(argCopy, mmUpdateReplicaScaling.callArgs)

	mmUpdateReplicaScaling.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReplicaScalingDone returns true if the count of the UpdateReplicaScaling invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateReplicaScalingDone() bool {
	if m.UpdateReplicaScalingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReplicaScalingMock.invocationsDone()
}

// MinimockUpdateReplicaScalingInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateReplicaScalingInspect() {
	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling with params: %#v", *e.params)
		}
	}

	afterUpdateReplicaScalingCounter := mm_atomic.LoadUint64(&m.afterUpdateReplicaScalingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReplicaScalingMock.defaultExpectation != nil && afterUpdateReplicaScalingCounter < 1 {
		if m.UpdateReplicaScalingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateReplicaScaling")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling with params: %#v", *m.UpdateReplicaScalingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReplicaScaling != nil && afterUpdateReplicaScalingCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateReplicaScaling")
	}

	if !m.UpdateReplicaScalingMock.invocationsDone() && afterUpdateReplicaScalingCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateReplicaScaling but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReplicaScalingMock.expectedInvocations), afterUpdateReplicaScalingCounter)
	}
}

type mClientMockUpdateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServiceExpectation
	expectations       []*ClientMockUpdateServiceExpectation

	callArgs []*ClientMockUpdateServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateServiceExpectation specifies expectation struct of the Client.UpdateService
type ClientMockUpdateServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateServiceParams
	paramPtrs *ClientMockUpdateServiceParamPtrs
	results   *ClientMockUpdateServiceResults
	Counter   uint64
}

// ClientMockUpdateServiceParams contains parameters of the Client.UpdateService
type ClientMockUpdateServiceParams struct {
	ctx       context.Context
	serviceId string
	s         ServiceUpdate
}

// ClientMockUpdateServiceParamPtrs contains pointers to parameters of the Client.UpdateService
type ClientMockUpdateServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ServiceUpdate
}

// ClientMockUpdateServiceResults contains results of the Client.UpdateService
type ClientMockUpdateServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateService *mClientMockUpdateService) Optional() *mClientMockUpdateService {
	mmUpdateService.optional = true
	return mmUpdateService
}

// Expect sets up expected params for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Expect(ctx context.Context, serviceId string, s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.paramPtrs != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by ExpectParams functions")
	}

	mmUpdateService.defaultExpectation.params = &ClientMockUpdateServiceParams{ctx, serviceId, s}
	for _, e := range mmUpdateService.expectations {
		if minimock.Equal(e.params, mmUpdateService.defaultExpectation.params) {
			mmUpdateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateService.defaultExpectation.params)
		}
	}

	return mmUpdateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateService
}

// ExpectSParam3 sets up expected param s for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectSParam3(s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.s = &s

	return mmUpdateService
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Inspect(f func(ctx context.Context, serviceId string, s ServiceUpdate)) *mClientMockUpdateService {
	if mmUpdateService.mock.inspectFuncUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateService")
	}

	mmUpdateService.mock.inspectFuncUpdateService = f

	return mmUpdateService
}

// Return sets up results that will be returned by Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{mock: mmUpdateService.mock}
	}
	mmUpdateService.defaultExpectation.results = &ClientMockUpdateServiceResults{sp1, err}
	return mmUpdateService.mock
}

// Set uses given function f to mock the Client.UpdateService method
func (mmUpdateService *mClientMockUpdateService) Set(f func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateService.defaultExpectation != nil {
		mmUpdateService.mock.t.Fatalf("Default expectation is already set for the Client.UpdateService method")
	}

	if len(mmUpdateService.expectations) > 0 {
		mmUpdateService.mock.t.Fatalf("Some expectations are already set for the Client.UpdateService method")
	}

	mmUpdateService.mock.funcUpdateService = f
	return mmUpdateService.mock
}

// When sets expectation for the Client.UpdateService which will trigger the result defined by the following
// Then helper
func (mmUpdateService *mClientMockUpdateService) When(ctx context.Context, serviceId string, s ServiceUpdate) *ClientMockUpdateServiceExpectation {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	expectation := &ClientMockUpdateServiceExpectation{
		mock:   mmUpdateService.mock,
		params: &ClientMockUpdateServiceParams{ctx, serviceId, s},
	}
	mmUpdateService.expectations = append(mmUpdateService.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateService return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateService should be invoked
func (mmUpdateService *mClientMockUpdateService) Times(n uint64) *mClientMockUpdateService {
	if n == 0 {
		mmUpdateService.mock.t.Fatalf("Times of ClientMock.UpdateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateService.expectedInvocations, n)
	return mmUpdateService
}

func (mmUpdateService *mClientMockUpdateService) invocationsDone() bool {
	if len(mmUpdateService.expectations) == 0 && mmUpdateService.defaultExpectation == nil && mmUpdateService.mock.funcUpdateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateService.mock.afterUpdateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateService implements Client
func (mmUpdateService *ClientMock) UpdateService(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateService.beforeUpdateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateService.afterUpdateServiceCounter, 1)

	if mmUpdateService.inspectFuncUpdateService != nil {
		mmUpdateService.inspectFuncUpdateService(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateServiceParams{ctx, serviceId, s}

	// Record call args
	mmUpdateService.UpdateServiceMock.mutex.Lock()
	mmUpdateService.UpdateServiceMock.callArgs = append(mmUpdateService.UpdateServiceMock.callArgs, &mm_params)
	mmUpdateService.UpdateServiceMock.mutex.Unlock()

	for _, e := range mmUpdateService.UpdateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateService.UpdateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateService.UpdateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateService.UpdateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateService.UpdateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServiceParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateService.UpdateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateService.t.Fatal("No results are set for the ClientMock.UpdateService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateService.funcUpdateService != nil {
		return mmUpdateService.funcUpdateService(ctx, serviceId, s)
	}
	mmUpdateService.t.Fatalf("Unexpected call to ClientMock.UpdateService. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateServiceAfterCounter returns a count of finished ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.afterUpdateServiceCounter)
}

// UpdateServiceBeforeCounter returns a count of ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.beforeUpdateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateService *mClientMockUpdateService) Calls() []*ClientMockUpdateServiceParams {
	mmUpdateService.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServiceParams, len(mmUpdateService.callArgs))
	copy(argCopy, mmUpdateService.callArgs)

	mmUpdateService.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServiceDone returns true if the count of the UpdateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServiceDone() bool {
	if m.UpdateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServiceMock.invocationsDone()
}

// MinimockUpdateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServiceInspect() {
	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateService with params: %#v", *e.params)
		}
	}

	afterUpdateServiceCounter := mm_atomic.LoadUint64(&m.afterUpdateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServiceMock.defaultExpectation != nil && afterUpdateServiceCounter < 1 {
		if m.UpdateServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateService")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateService with params: %#v", *m.UpdateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateService != nil && afterUpdateServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateService")
	}

	if !m.UpdateServiceMock.invocationsDone() && afterUpdateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateService but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServiceMock.expectedInvocations), afterUpdateServiceCounter)
	}
}

type mClientMockUpdateServicePassword struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServicePasswordExpectation
	expectations       []*ClientMockUpdateServicePasswordExpectation

	callArgs []*ClientMockUpdateServicePasswordParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateServicePasswordExpectation specifies expectation struct of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateServicePasswordParams
	paramPtrs *ClientMockUpdateServicePasswordParamPtrs
	results   *ClientMockUpdateServicePasswordResults
	Counter   uint64
}

// ClientMockUpdateServicePasswordParams contains parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParams struct {
	ctx       context.Context
	serviceId string
	u         ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordParamPtrs contains pointers to parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	u         *ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordResults contains results of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordResults struct {
	sp1 *ServicePasswordUpdateResult
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Optional() *mClientMockUpdateServicePassword {
	mmUpdateServicePassword.optional = true
	return mmUpdateServicePassword
}

// Expect sets up expected params for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Expect(ctx context.Context, serviceId string, u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by ExpectParams functions")
	}

	mmUpdateServicePassword.defaultExpectation.params = &ClientMockUpdateServicePasswordParams{ctx, serviceId, u}
	for _, e := range mmUpdateServicePassword.expectations {
		if minimock.Equal(e.params, mmUpdateServicePassword.defaultExpectation.params) {
			mmUpdateServicePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateServicePassword.defaultExpectation.params)
		}
	}

	return mmUpdateServicePassword
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateServicePassword
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateServicePassword
}

// ExpectUParam3 sets up expected param u for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectUParam3(u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.u = &u

	return mmUpdateServicePassword
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Inspect(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate)) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateServicePassword")
	}

	mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword = f

	return mmUpdateServicePassword
}

// Return sets up results that will be returned by Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Return(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{mock: mmUpdateServicePassword.mock}
	}
	mmUpdateServicePassword.defaultExpectation.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return mmUpdateServicePassword.mock
}

// Set uses given function f to mock the Client.UpdateServicePassword method
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Set(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)) *ClientMock {
	if mmUpdateServicePassword.defaultExpectation != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Default expectation is already set for the Client.UpdateServicePassword method")
	}

	if len(mmUpdateServicePassword.expectations) > 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Some expectations are already set for the Client.UpdateServicePassword method")
	}

	mmUpdateServicePassword.mock.funcUpdateServicePassword = f
	return mmUpdateServicePassword.mock
}

// When sets expectation for the Client.UpdateServicePassword which will trigger the result defined by the following
// Then helper
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) When(ctx context.Context, serviceId string, u ServicePasswordUpdate) *ClientMockUpdateServicePasswordExpectation {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	expectation := &ClientMockUpdateServicePasswordExpectation{
		mock:   mmUpdateServicePassword.mock,
		params: &ClientMockUpdateServicePasswordParams{ctx, serviceId, u},
	}
	mmUpdateServicePassword.expectations = append(mmUpdateServicePassword.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateServicePassword return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServicePasswordExpectation) Then(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	e.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateServicePassword should be invoked
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Times(n uint64) *mClientMockUpdateServicePassword {
	if n == 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Times of ClientMock.UpdateServicePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateServicePassword.expectedInvocations, n)
	return mmUpdateServicePassword
}

func (mmUpdateServicePassword *mClientMockUpdateServicePassword) invocationsDone() bool {
	if len(mmUpdateServicePassword.expectations) == 0 && mmUpdateServicePassword.defaultExpectation == nil && mmUpdateServicePassword.mock.funcUpdateServicePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.mock.afterUpdateServicePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateServicePassword implements Client
func (mmUpdateServicePassword *ClientMock) UpdateServicePassword(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error) {
	mm_atomic.AddUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter, 1)

	if mmUpdateServicePassword.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.inspectFuncUpdateServicePassword(ctx, serviceId, u)
	}

	mm_params := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

	// Record call args
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Lock()
	mmUpdateServicePassword.UpdateServicePasswordMock.callArgs = append(mmUpdateServicePassword.UpdateServicePasswordMock.callArgs, &mm_params)
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Unlock()

	for _, e := range mmUpdateServicePassword.UpdateServicePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.u != nil && !minimock.Equal(*mm_want_ptrs.u, mm_got.u) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter u, want: %#v, got: %#v%s\n", *mm_want_ptrs.u, mm_got.u, minimock.Diff(*mm_want_ptrs.u, mm_got.u))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateServicePassword.t.Fatal("No results are set for the ClientMock.UpdateServicePassword")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateServicePassword.funcUpdateServicePassword != nil {
		return mmUpdateServicePassword.funcUpdateServicePassword(ctx, serviceId, u)
	}
	mmUpdateServicePassword.t.Fatalf("Unexpected call to ClientMock.UpdateServicePassword. %v %v %v", ctx, serviceId, u)
	return
}

// UpdateServicePasswordAfterCounter returns a count of finished ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter)
}

// UpdateServicePasswordBeforeCounter returns a count of ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateServicePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Calls() []*ClientMockUpdateServicePasswordParams {
	mmUpdateServicePassword.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServicePasswordParams, len(mmUpdateServicePassword.callArgs))
	copy(argCopy, mmUpdateServicePassword.callArgs)

	mmUpdateServicePassword.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServicePasswordDone returns true if the count of the UpdateServicePassword invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServicePasswordDone() bool {
	if m.UpdateServicePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServicePasswordMock.invocationsDone()
}

// MinimockUpdateServicePasswordInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServicePasswordInspect() {
	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword with params: %#v", *e.params)
		}
	}

	afterUpdateServicePasswordCounter := mm_atomic.LoadUint64(&m.afterUpdateServicePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServicePasswordMock.defaultExpectation != nil && afterUpdateServicePasswordCounter < 1 {
		if m.UpdateServicePasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateServicePassword")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword with params: %#v", *m.UpdateServicePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateServicePassword != nil && afterUpdateServicePasswordCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateServicePassword")
	}

	if !m.UpdateServicePasswordMock.invocationsDone() && afterUpdateServicePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateServicePassword but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServicePasswordMock.expectedInvocations), afterUpdateServicePasswordCounter)
	}
}

type mClientMockWaitForClickPipeState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForClickPipeStateExpectation
	expectations       []*ClientMockWaitForClickPipeStateExpectation

	callArgs []*ClientMockWaitForClickPipeStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockWaitForClickPipeStateExpectation specifies expectation struct of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockWaitForClickPipeStateParams
	paramPtrs *ClientMockWaitForClickPipeStateParamPtrs
	results   *ClientMockWaitForClickPipeStateResults
	Counter   uint64
}

// ClientMockWaitForClickPipeStateParams contains parameters of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateParams struct {
	ctx            context.Context
	serviceId      string
	clickPipeId    string
	stateChecker   func(string) bool
	maxWaitSeconds uint64
}

// ClientMockWaitForClickPipeStateParamPtrs contains pointers to parameters of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	clickPipeId    *string
	stateChecker   *func(string) bool
	maxWaitSeconds *uint64
}

// ClientMockWaitForClickPipeStateResults contains results of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Optional() *mClientMockWaitForClickPipeState {
	mmWaitForClickPipeState.optional = true
	return mmWaitForClickPipeState
}

// Expect sets up expected params for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Expect(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by ExpectParams functions")
	}

	mmWaitForClickPipeState.defaultExpectation.params = &ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}
	for _, e := range mmWaitForClickPipeState.expectations {
		if minimock.Equal(e.params, mmWaitForClickPipeState.defaultExpectation.params) {
			mmWaitForClickPipeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForClickPipeState.defaultExpectation.params)
		}
	}

	return mmWaitForClickPipeState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWaitForClickPipeState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmWaitForClickPipeState
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmWaitForClickPipeState
}

// ExpectStateCheckerParam4 sets up expected param stateChecker for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectStateCheckerParam4(stateChecker func(string) bool) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.stateChecker = &stateChecker

	return mmWaitForClickPipeState
}

// ExpectMaxWaitSecondsParam5 sets up expected param maxWaitSeconds for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectMaxWaitSecondsParam5(maxWaitSeconds uint64) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds

	return mmWaitForClickPipeState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64)) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.inspectFuncWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForClickPipeState")
	}

	mmWaitForClickPipeState.mock.inspectFuncWaitForClickPipeState = f

	return mmWaitForClickPipeState
}

// Return sets up results that will be returned by Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{mock: mmWaitForClickPipeState.mock}
	}
	mmWaitForClickPipeState.defaultExpectation.results = &ClientMockWaitForClickPipeStateResults{cp1, err}
	return mmWaitForClickPipeState.mock
}

// Set uses given function f to mock the Client.WaitForClickPipeState method
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Set(f func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmWaitForClickPipeState.defaultExpectation != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForClickPipeState method")
	}

	if len(mmWaitForClickPipeState.expectations) > 0 {
		mmWaitForClickPipeState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForClickPipeState method")
	}

	mmWaitForClickPipeState.mock.funcWaitForClickPipeState = f
	return mmWaitForClickPipeState.mock
}

// When sets expectation for the Client.WaitForClickPipeState which will trigger the result defined by the following
// Then helper
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) When(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) *ClientMockWaitForClickPipeStateExpectation {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockWaitForClickPipeStateExpectation{
		mock:   mmWaitForClickPipeState.mock,
		params: &ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds},
	}
	mmWaitForClickPipeState.expectations = append(mmWaitForClickPipeState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForClickPipeState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForClickPipeStateExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockWaitForClickPipeStateResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.WaitForClickPipeState should be invoked
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Times(n uint64) *mClientMockWaitForClickPipeState {
	if n == 0 {
		mmWaitForClickPipeState.mock.t.Fatalf("Times of ClientMock.WaitForClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForClickPipeState.expectedInvocations, n)
	return mmWaitForClickPipeState
}

func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) invocationsDone() bool {
	if len(mmWaitForClickPipeState.expectations) == 0 && mmWaitForClickPipeState.defaultExpectation == nil && mmWaitForClickPipeState.mock.funcWaitForClickPipeState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForClickPipeState.mock.afterWaitForClickPipeStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForClickPipeState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForClickPipeState implements Client
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeState(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmWaitForClickPipeState.beforeWaitForClickPipeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForClickPipeState.afterWaitForClickPipeStateCounter, 1)

	if mmWaitForClickPipeState.inspectFuncWaitForClickPipeState != nil {
		mmWaitForClickPipeState.inspectFuncWaitForClickPipeState(ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForClickPipeState.WaitForClickPipeStateMock.mutex.Lock()
	mmWaitForClickPipeState.WaitForClickPipeStateMock.callArgs = append(mmWaitForClickPipeState.WaitForClickPipeStateMock.callArgs, &mm_params)
	mmWaitForClickPipeState.WaitForClickPipeStateMock.mutex.Unlock()

	for _, e := range mmWaitForClickPipeState.WaitForClickPipeStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter stateChecker, want: %#v, got: %#v%s\n", *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter maxWaitSeconds, want: %#v, got: %#v%s\n", *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForClickPipeState.t.Fatal("No results are set for the ClientMock.WaitForClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmWaitForClickPipeState.funcWaitForClickPipeState != nil {
		return mmWaitForClickPipeState.funcWaitForClickPipeState(ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	}
	mmWaitForClickPipeState.t.Fatalf("Unexpected call to ClientMock.WaitForClickPipeState. %v %v %v %v %v", ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	return
}

// WaitForClickPipeStateAfterCounter returns a count of finished ClientMock.WaitForClickPipeState invocations
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForClickPipeState.afterWaitForClickPipeStateCounter)
}

// WaitForClickPipeStateBeforeCounter returns a count of ClientMock.WaitForClickPipeState invocations
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForClickPipeState.beforeWaitForClickPipeStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForClickPipeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Calls() []*ClientMockWaitForClickPipeStateParams {
	mmWaitForClickPipeState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForClickPipeStateParams, len(mmWaitForClickPipeState.callArgs))
	copy(argCopy, mmWaitForClickPipeState.callArgs)

	mmWaitForClickPipeState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForClickPipeStateDone returns true if the count of the WaitForClickPipeState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForClickPipeStateDone() bool {
	if m.WaitForClickPipeStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForClickPipeStateMock.invocationsDone()
}

// MinimockWaitForClickPipeStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForClickPipeStateInspect() {
	for _, e := range m.WaitForClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState with params: %#v", *e.params)
		}
	}

	afterWaitForClickPipeStateCounter := mm_atomic.LoadUint64(&m.afterWaitForClickPipeStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForClickPipeStateMock.defaultExpectation != nil && afterWaitForClickPipeStateCounter < 1 {
		if m.WaitForClickPipeStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.WaitForClickPipeState")
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState with params: %#v", *m.WaitForClickPipeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForClickPipeState != nil && afterWaitForClickPipeStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.WaitForClickPipeState")
	}

	if !m.WaitForClickPipeStateMock.invocationsDone() && afterWaitForClickPipeStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForClickPipeState but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForClickPipeStateMock.expectedInvocations), afterWaitForClickPipeStateCounter)
	}
}

type mClientMockWaitForServiceState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForServiceStateExpectation
	expectations       []*ClientMockWaitForServiceStateExpectation

	callArgs []*ClientMockWaitForServiceStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockWaitForServiceStateExpectation specifies expectation struct of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockWaitForServiceStateParams
	paramPtrs *ClientMockWaitForServiceStateParamPtrs
	results   *ClientMockWaitForServiceStateResults
	Counter   uint64
}

// ClientMockWaitForServiceStateParams contains parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParams struct {
	ctx            context.Context
	serviceId      string
	stateChecker   func(string) bool
	maxWaitSeconds int
}

// ClientMockWaitForServiceStateParamPtrs contains pointers to parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	stateChecker   *func(string) bool
	maxWaitSeconds *int
}

// ClientMockWaitForServiceStateResults contains results of the Client.WaitForServiceState
type ClientMockWaitForServiceStateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForServiceState *mClientMockWaitForServiceState) Optional() *mClientMockWaitForServiceState {
	mmWaitForServiceState.optional = true
	return mmWaitForServiceState
}

// Expect sets up expected params for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Expect(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by ExpectParams functions")
	}

	mmWaitForServiceState.defaultExpectation.params = &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}
	for _, e := range mmWaitForServiceState.expectations {
		if minimock.Equal(e.params, mmWaitForServiceState.defaultExpectation.params) {
			mmWaitForServiceState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForServiceState.defaultExpectation.params)
		}
	}

	return mmWaitForServiceState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWaitForServiceState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmWaitForServiceState
}

// ExpectStateCheckerParam3 sets up expected param stateChecker for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectStateCheckerParam3(stateChecker func(string) bool) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.stateChecker = &stateChecker

	return mmWaitForServiceState
}

// ExpectMaxWaitSecondsParam4 sets up expected param maxWaitSeconds for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectMaxWaitSecondsParam4(maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds

	return mmWaitForServiceState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Inspect(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForServiceState")
	}

	mmWaitForServiceState.mock.inspectFuncWaitForServiceState = f

	return mmWaitForServiceState
}

// Return sets up results that will be returned by Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Return(err error) *ClientMock {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{mock: mmWaitForServiceState.mock}
	}
	mmWaitForServiceState.defaultExpectation.results = &ClientMockWaitForServiceStateResults{err}
	return mmWaitForServiceState.mock
}

// Set uses given function f to mock the Client.WaitForServiceState method
func (mmWaitForServiceState *mClientMockWaitForServiceState) Set(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)) *ClientMock {
	if mmWaitForServiceState.defaultExpectation != nil {
		mmWaitForServiceState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForServiceState method")
	}

	if len(mmWaitForServiceState.expectations) > 0 {
		mmWaitForServiceState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForServiceState method")
	}

	mmWaitForServiceState.mock.funcWaitForServiceState = f
	return mmWaitForServiceState.mock
}

// When sets expectation for the Client.WaitForServiceState which will trigger the result defined by the following
// Then helper
func (mmWaitForServiceState *mClientMockWaitForServiceState) When(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *ClientMockWaitForServiceStateExpectation {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	expectation := &ClientMockWaitForServiceStateExpectation{
		mock:   mmWaitForServiceState.mock,
		params: &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds},
	}
	mmWaitForServiceState.expectations = append(mmWaitForServiceState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForServiceState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForServiceStateExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockWaitForServiceStateResults{err}
	return e.mock
}

// Times sets number of times Client.WaitForServiceState should be invoked
func (mmWaitForServiceState *mClientMockWaitForServiceState) Times(n uint64) *mClientMockWaitForServiceState {
	if n == 0 {
		mmWaitForServiceState.mock.t.Fatalf("Times of ClientMock.WaitForServiceState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForServiceState.expectedInvocations, n)
	return mmWaitForServiceState
}

func (mmWaitForServiceState *mClientMockWaitForServiceState) invocationsDone() bool {
	if len(mmWaitForServiceState.expectations) == 0 && mmWaitForServiceState.defaultExpectation == nil && mmWaitForServiceState.mock.funcWaitForServiceState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.mock.afterWaitForServiceStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForServiceState implements Client
func (mmWaitForServiceState *ClientMock) WaitForServiceState(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error) {
	mm_atomic.AddUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter, 1)

	if mmWaitForServiceState.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.inspectFuncWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Lock()
	mmWaitForServiceState.WaitForServiceStateMock.callArgs = append(mmWaitForServiceState.WaitForServiceStateMock.callArgs, &mm_params)
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Unlock()

	for _, e := range mmWaitForServiceState.WaitForServiceStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter stateChecker, want: %#v, got: %#v%s\n", *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter maxWaitSeconds, want: %#v, got: %#v%s\n", *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForServiceState.t.Fatal("No results are set for the ClientMock.WaitForServiceState")
		}
		return (*mm_results).err
	}
	if mmWaitForServiceState.funcWaitForServiceState != nil {
		return mmWaitForServiceState.funcWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}
	mmWaitForServiceState.t.Fatalf("Unexpected call to ClientMock.WaitForServiceState. %v %v %v %v", ctx, serviceId, stateChecker, maxWaitSeconds)
	return
}

// WaitForServiceStateAfterCounter returns a count of finished ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter)
}

// WaitForServiceStateBeforeCounter returns a count of ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForServiceState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForServiceState *mClientMockWaitForServiceState) Calls() []*ClientMockWaitForServiceStateParams {
	mmWaitForServiceState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForServiceStateParams, len(mmWaitForServiceState.callArgs))
	copy(argCopy, mmWaitForServiceState.callArgs)

	mmWaitForServiceState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForServiceStateDone returns true if the count of the WaitForServiceState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForServiceStateDone() bool {
	if m.WaitForServiceStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForServiceStateMock.invocationsDone()
}

// MinimockWaitForServiceStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForServiceStateInspect() {
	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState with params: %#v", *e.params)
		}
	}

	afterWaitForServiceStateCounter := mm_atomic.LoadUint64(&m.afterWaitForServiceStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForServiceStateMock.defaultExpectation != nil && afterWaitForServiceStateCounter < 1 {
		if m.WaitForServiceStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.WaitForServiceState")
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState with params: %#v", *m.WaitForServiceStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForServiceState != nil && afterWaitForServiceStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.WaitForServiceState")
	}

	if !m.WaitForServiceStateMock.invocationsDone() && afterWaitForServiceStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForServiceState but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForServiceStateMock.expectedInvocations), afterWaitForServiceStateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangeClickPipeStateInspect()

			m.MinimockCreateClickPipeInspect()

			m.MinimockCreateQueryEndpointInspect()

			m.MinimockCreateServiceInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteClickPipeInspect()

			m.MinimockDeleteQueryEndpointInspect()

			m.MinimockDeleteServiceInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetApiKeyIDInspect()

			m.MinimockGetBackupConfigurationInspect()

			m.MinimockGetClickPipeInspect()

			m.MinimockGetOrgPrivateEndpointConfigInspect()

			m.MinimockGetOrganizationPrivateEndpointsInspect()

			m.MinimockGetQueryEndpointInspect()

			m.MinimockGetServiceInspect()

			m.MinimockGetUserInspect()

			m.MinimockScalingClickPipeInspect()

			m.MinimockUpdateBackupConfigurationInspect()

			m.MinimockUpdateOrganizationPrivateEndpointsInspect()

			m.MinimockUpdateReplicaScalingInspect()

			m.MinimockUpdateServiceInspect()

			m.MinimockUpdateServicePasswordInspect()

			m.MinimockWaitForClickPipeStateInspect()

			m.MinimockWaitForServiceStateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangeClickPipeStateDone() &&
		m.MinimockCreateClickPipeDone() &&
		m.MinimockCreateQueryEndpointDone() &&
		m.MinimockCreateServiceDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteClickPipeDone() &&
		m.MinimockDeleteQueryEndpointDone() &&
		m.MinimockDeleteServiceDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetApiKeyIDDone() &&
		m.MinimockGetBackupConfigurationDone() &&
		m.MinimockGetClickPipeDone() &&
		m.MinimockGetOrgPrivateEndpointConfigDone() &&
		m.MinimockGetOrganizationPrivateEndpointsDone() &&
		m.MinimockGetQueryEndpointDone() &&
		m.MinimockGetServiceDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockScalingClickPipeDone() &&
		m.MinimockUpdateBackupConfigurationDone() &&
		m.MinimockUpdateOrganizationPrivateEndpointsDone() &&
		m.MinimockUpdateReplicaScalingDone() &&
		m.MinimockUpdateServiceDone() &&
		m.MinimockUpdateServicePasswordDone() &&
		m.MinimockWaitForClickPipeStateDone() &&
		m.MinimockWaitForServiceStateDone()
}
