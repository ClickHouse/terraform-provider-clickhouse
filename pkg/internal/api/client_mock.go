// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package api

//go:generate minimock -i github.com/ClickHouse/terraform-provider-clickhouse/pkg/internal/api.Client -o client_mock.go -n ClientMock -p api

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangeClickPipeState          func(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error)
	inspectFuncChangeClickPipeState   func(ctx context.Context, serviceId string, clickPipeId string, command string)
	afterChangeClickPipeStateCounter  uint64
	beforeChangeClickPipeStateCounter uint64
	ChangeClickPipeStateMock          mClientMockChangeClickPipeState

	funcCreateApiKey          func(ctx context.Context, key ApiKey) (ap1 *ApiKey, s1 string, s2 string, err error)
	inspectFuncCreateApiKey   func(ctx context.Context, key ApiKey)
	afterCreateApiKeyCounter  uint64
	beforeCreateApiKeyCounter uint64
	CreateApiKeyMock          mClientMockCreateApiKey

	funcCreateClickPipe          func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)
	inspectFuncCreateClickPipe   func(ctx context.Context, serviceId string, clickPipe ClickPipe)
	afterCreateClickPipeCounter  uint64
	beforeCreateClickPipeCounter uint64
	CreateClickPipeMock          mClientMockCreateClickPipe

	funcCreateDatabase          func(ctx context.Context, serviceID string, db Database) (err error)
	inspectFuncCreateDatabase   func(ctx context.Context, serviceID string, db Database)
	afterCreateDatabaseCounter  uint64
	beforeCreateDatabaseCounter uint64
	CreateDatabaseMock          mClientMockCreateDatabase

	funcCreateQueryEndpoint          func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error)
	inspectFuncCreateQueryEndpoint   func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint)
	afterCreateQueryEndpointCounter  uint64
	beforeCreateQueryEndpointCounter uint64
	CreateQueryEndpointMock          mClientMockCreateQueryEndpoint

	funcCreateReversePrivateEndpoint          func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) (rp1 *ReversePrivateEndpoint, err error)
	inspectFuncCreateReversePrivateEndpoint   func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint)
	afterCreateReversePrivateEndpointCounter  uint64
	beforeCreateReversePrivateEndpointCounter uint64
	CreateReversePrivateEndpointMock          mClientMockCreateReversePrivateEndpoint

	funcCreateRole          func(ctx context.Context, serviceId string, role Role) (rp1 *Role, err error)
	inspectFuncCreateRole   func(ctx context.Context, serviceId string, role Role)
	afterCreateRoleCounter  uint64
	beforeCreateRoleCounter uint64
	CreateRoleMock          mClientMockCreateRole

	funcCreateService          func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)
	inspectFuncCreateService   func(ctx context.Context, s Service)
	afterCreateServiceCounter  uint64
	beforeCreateServiceCounter uint64
	CreateServiceMock          mClientMockCreateService

	funcCreateUser          func(ctx context.Context, serviceId string, user User) (up1 *User, err error)
	inspectFuncCreateUser   func(ctx context.Context, serviceId string, user User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mClientMockCreateUser

	funcDeleteApiKey          func(ctx context.Context, id string) (err error)
	inspectFuncDeleteApiKey   func(ctx context.Context, id string)
	afterDeleteApiKeyCounter  uint64
	beforeDeleteApiKeyCounter uint64
	DeleteApiKeyMock          mClientMockDeleteApiKey

	funcDeleteClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (err error)
	inspectFuncDeleteClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterDeleteClickPipeCounter  uint64
	beforeDeleteClickPipeCounter uint64
	DeleteClickPipeMock          mClientMockDeleteClickPipe

	funcDeleteDatabase          func(ctx context.Context, serviceID string, name string) (err error)
	inspectFuncDeleteDatabase   func(ctx context.Context, serviceID string, name string)
	afterDeleteDatabaseCounter  uint64
	beforeDeleteDatabaseCounter uint64
	DeleteDatabaseMock          mClientMockDeleteDatabase

	funcDeleteQueryEndpoint          func(ctx context.Context, serviceID string) (err error)
	inspectFuncDeleteQueryEndpoint   func(ctx context.Context, serviceID string)
	afterDeleteQueryEndpointCounter  uint64
	beforeDeleteQueryEndpointCounter uint64
	DeleteQueryEndpointMock          mClientMockDeleteQueryEndpoint

	funcDeleteReversePrivateEndpoint          func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (err error)
	inspectFuncDeleteReversePrivateEndpoint   func(ctx context.Context, serviceId string, reversePrivateEndpointId string)
	afterDeleteReversePrivateEndpointCounter  uint64
	beforeDeleteReversePrivateEndpointCounter uint64
	DeleteReversePrivateEndpointMock          mClientMockDeleteReversePrivateEndpoint

	funcDeleteRole          func(ctx context.Context, serviceID string, name string) (err error)
	inspectFuncDeleteRole   func(ctx context.Context, serviceID string, name string)
	afterDeleteRoleCounter  uint64
	beforeDeleteRoleCounter uint64
	DeleteRoleMock          mClientMockDeleteRole

	funcDeleteService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	inspectFuncDeleteService   func(ctx context.Context, serviceId string)
	afterDeleteServiceCounter  uint64
	beforeDeleteServiceCounter uint64
	DeleteServiceMock          mClientMockDeleteService

	funcDeleteUser          func(ctx context.Context, serviceID string, name string) (err error)
	inspectFuncDeleteUser   func(ctx context.Context, serviceID string, name string)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mClientMockDeleteUser

	funcGetApiKey          func(ctx context.Context, name string) (ap1 *ApiKey, err error)
	inspectFuncGetApiKey   func(ctx context.Context, name string)
	afterGetApiKeyCounter  uint64
	beforeGetApiKeyCounter uint64
	GetApiKeyMock          mClientMockGetApiKey

	funcGetBackupConfiguration          func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)
	inspectFuncGetBackupConfiguration   func(ctx context.Context, serviceId string)
	afterGetBackupConfigurationCounter  uint64
	beforeGetBackupConfigurationCounter uint64
	GetBackupConfigurationMock          mClientMockGetBackupConfiguration

	funcGetClickPipe          func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)
	inspectFuncGetClickPipe   func(ctx context.Context, serviceId string, clickPipeId string)
	afterGetClickPipeCounter  uint64
	beforeGetClickPipeCounter uint64
	GetClickPipeMock          mClientMockGetClickPipe

	funcGetCurrentApiKey          func(ctx context.Context) (ap1 *ApiKey, err error)
	inspectFuncGetCurrentApiKey   func(ctx context.Context)
	afterGetCurrentApiKeyCounter  uint64
	beforeGetCurrentApiKeyCounter uint64
	GetCurrentApiKeyMock          mClientMockGetCurrentApiKey

	funcGetDatabase          func(ctx context.Context, serviceID string, name string) (dp1 *Database, err error)
	inspectFuncGetDatabase   func(ctx context.Context, serviceID string, name string)
	afterGetDatabaseCounter  uint64
	beforeGetDatabaseCounter uint64
	GetDatabaseMock          mClientMockGetDatabase

	funcGetGrantPrivilege          func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) (gp1 *GrantPrivilege, err error)
	inspectFuncGetGrantPrivilege   func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string)
	afterGetGrantPrivilegeCounter  uint64
	beforeGetGrantPrivilegeCounter uint64
	GetGrantPrivilegeMock          mClientMockGetGrantPrivilege

	funcGetGrantRole          func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) (gp1 *GrantRole, err error)
	inspectFuncGetGrantRole   func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string)
	afterGetGrantRoleCounter  uint64
	beforeGetGrantRoleCounter uint64
	GetGrantRoleMock          mClientMockGetGrantRole

	funcGetOrgPrivateEndpointConfig          func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)
	inspectFuncGetOrgPrivateEndpointConfig   func(ctx context.Context, cloudProvider string, region string)
	afterGetOrgPrivateEndpointConfigCounter  uint64
	beforeGetOrgPrivateEndpointConfigCounter uint64
	GetOrgPrivateEndpointConfigMock          mClientMockGetOrgPrivateEndpointConfig

	funcGetOrganizationPrivateEndpoints          func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)
	inspectFuncGetOrganizationPrivateEndpoints   func(ctx context.Context)
	afterGetOrganizationPrivateEndpointsCounter  uint64
	beforeGetOrganizationPrivateEndpointsCounter uint64
	GetOrganizationPrivateEndpointsMock          mClientMockGetOrganizationPrivateEndpoints

	funcGetQueryEndpoint          func(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error)
	inspectFuncGetQueryEndpoint   func(ctx context.Context, serviceID string)
	afterGetQueryEndpointCounter  uint64
	beforeGetQueryEndpointCounter uint64
	GetQueryEndpointMock          mClientMockGetQueryEndpoint

	funcGetReversePrivateEndpoint          func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (rp1 *ReversePrivateEndpoint, err error)
	inspectFuncGetReversePrivateEndpoint   func(ctx context.Context, serviceId string, reversePrivateEndpointId string)
	afterGetReversePrivateEndpointCounter  uint64
	beforeGetReversePrivateEndpointCounter uint64
	GetReversePrivateEndpointMock          mClientMockGetReversePrivateEndpoint

	funcGetReversePrivateEndpointPath          func(serviceId string, reversePrivateEndpointId string) (s1 string)
	inspectFuncGetReversePrivateEndpointPath   func(serviceId string, reversePrivateEndpointId string)
	afterGetReversePrivateEndpointPathCounter  uint64
	beforeGetReversePrivateEndpointPathCounter uint64
	GetReversePrivateEndpointPathMock          mClientMockGetReversePrivateEndpointPath

	funcGetRole          func(ctx context.Context, serviceID string, name string) (rp1 *Role, err error)
	inspectFuncGetRole   func(ctx context.Context, serviceID string, name string)
	afterGetRoleCounter  uint64
	beforeGetRoleCounter uint64
	GetRoleMock          mClientMockGetRole

	funcGetService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	inspectFuncGetService   func(ctx context.Context, serviceId string)
	afterGetServiceCounter  uint64
	beforeGetServiceCounter uint64
	GetServiceMock          mClientMockGetService

	funcGetUser          func(ctx context.Context, serviceID string, name string) (up1 *User, err error)
	inspectFuncGetUser   func(ctx context.Context, serviceID string, name string)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mClientMockGetUser

	funcGrantPrivilege          func(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege) (gp1 *GrantPrivilege, err error)
	inspectFuncGrantPrivilege   func(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege)
	afterGrantPrivilegeCounter  uint64
	beforeGrantPrivilegeCounter uint64
	GrantPrivilegeMock          mClientMockGrantPrivilege

	funcGrantRole          func(ctx context.Context, serviceId string, grantRole GrantRole) (gp1 *GrantRole, err error)
	inspectFuncGrantRole   func(ctx context.Context, serviceId string, grantRole GrantRole)
	afterGrantRoleCounter  uint64
	beforeGrantRoleCounter uint64
	GrantRoleMock          mClientMockGrantRole

	funcListReversePrivateEndpoints          func(ctx context.Context, serviceId string) (rpa1 []*ReversePrivateEndpoint, err error)
	inspectFuncListReversePrivateEndpoints   func(ctx context.Context, serviceId string)
	afterListReversePrivateEndpointsCounter  uint64
	beforeListReversePrivateEndpointsCounter uint64
	ListReversePrivateEndpointsMock          mClientMockListReversePrivateEndpoints

	funcRevokeGrantPrivilege          func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) (err error)
	inspectFuncRevokeGrantPrivilege   func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string)
	afterRevokeGrantPrivilegeCounter  uint64
	beforeRevokeGrantPrivilegeCounter uint64
	RevokeGrantPrivilegeMock          mClientMockRevokeGrantPrivilege

	funcRevokeGrantRole          func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) (err error)
	inspectFuncRevokeGrantRole   func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string)
	afterRevokeGrantRoleCounter  uint64
	beforeRevokeGrantRoleCounter uint64
	RevokeGrantRoleMock          mClientMockRevokeGrantRole

	funcRotateTDEKey          func(ctx context.Context, serviceId string, keyId string) (err error)
	inspectFuncRotateTDEKey   func(ctx context.Context, serviceId string, keyId string)
	afterRotateTDEKeyCounter  uint64
	beforeRotateTDEKeyCounter uint64
	RotateTDEKeyMock          mClientMockRotateTDEKey

	funcScalingClickPipe          func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) (cp1 *ClickPipe, err error)
	inspectFuncScalingClickPipe   func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling)
	afterScalingClickPipeCounter  uint64
	beforeScalingClickPipeCounter uint64
	ScalingClickPipeMock          mClientMockScalingClickPipe

	funcSyncDatabase          func(ctx context.Context, serviceID string, db Database) (err error)
	inspectFuncSyncDatabase   func(ctx context.Context, serviceID string, db Database)
	afterSyncDatabaseCounter  uint64
	beforeSyncDatabaseCounter uint64
	SyncDatabaseMock          mClientMockSyncDatabase

	funcUpdateBackupConfiguration          func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)
	inspectFuncUpdateBackupConfiguration   func(ctx context.Context, serviceId string, b BackupConfiguration)
	afterUpdateBackupConfigurationCounter  uint64
	beforeUpdateBackupConfigurationCounter uint64
	UpdateBackupConfigurationMock          mClientMockUpdateBackupConfiguration

	funcUpdateClickPipe          func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) (cp1 *ClickPipe, err error)
	inspectFuncUpdateClickPipe   func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate)
	afterUpdateClickPipeCounter  uint64
	beforeUpdateClickPipeCounter uint64
	UpdateClickPipeMock          mClientMockUpdateClickPipe

	funcUpdateOrganizationPrivateEndpoints          func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)
	inspectFuncUpdateOrganizationPrivateEndpoints   func(ctx context.Context, orgUpdate OrganizationUpdate)
	afterUpdateOrganizationPrivateEndpointsCounter  uint64
	beforeUpdateOrganizationPrivateEndpointsCounter uint64
	UpdateOrganizationPrivateEndpointsMock          mClientMockUpdateOrganizationPrivateEndpoints

	funcUpdateReplicaScaling          func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)
	inspectFuncUpdateReplicaScaling   func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)
	afterUpdateReplicaScalingCounter  uint64
	beforeUpdateReplicaScalingCounter uint64
	UpdateReplicaScalingMock          mClientMockUpdateReplicaScaling

	funcUpdateService          func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)
	inspectFuncUpdateService   func(ctx context.Context, serviceId string, s ServiceUpdate)
	afterUpdateServiceCounter  uint64
	beforeUpdateServiceCounter uint64
	UpdateServiceMock          mClientMockUpdateService

	funcUpdateServicePassword          func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)
	inspectFuncUpdateServicePassword   func(ctx context.Context, serviceId string, u ServicePasswordUpdate)
	afterUpdateServicePasswordCounter  uint64
	beforeUpdateServicePasswordCounter uint64
	UpdateServicePasswordMock          mClientMockUpdateServicePassword

	funcWaitForClickPipeState          func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error)
	inspectFuncWaitForClickPipeState   func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64)
	afterWaitForClickPipeStateCounter  uint64
	beforeWaitForClickPipeStateCounter uint64
	WaitForClickPipeStateMock          mClientMockWaitForClickPipeState

	funcWaitForReversePrivateEndpointState          func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) (rp1 *ReversePrivateEndpoint, err error)
	inspectFuncWaitForReversePrivateEndpointState   func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64)
	afterWaitForReversePrivateEndpointStateCounter  uint64
	beforeWaitForReversePrivateEndpointStateCounter uint64
	WaitForReversePrivateEndpointStateMock          mClientMockWaitForReversePrivateEndpointState

	funcWaitForServiceState          func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)
	inspectFuncWaitForServiceState   func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)
	afterWaitForServiceStateCounter  uint64
	beforeWaitForServiceStateCounter uint64
	WaitForServiceStateMock          mClientMockWaitForServiceState
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangeClickPipeStateMock = mClientMockChangeClickPipeState{mock: m}
	m.ChangeClickPipeStateMock.callArgs = []*ClientMockChangeClickPipeStateParams{}

	m.CreateApiKeyMock = mClientMockCreateApiKey{mock: m}
	m.CreateApiKeyMock.callArgs = []*ClientMockCreateApiKeyParams{}

	m.CreateClickPipeMock = mClientMockCreateClickPipe{mock: m}
	m.CreateClickPipeMock.callArgs = []*ClientMockCreateClickPipeParams{}

	m.CreateDatabaseMock = mClientMockCreateDatabase{mock: m}
	m.CreateDatabaseMock.callArgs = []*ClientMockCreateDatabaseParams{}

	m.CreateQueryEndpointMock = mClientMockCreateQueryEndpoint{mock: m}
	m.CreateQueryEndpointMock.callArgs = []*ClientMockCreateQueryEndpointParams{}

	m.CreateReversePrivateEndpointMock = mClientMockCreateReversePrivateEndpoint{mock: m}
	m.CreateReversePrivateEndpointMock.callArgs = []*ClientMockCreateReversePrivateEndpointParams{}

	m.CreateRoleMock = mClientMockCreateRole{mock: m}
	m.CreateRoleMock.callArgs = []*ClientMockCreateRoleParams{}

	m.CreateServiceMock = mClientMockCreateService{mock: m}
	m.CreateServiceMock.callArgs = []*ClientMockCreateServiceParams{}

	m.CreateUserMock = mClientMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*ClientMockCreateUserParams{}

	m.DeleteApiKeyMock = mClientMockDeleteApiKey{mock: m}
	m.DeleteApiKeyMock.callArgs = []*ClientMockDeleteApiKeyParams{}

	m.DeleteClickPipeMock = mClientMockDeleteClickPipe{mock: m}
	m.DeleteClickPipeMock.callArgs = []*ClientMockDeleteClickPipeParams{}

	m.DeleteDatabaseMock = mClientMockDeleteDatabase{mock: m}
	m.DeleteDatabaseMock.callArgs = []*ClientMockDeleteDatabaseParams{}

	m.DeleteQueryEndpointMock = mClientMockDeleteQueryEndpoint{mock: m}
	m.DeleteQueryEndpointMock.callArgs = []*ClientMockDeleteQueryEndpointParams{}

	m.DeleteReversePrivateEndpointMock = mClientMockDeleteReversePrivateEndpoint{mock: m}
	m.DeleteReversePrivateEndpointMock.callArgs = []*ClientMockDeleteReversePrivateEndpointParams{}

	m.DeleteRoleMock = mClientMockDeleteRole{mock: m}
	m.DeleteRoleMock.callArgs = []*ClientMockDeleteRoleParams{}

	m.DeleteServiceMock = mClientMockDeleteService{mock: m}
	m.DeleteServiceMock.callArgs = []*ClientMockDeleteServiceParams{}

	m.DeleteUserMock = mClientMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*ClientMockDeleteUserParams{}

	m.GetApiKeyMock = mClientMockGetApiKey{mock: m}
	m.GetApiKeyMock.callArgs = []*ClientMockGetApiKeyParams{}

	m.GetBackupConfigurationMock = mClientMockGetBackupConfiguration{mock: m}
	m.GetBackupConfigurationMock.callArgs = []*ClientMockGetBackupConfigurationParams{}

	m.GetClickPipeMock = mClientMockGetClickPipe{mock: m}
	m.GetClickPipeMock.callArgs = []*ClientMockGetClickPipeParams{}

	m.GetCurrentApiKeyMock = mClientMockGetCurrentApiKey{mock: m}
	m.GetCurrentApiKeyMock.callArgs = []*ClientMockGetCurrentApiKeyParams{}

	m.GetDatabaseMock = mClientMockGetDatabase{mock: m}
	m.GetDatabaseMock.callArgs = []*ClientMockGetDatabaseParams{}

	m.GetGrantPrivilegeMock = mClientMockGetGrantPrivilege{mock: m}
	m.GetGrantPrivilegeMock.callArgs = []*ClientMockGetGrantPrivilegeParams{}

	m.GetGrantRoleMock = mClientMockGetGrantRole{mock: m}
	m.GetGrantRoleMock.callArgs = []*ClientMockGetGrantRoleParams{}

	m.GetOrgPrivateEndpointConfigMock = mClientMockGetOrgPrivateEndpointConfig{mock: m}
	m.GetOrgPrivateEndpointConfigMock.callArgs = []*ClientMockGetOrgPrivateEndpointConfigParams{}

	m.GetOrganizationPrivateEndpointsMock = mClientMockGetOrganizationPrivateEndpoints{mock: m}
	m.GetOrganizationPrivateEndpointsMock.callArgs = []*ClientMockGetOrganizationPrivateEndpointsParams{}

	m.GetQueryEndpointMock = mClientMockGetQueryEndpoint{mock: m}
	m.GetQueryEndpointMock.callArgs = []*ClientMockGetQueryEndpointParams{}

	m.GetReversePrivateEndpointMock = mClientMockGetReversePrivateEndpoint{mock: m}
	m.GetReversePrivateEndpointMock.callArgs = []*ClientMockGetReversePrivateEndpointParams{}

	m.GetReversePrivateEndpointPathMock = mClientMockGetReversePrivateEndpointPath{mock: m}
	m.GetReversePrivateEndpointPathMock.callArgs = []*ClientMockGetReversePrivateEndpointPathParams{}

	m.GetRoleMock = mClientMockGetRole{mock: m}
	m.GetRoleMock.callArgs = []*ClientMockGetRoleParams{}

	m.GetServiceMock = mClientMockGetService{mock: m}
	m.GetServiceMock.callArgs = []*ClientMockGetServiceParams{}

	m.GetUserMock = mClientMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*ClientMockGetUserParams{}

	m.GrantPrivilegeMock = mClientMockGrantPrivilege{mock: m}
	m.GrantPrivilegeMock.callArgs = []*ClientMockGrantPrivilegeParams{}

	m.GrantRoleMock = mClientMockGrantRole{mock: m}
	m.GrantRoleMock.callArgs = []*ClientMockGrantRoleParams{}

	m.ListReversePrivateEndpointsMock = mClientMockListReversePrivateEndpoints{mock: m}
	m.ListReversePrivateEndpointsMock.callArgs = []*ClientMockListReversePrivateEndpointsParams{}

	m.RevokeGrantPrivilegeMock = mClientMockRevokeGrantPrivilege{mock: m}
	m.RevokeGrantPrivilegeMock.callArgs = []*ClientMockRevokeGrantPrivilegeParams{}

	m.RevokeGrantRoleMock = mClientMockRevokeGrantRole{mock: m}
	m.RevokeGrantRoleMock.callArgs = []*ClientMockRevokeGrantRoleParams{}

	m.RotateTDEKeyMock = mClientMockRotateTDEKey{mock: m}
	m.RotateTDEKeyMock.callArgs = []*ClientMockRotateTDEKeyParams{}

	m.ScalingClickPipeMock = mClientMockScalingClickPipe{mock: m}
	m.ScalingClickPipeMock.callArgs = []*ClientMockScalingClickPipeParams{}

	m.SyncDatabaseMock = mClientMockSyncDatabase{mock: m}
	m.SyncDatabaseMock.callArgs = []*ClientMockSyncDatabaseParams{}

	m.UpdateBackupConfigurationMock = mClientMockUpdateBackupConfiguration{mock: m}
	m.UpdateBackupConfigurationMock.callArgs = []*ClientMockUpdateBackupConfigurationParams{}

	m.UpdateClickPipeMock = mClientMockUpdateClickPipe{mock: m}
	m.UpdateClickPipeMock.callArgs = []*ClientMockUpdateClickPipeParams{}

	m.UpdateOrganizationPrivateEndpointsMock = mClientMockUpdateOrganizationPrivateEndpoints{mock: m}
	m.UpdateOrganizationPrivateEndpointsMock.callArgs = []*ClientMockUpdateOrganizationPrivateEndpointsParams{}

	m.UpdateReplicaScalingMock = mClientMockUpdateReplicaScaling{mock: m}
	m.UpdateReplicaScalingMock.callArgs = []*ClientMockUpdateReplicaScalingParams{}

	m.UpdateServiceMock = mClientMockUpdateService{mock: m}
	m.UpdateServiceMock.callArgs = []*ClientMockUpdateServiceParams{}

	m.UpdateServicePasswordMock = mClientMockUpdateServicePassword{mock: m}
	m.UpdateServicePasswordMock.callArgs = []*ClientMockUpdateServicePasswordParams{}

	m.WaitForClickPipeStateMock = mClientMockWaitForClickPipeState{mock: m}
	m.WaitForClickPipeStateMock.callArgs = []*ClientMockWaitForClickPipeStateParams{}

	m.WaitForReversePrivateEndpointStateMock = mClientMockWaitForReversePrivateEndpointState{mock: m}
	m.WaitForReversePrivateEndpointStateMock.callArgs = []*ClientMockWaitForReversePrivateEndpointStateParams{}

	m.WaitForServiceStateMock = mClientMockWaitForServiceState{mock: m}
	m.WaitForServiceStateMock.callArgs = []*ClientMockWaitForServiceStateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockChangeClickPipeState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockChangeClickPipeStateExpectation
	expectations       []*ClientMockChangeClickPipeStateExpectation

	callArgs []*ClientMockChangeClickPipeStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockChangeClickPipeStateExpectation specifies expectation struct of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockChangeClickPipeStateParams
	paramPtrs *ClientMockChangeClickPipeStateParamPtrs
	results   *ClientMockChangeClickPipeStateResults
	Counter   uint64
}

// ClientMockChangeClickPipeStateParams contains parameters of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	command     string
}

// ClientMockChangeClickPipeStateParamPtrs contains pointers to parameters of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	command     *string
}

// ClientMockChangeClickPipeStateResults contains results of the Client.ChangeClickPipeState
type ClientMockChangeClickPipeStateResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Optional() *mClientMockChangeClickPipeState {
	mmChangeClickPipeState.optional = true
	return mmChangeClickPipeState
}

// Expect sets up expected params for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Expect(ctx context.Context, serviceId string, clickPipeId string, command string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by ExpectParams functions")
	}

	mmChangeClickPipeState.defaultExpectation.params = &ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}
	for _, e := range mmChangeClickPipeState.expectations {
		if minimock.Equal(e.params, mmChangeClickPipeState.defaultExpectation.params) {
			mmChangeClickPipeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeClickPipeState.defaultExpectation.params)
		}
	}

	return mmChangeClickPipeState
}

// ExpectCtxParam1 sets up expected param ctx for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectCtxParam1(ctx context.Context) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmChangeClickPipeState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectServiceIdParam2(serviceId string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmChangeClickPipeState
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmChangeClickPipeState
}

// ExpectCommandParam4 sets up expected param command for Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) ExpectCommandParam4(command string) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{}
	}

	if mmChangeClickPipeState.defaultExpectation.params != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Expect")
	}

	if mmChangeClickPipeState.defaultExpectation.paramPtrs == nil {
		mmChangeClickPipeState.defaultExpectation.paramPtrs = &ClientMockChangeClickPipeStateParamPtrs{}
	}
	mmChangeClickPipeState.defaultExpectation.paramPtrs.command = &command

	return mmChangeClickPipeState
}

// Inspect accepts an inspector function that has same arguments as the Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, command string)) *mClientMockChangeClickPipeState {
	if mmChangeClickPipeState.mock.inspectFuncChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("Inspect function is already set for ClientMock.ChangeClickPipeState")
	}

	mmChangeClickPipeState.mock.inspectFuncChangeClickPipeState = f

	return mmChangeClickPipeState
}

// Return sets up results that will be returned by Client.ChangeClickPipeState
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	if mmChangeClickPipeState.defaultExpectation == nil {
		mmChangeClickPipeState.defaultExpectation = &ClientMockChangeClickPipeStateExpectation{mock: mmChangeClickPipeState.mock}
	}
	mmChangeClickPipeState.defaultExpectation.results = &ClientMockChangeClickPipeStateResults{cp1, err}
	return mmChangeClickPipeState.mock
}

// Set uses given function f to mock the Client.ChangeClickPipeState method
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Set(f func(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmChangeClickPipeState.defaultExpectation != nil {
		mmChangeClickPipeState.mock.t.Fatalf("Default expectation is already set for the Client.ChangeClickPipeState method")
	}

	if len(mmChangeClickPipeState.expectations) > 0 {
		mmChangeClickPipeState.mock.t.Fatalf("Some expectations are already set for the Client.ChangeClickPipeState method")
	}

	mmChangeClickPipeState.mock.funcChangeClickPipeState = f
	return mmChangeClickPipeState.mock
}

// When sets expectation for the Client.ChangeClickPipeState which will trigger the result defined by the following
// Then helper
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) When(ctx context.Context, serviceId string, clickPipeId string, command string) *ClientMockChangeClickPipeStateExpectation {
	if mmChangeClickPipeState.mock.funcChangeClickPipeState != nil {
		mmChangeClickPipeState.mock.t.Fatalf("ClientMock.ChangeClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockChangeClickPipeStateExpectation{
		mock:   mmChangeClickPipeState.mock,
		params: &ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command},
	}
	mmChangeClickPipeState.expectations = append(mmChangeClickPipeState.expectations, expectation)
	return expectation
}

// Then sets up Client.ChangeClickPipeState return parameters for the expectation previously defined by the When method
func (e *ClientMockChangeClickPipeStateExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockChangeClickPipeStateResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ChangeClickPipeState should be invoked
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Times(n uint64) *mClientMockChangeClickPipeState {
	if n == 0 {
		mmChangeClickPipeState.mock.t.Fatalf("Times of ClientMock.ChangeClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangeClickPipeState.expectedInvocations, n)
	return mmChangeClickPipeState
}

func (mmChangeClickPipeState *mClientMockChangeClickPipeState) invocationsDone() bool {
	if len(mmChangeClickPipeState.expectations) == 0 && mmChangeClickPipeState.defaultExpectation == nil && mmChangeClickPipeState.mock.funcChangeClickPipeState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangeClickPipeState.mock.afterChangeClickPipeStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangeClickPipeState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangeClickPipeState implements Client
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeState(ctx context.Context, serviceId string, clickPipeId string, command string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmChangeClickPipeState.beforeChangeClickPipeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeClickPipeState.afterChangeClickPipeStateCounter, 1)

	if mmChangeClickPipeState.inspectFuncChangeClickPipeState != nil {
		mmChangeClickPipeState.inspectFuncChangeClickPipeState(ctx, serviceId, clickPipeId, command)
	}

	mm_params := ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}

	// Record call args
	mmChangeClickPipeState.ChangeClickPipeStateMock.mutex.Lock()
	mmChangeClickPipeState.ChangeClickPipeStateMock.callArgs = append(mmChangeClickPipeState.ChangeClickPipeStateMock.callArgs, &mm_params)
	mmChangeClickPipeState.ChangeClickPipeStateMock.mutex.Unlock()

	for _, e := range mmChangeClickPipeState.ChangeClickPipeStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.params
		mm_want_ptrs := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockChangeClickPipeStateParams{ctx, serviceId, clickPipeId, command}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.command != nil && !minimock.Equal(*mm_want_ptrs.command, mm_got.command) {
				mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameter command, want: %#v, got: %#v%s\n", *mm_want_ptrs.command, mm_got.command, minimock.Diff(*mm_want_ptrs.command, mm_got.command))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeClickPipeState.t.Errorf("ClientMock.ChangeClickPipeState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeClickPipeState.ChangeClickPipeStateMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeClickPipeState.t.Fatal("No results are set for the ClientMock.ChangeClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChangeClickPipeState.funcChangeClickPipeState != nil {
		return mmChangeClickPipeState.funcChangeClickPipeState(ctx, serviceId, clickPipeId, command)
	}
	mmChangeClickPipeState.t.Fatalf("Unexpected call to ClientMock.ChangeClickPipeState. %v %v %v %v", ctx, serviceId, clickPipeId, command)
	return
}

// ChangeClickPipeStateAfterCounter returns a count of finished ClientMock.ChangeClickPipeState invocations
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeClickPipeState.afterChangeClickPipeStateCounter)
}

// ChangeClickPipeStateBeforeCounter returns a count of ClientMock.ChangeClickPipeState invocations
func (mmChangeClickPipeState *ClientMock) ChangeClickPipeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeClickPipeState.beforeChangeClickPipeStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ChangeClickPipeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeClickPipeState *mClientMockChangeClickPipeState) Calls() []*ClientMockChangeClickPipeStateParams {
	mmChangeClickPipeState.mutex.RLock()

	argCopy := make([]*ClientMockChangeClickPipeStateParams, len(mmChangeClickPipeState.callArgs))
	copy(argCopy, mmChangeClickPipeState.callArgs)

	mmChangeClickPipeState.mutex.RUnlock()

	return argCopy
}

// MinimockChangeClickPipeStateDone returns true if the count of the ChangeClickPipeState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockChangeClickPipeStateDone() bool {
	if m.ChangeClickPipeStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangeClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangeClickPipeStateMock.invocationsDone()
}

// MinimockChangeClickPipeStateInspect logs each unmet expectation
func (m *ClientMock) MinimockChangeClickPipeStateInspect() {
	for _, e := range m.ChangeClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState with params: %#v", *e.params)
		}
	}

	afterChangeClickPipeStateCounter := mm_atomic.LoadUint64(&m.afterChangeClickPipeStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeClickPipeStateMock.defaultExpectation != nil && afterChangeClickPipeStateCounter < 1 {
		if m.ChangeClickPipeStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ChangeClickPipeState")
		} else {
			m.t.Errorf("Expected call to ClientMock.ChangeClickPipeState with params: %#v", *m.ChangeClickPipeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeClickPipeState != nil && afterChangeClickPipeStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.ChangeClickPipeState")
	}

	if !m.ChangeClickPipeStateMock.invocationsDone() && afterChangeClickPipeStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ChangeClickPipeState but found %d calls",
			mm_atomic.LoadUint64(&m.ChangeClickPipeStateMock.expectedInvocations), afterChangeClickPipeStateCounter)
	}
}

type mClientMockCreateApiKey struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateApiKeyExpectation
	expectations       []*ClientMockCreateApiKeyExpectation

	callArgs []*ClientMockCreateApiKeyParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateApiKeyExpectation specifies expectation struct of the Client.CreateApiKey
type ClientMockCreateApiKeyExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateApiKeyParams
	paramPtrs *ClientMockCreateApiKeyParamPtrs
	results   *ClientMockCreateApiKeyResults
	Counter   uint64
}

// ClientMockCreateApiKeyParams contains parameters of the Client.CreateApiKey
type ClientMockCreateApiKeyParams struct {
	ctx context.Context
	key ApiKey
}

// ClientMockCreateApiKeyParamPtrs contains pointers to parameters of the Client.CreateApiKey
type ClientMockCreateApiKeyParamPtrs struct {
	ctx *context.Context
	key *ApiKey
}

// ClientMockCreateApiKeyResults contains results of the Client.CreateApiKey
type ClientMockCreateApiKeyResults struct {
	ap1 *ApiKey
	s1  string
	s2  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateApiKey *mClientMockCreateApiKey) Optional() *mClientMockCreateApiKey {
	mmCreateApiKey.optional = true
	return mmCreateApiKey
}

// Expect sets up expected params for Client.CreateApiKey
func (mmCreateApiKey *mClientMockCreateApiKey) Expect(ctx context.Context, key ApiKey) *mClientMockCreateApiKey {
	if mmCreateApiKey.mock.funcCreateApiKey != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Set")
	}

	if mmCreateApiKey.defaultExpectation == nil {
		mmCreateApiKey.defaultExpectation = &ClientMockCreateApiKeyExpectation{}
	}

	if mmCreateApiKey.defaultExpectation.paramPtrs != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by ExpectParams functions")
	}

	mmCreateApiKey.defaultExpectation.params = &ClientMockCreateApiKeyParams{ctx, key}
	for _, e := range mmCreateApiKey.expectations {
		if minimock.Equal(e.params, mmCreateApiKey.defaultExpectation.params) {
			mmCreateApiKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateApiKey.defaultExpectation.params)
		}
	}

	return mmCreateApiKey
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateApiKey
func (mmCreateApiKey *mClientMockCreateApiKey) ExpectCtxParam1(ctx context.Context) *mClientMockCreateApiKey {
	if mmCreateApiKey.mock.funcCreateApiKey != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Set")
	}

	if mmCreateApiKey.defaultExpectation == nil {
		mmCreateApiKey.defaultExpectation = &ClientMockCreateApiKeyExpectation{}
	}

	if mmCreateApiKey.defaultExpectation.params != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Expect")
	}

	if mmCreateApiKey.defaultExpectation.paramPtrs == nil {
		mmCreateApiKey.defaultExpectation.paramPtrs = &ClientMockCreateApiKeyParamPtrs{}
	}
	mmCreateApiKey.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateApiKey
}

// ExpectKeyParam2 sets up expected param key for Client.CreateApiKey
func (mmCreateApiKey *mClientMockCreateApiKey) ExpectKeyParam2(key ApiKey) *mClientMockCreateApiKey {
	if mmCreateApiKey.mock.funcCreateApiKey != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Set")
	}

	if mmCreateApiKey.defaultExpectation == nil {
		mmCreateApiKey.defaultExpectation = &ClientMockCreateApiKeyExpectation{}
	}

	if mmCreateApiKey.defaultExpectation.params != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Expect")
	}

	if mmCreateApiKey.defaultExpectation.paramPtrs == nil {
		mmCreateApiKey.defaultExpectation.paramPtrs = &ClientMockCreateApiKeyParamPtrs{}
	}
	mmCreateApiKey.defaultExpectation.paramPtrs.key = &key

	return mmCreateApiKey
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateApiKey
func (mmCreateApiKey *mClientMockCreateApiKey) Inspect(f func(ctx context.Context, key ApiKey)) *mClientMockCreateApiKey {
	if mmCreateApiKey.mock.inspectFuncCreateApiKey != nil {
		mmCreateApiKey.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateApiKey")
	}

	mmCreateApiKey.mock.inspectFuncCreateApiKey = f

	return mmCreateApiKey
}

// Return sets up results that will be returned by Client.CreateApiKey
func (mmCreateApiKey *mClientMockCreateApiKey) Return(ap1 *ApiKey, s1 string, s2 string, err error) *ClientMock {
	if mmCreateApiKey.mock.funcCreateApiKey != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Set")
	}

	if mmCreateApiKey.defaultExpectation == nil {
		mmCreateApiKey.defaultExpectation = &ClientMockCreateApiKeyExpectation{mock: mmCreateApiKey.mock}
	}
	mmCreateApiKey.defaultExpectation.results = &ClientMockCreateApiKeyResults{ap1, s1, s2, err}
	return mmCreateApiKey.mock
}

// Set uses given function f to mock the Client.CreateApiKey method
func (mmCreateApiKey *mClientMockCreateApiKey) Set(f func(ctx context.Context, key ApiKey) (ap1 *ApiKey, s1 string, s2 string, err error)) *ClientMock {
	if mmCreateApiKey.defaultExpectation != nil {
		mmCreateApiKey.mock.t.Fatalf("Default expectation is already set for the Client.CreateApiKey method")
	}

	if len(mmCreateApiKey.expectations) > 0 {
		mmCreateApiKey.mock.t.Fatalf("Some expectations are already set for the Client.CreateApiKey method")
	}

	mmCreateApiKey.mock.funcCreateApiKey = f
	return mmCreateApiKey.mock
}

// When sets expectation for the Client.CreateApiKey which will trigger the result defined by the following
// Then helper
func (mmCreateApiKey *mClientMockCreateApiKey) When(ctx context.Context, key ApiKey) *ClientMockCreateApiKeyExpectation {
	if mmCreateApiKey.mock.funcCreateApiKey != nil {
		mmCreateApiKey.mock.t.Fatalf("ClientMock.CreateApiKey mock is already set by Set")
	}

	expectation := &ClientMockCreateApiKeyExpectation{
		mock:   mmCreateApiKey.mock,
		params: &ClientMockCreateApiKeyParams{ctx, key},
	}
	mmCreateApiKey.expectations = append(mmCreateApiKey.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateApiKey return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateApiKeyExpectation) Then(ap1 *ApiKey, s1 string, s2 string, err error) *ClientMock {
	e.results = &ClientMockCreateApiKeyResults{ap1, s1, s2, err}
	return e.mock
}

// Times sets number of times Client.CreateApiKey should be invoked
func (mmCreateApiKey *mClientMockCreateApiKey) Times(n uint64) *mClientMockCreateApiKey {
	if n == 0 {
		mmCreateApiKey.mock.t.Fatalf("Times of ClientMock.CreateApiKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateApiKey.expectedInvocations, n)
	return mmCreateApiKey
}

func (mmCreateApiKey *mClientMockCreateApiKey) invocationsDone() bool {
	if len(mmCreateApiKey.expectations) == 0 && mmCreateApiKey.defaultExpectation == nil && mmCreateApiKey.mock.funcCreateApiKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateApiKey.mock.afterCreateApiKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateApiKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateApiKey implements Client
func (mmCreateApiKey *ClientMock) CreateApiKey(ctx context.Context, key ApiKey) (ap1 *ApiKey, s1 string, s2 string, err error) {
	mm_atomic.AddUint64(&mmCreateApiKey.beforeCreateApiKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateApiKey.afterCreateApiKeyCounter, 1)

	if mmCreateApiKey.inspectFuncCreateApiKey != nil {
		mmCreateApiKey.inspectFuncCreateApiKey(ctx, key)
	}

	mm_params := ClientMockCreateApiKeyParams{ctx, key}

	// Record call args
	mmCreateApiKey.CreateApiKeyMock.mutex.Lock()
	mmCreateApiKey.CreateApiKeyMock.callArgs = append(mmCreateApiKey.CreateApiKeyMock.callArgs, &mm_params)
	mmCreateApiKey.CreateApiKeyMock.mutex.Unlock()

	for _, e := range mmCreateApiKey.CreateApiKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.s1, e.results.s2, e.results.err
		}
	}

	if mmCreateApiKey.CreateApiKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateApiKey.CreateApiKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateApiKey.CreateApiKeyMock.defaultExpectation.params
		mm_want_ptrs := mmCreateApiKey.CreateApiKeyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateApiKeyParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateApiKey.t.Errorf("ClientMock.CreateApiKey got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmCreateApiKey.t.Errorf("ClientMock.CreateApiKey got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateApiKey.t.Errorf("ClientMock.CreateApiKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateApiKey.CreateApiKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateApiKey.t.Fatal("No results are set for the ClientMock.CreateApiKey")
		}
		return (*mm_results).ap1, (*mm_results).s1, (*mm_results).s2, (*mm_results).err
	}
	if mmCreateApiKey.funcCreateApiKey != nil {
		return mmCreateApiKey.funcCreateApiKey(ctx, key)
	}
	mmCreateApiKey.t.Fatalf("Unexpected call to ClientMock.CreateApiKey. %v %v", ctx, key)
	return
}

// CreateApiKeyAfterCounter returns a count of finished ClientMock.CreateApiKey invocations
func (mmCreateApiKey *ClientMock) CreateApiKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApiKey.afterCreateApiKeyCounter)
}

// CreateApiKeyBeforeCounter returns a count of ClientMock.CreateApiKey invocations
func (mmCreateApiKey *ClientMock) CreateApiKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApiKey.beforeCreateApiKeyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateApiKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateApiKey *mClientMockCreateApiKey) Calls() []*ClientMockCreateApiKeyParams {
	mmCreateApiKey.mutex.RLock()

	argCopy := make([]*ClientMockCreateApiKeyParams, len(mmCreateApiKey.callArgs))
	copy(argCopy, mmCreateApiKey.callArgs)

	mmCreateApiKey.mutex.RUnlock()

	return argCopy
}

// MinimockCreateApiKeyDone returns true if the count of the CreateApiKey invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateApiKeyDone() bool {
	if m.CreateApiKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateApiKeyMock.invocationsDone()
}

// MinimockCreateApiKeyInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateApiKeyInspect() {
	for _, e := range m.CreateApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateApiKey with params: %#v", *e.params)
		}
	}

	afterCreateApiKeyCounter := mm_atomic.LoadUint64(&m.afterCreateApiKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateApiKeyMock.defaultExpectation != nil && afterCreateApiKeyCounter < 1 {
		if m.CreateApiKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateApiKey")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateApiKey with params: %#v", *m.CreateApiKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateApiKey != nil && afterCreateApiKeyCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateApiKey")
	}

	if !m.CreateApiKeyMock.invocationsDone() && afterCreateApiKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateApiKey but found %d calls",
			mm_atomic.LoadUint64(&m.CreateApiKeyMock.expectedInvocations), afterCreateApiKeyCounter)
	}
}

type mClientMockCreateClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateClickPipeExpectation
	expectations       []*ClientMockCreateClickPipeExpectation

	callArgs []*ClientMockCreateClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateClickPipeExpectation specifies expectation struct of the Client.CreateClickPipe
type ClientMockCreateClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateClickPipeParams
	paramPtrs *ClientMockCreateClickPipeParamPtrs
	results   *ClientMockCreateClickPipeResults
	Counter   uint64
}

// ClientMockCreateClickPipeParams contains parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParams struct {
	ctx       context.Context
	serviceId string
	clickPipe ClickPipe
}

// ClientMockCreateClickPipeParamPtrs contains pointers to parameters of the Client.CreateClickPipe
type ClientMockCreateClickPipeParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	clickPipe *ClickPipe
}

// ClientMockCreateClickPipeResults contains results of the Client.CreateClickPipe
type ClientMockCreateClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateClickPipe *mClientMockCreateClickPipe) Optional() *mClientMockCreateClickPipe {
	mmCreateClickPipe.optional = true
	return mmCreateClickPipe
}

// Expect sets up expected params for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Expect(ctx context.Context, serviceId string, clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by ExpectParams functions")
	}

	mmCreateClickPipe.defaultExpectation.params = &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}
	for _, e := range mmCreateClickPipe.expectations {
		if minimock.Equal(e.params, mmCreateClickPipe.defaultExpectation.params) {
			mmCreateClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClickPipe.defaultExpectation.params)
		}
	}

	return mmCreateClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmCreateClickPipe
}

// ExpectClickPipeParam3 sets up expected param clickPipe for Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) ExpectClickPipeParam3(clickPipe ClickPipe) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{}
	}

	if mmCreateClickPipe.defaultExpectation.params != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Expect")
	}

	if mmCreateClickPipe.defaultExpectation.paramPtrs == nil {
		mmCreateClickPipe.defaultExpectation.paramPtrs = &ClientMockCreateClickPipeParamPtrs{}
	}
	mmCreateClickPipe.defaultExpectation.paramPtrs.clickPipe = &clickPipe

	return mmCreateClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipe ClickPipe)) *mClientMockCreateClickPipe {
	if mmCreateClickPipe.mock.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateClickPipe")
	}

	mmCreateClickPipe.mock.inspectFuncCreateClickPipe = f

	return mmCreateClickPipe
}

// Return sets up results that will be returned by Client.CreateClickPipe
func (mmCreateClickPipe *mClientMockCreateClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	if mmCreateClickPipe.defaultExpectation == nil {
		mmCreateClickPipe.defaultExpectation = &ClientMockCreateClickPipeExpectation{mock: mmCreateClickPipe.mock}
	}
	mmCreateClickPipe.defaultExpectation.results = &ClientMockCreateClickPipeResults{cp1, err}
	return mmCreateClickPipe.mock
}

// Set uses given function f to mock the Client.CreateClickPipe method
func (mmCreateClickPipe *mClientMockCreateClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmCreateClickPipe.defaultExpectation != nil {
		mmCreateClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.CreateClickPipe method")
	}

	if len(mmCreateClickPipe.expectations) > 0 {
		mmCreateClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.CreateClickPipe method")
	}

	mmCreateClickPipe.mock.funcCreateClickPipe = f
	return mmCreateClickPipe.mock
}

// When sets expectation for the Client.CreateClickPipe which will trigger the result defined by the following
// Then helper
func (mmCreateClickPipe *mClientMockCreateClickPipe) When(ctx context.Context, serviceId string, clickPipe ClickPipe) *ClientMockCreateClickPipeExpectation {
	if mmCreateClickPipe.mock.funcCreateClickPipe != nil {
		mmCreateClickPipe.mock.t.Fatalf("ClientMock.CreateClickPipe mock is already set by Set")
	}

	expectation := &ClientMockCreateClickPipeExpectation{
		mock:   mmCreateClickPipe.mock,
		params: &ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe},
	}
	mmCreateClickPipe.expectations = append(mmCreateClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockCreateClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.CreateClickPipe should be invoked
func (mmCreateClickPipe *mClientMockCreateClickPipe) Times(n uint64) *mClientMockCreateClickPipe {
	if n == 0 {
		mmCreateClickPipe.mock.t.Fatalf("Times of ClientMock.CreateClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateClickPipe.expectedInvocations, n)
	return mmCreateClickPipe
}

func (mmCreateClickPipe *mClientMockCreateClickPipe) invocationsDone() bool {
	if len(mmCreateClickPipe.expectations) == 0 && mmCreateClickPipe.defaultExpectation == nil && mmCreateClickPipe.mock.funcCreateClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.mock.afterCreateClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateClickPipe implements Client
func (mmCreateClickPipe *ClientMock) CreateClickPipe(ctx context.Context, serviceId string, clickPipe ClickPipe) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClickPipe.afterCreateClickPipeCounter, 1)

	if mmCreateClickPipe.inspectFuncCreateClickPipe != nil {
		mmCreateClickPipe.inspectFuncCreateClickPipe(ctx, serviceId, clickPipe)
	}

	mm_params := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

	// Record call args
	mmCreateClickPipe.CreateClickPipeMock.mutex.Lock()
	mmCreateClickPipe.CreateClickPipeMock.callArgs = append(mmCreateClickPipe.CreateClickPipeMock.callArgs, &mm_params)
	mmCreateClickPipe.CreateClickPipeMock.mutex.Unlock()

	for _, e := range mmCreateClickPipe.CreateClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateClickPipe.CreateClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateClickPipeParams{ctx, serviceId, clickPipe}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipe != nil && !minimock.Equal(*mm_want_ptrs.clickPipe, mm_got.clickPipe) {
				mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameter clickPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipe, mm_got.clickPipe, minimock.Diff(*mm_want_ptrs.clickPipe, mm_got.clickPipe))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClickPipe.t.Errorf("ClientMock.CreateClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClickPipe.CreateClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClickPipe.t.Fatal("No results are set for the ClientMock.CreateClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateClickPipe.funcCreateClickPipe != nil {
		return mmCreateClickPipe.funcCreateClickPipe(ctx, serviceId, clickPipe)
	}
	mmCreateClickPipe.t.Fatalf("Unexpected call to ClientMock.CreateClickPipe. %v %v %v", ctx, serviceId, clickPipe)
	return
}

// CreateClickPipeAfterCounter returns a count of finished ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.afterCreateClickPipeCounter)
}

// CreateClickPipeBeforeCounter returns a count of ClientMock.CreateClickPipe invocations
func (mmCreateClickPipe *ClientMock) CreateClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClickPipe.beforeCreateClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClickPipe *mClientMockCreateClickPipe) Calls() []*ClientMockCreateClickPipeParams {
	mmCreateClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockCreateClickPipeParams, len(mmCreateClickPipe.callArgs))
	copy(argCopy, mmCreateClickPipe.callArgs)

	mmCreateClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClickPipeDone returns true if the count of the CreateClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateClickPipeDone() bool {
	if m.CreateClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateClickPipeMock.invocationsDone()
}

// MinimockCreateClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateClickPipeInspect() {
	for _, e := range m.CreateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe with params: %#v", *e.params)
		}
	}

	afterCreateClickPipeCounter := mm_atomic.LoadUint64(&m.afterCreateClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClickPipeMock.defaultExpectation != nil && afterCreateClickPipeCounter < 1 {
		if m.CreateClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateClickPipe with params: %#v", *m.CreateClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClickPipe != nil && afterCreateClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateClickPipe")
	}

	if !m.CreateClickPipeMock.invocationsDone() && afterCreateClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.CreateClickPipeMock.expectedInvocations), afterCreateClickPipeCounter)
	}
}

type mClientMockCreateDatabase struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateDatabaseExpectation
	expectations       []*ClientMockCreateDatabaseExpectation

	callArgs []*ClientMockCreateDatabaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateDatabaseExpectation specifies expectation struct of the Client.CreateDatabase
type ClientMockCreateDatabaseExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateDatabaseParams
	paramPtrs *ClientMockCreateDatabaseParamPtrs
	results   *ClientMockCreateDatabaseResults
	Counter   uint64
}

// ClientMockCreateDatabaseParams contains parameters of the Client.CreateDatabase
type ClientMockCreateDatabaseParams struct {
	ctx       context.Context
	serviceID string
	db        Database
}

// ClientMockCreateDatabaseParamPtrs contains pointers to parameters of the Client.CreateDatabase
type ClientMockCreateDatabaseParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	db        *Database
}

// ClientMockCreateDatabaseResults contains results of the Client.CreateDatabase
type ClientMockCreateDatabaseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateDatabase *mClientMockCreateDatabase) Optional() *mClientMockCreateDatabase {
	mmCreateDatabase.optional = true
	return mmCreateDatabase
}

// Expect sets up expected params for Client.CreateDatabase
func (mmCreateDatabase *mClientMockCreateDatabase) Expect(ctx context.Context, serviceID string, db Database) *mClientMockCreateDatabase {
	if mmCreateDatabase.mock.funcCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Set")
	}

	if mmCreateDatabase.defaultExpectation == nil {
		mmCreateDatabase.defaultExpectation = &ClientMockCreateDatabaseExpectation{}
	}

	if mmCreateDatabase.defaultExpectation.paramPtrs != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by ExpectParams functions")
	}

	mmCreateDatabase.defaultExpectation.params = &ClientMockCreateDatabaseParams{ctx, serviceID, db}
	for _, e := range mmCreateDatabase.expectations {
		if minimock.Equal(e.params, mmCreateDatabase.defaultExpectation.params) {
			mmCreateDatabase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateDatabase.defaultExpectation.params)
		}
	}

	return mmCreateDatabase
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateDatabase
func (mmCreateDatabase *mClientMockCreateDatabase) ExpectCtxParam1(ctx context.Context) *mClientMockCreateDatabase {
	if mmCreateDatabase.mock.funcCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Set")
	}

	if mmCreateDatabase.defaultExpectation == nil {
		mmCreateDatabase.defaultExpectation = &ClientMockCreateDatabaseExpectation{}
	}

	if mmCreateDatabase.defaultExpectation.params != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Expect")
	}

	if mmCreateDatabase.defaultExpectation.paramPtrs == nil {
		mmCreateDatabase.defaultExpectation.paramPtrs = &ClientMockCreateDatabaseParamPtrs{}
	}
	mmCreateDatabase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateDatabase
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.CreateDatabase
func (mmCreateDatabase *mClientMockCreateDatabase) ExpectServiceIDParam2(serviceID string) *mClientMockCreateDatabase {
	if mmCreateDatabase.mock.funcCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Set")
	}

	if mmCreateDatabase.defaultExpectation == nil {
		mmCreateDatabase.defaultExpectation = &ClientMockCreateDatabaseExpectation{}
	}

	if mmCreateDatabase.defaultExpectation.params != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Expect")
	}

	if mmCreateDatabase.defaultExpectation.paramPtrs == nil {
		mmCreateDatabase.defaultExpectation.paramPtrs = &ClientMockCreateDatabaseParamPtrs{}
	}
	mmCreateDatabase.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmCreateDatabase
}

// ExpectDbParam3 sets up expected param db for Client.CreateDatabase
func (mmCreateDatabase *mClientMockCreateDatabase) ExpectDbParam3(db Database) *mClientMockCreateDatabase {
	if mmCreateDatabase.mock.funcCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Set")
	}

	if mmCreateDatabase.defaultExpectation == nil {
		mmCreateDatabase.defaultExpectation = &ClientMockCreateDatabaseExpectation{}
	}

	if mmCreateDatabase.defaultExpectation.params != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Expect")
	}

	if mmCreateDatabase.defaultExpectation.paramPtrs == nil {
		mmCreateDatabase.defaultExpectation.paramPtrs = &ClientMockCreateDatabaseParamPtrs{}
	}
	mmCreateDatabase.defaultExpectation.paramPtrs.db = &db

	return mmCreateDatabase
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateDatabase
func (mmCreateDatabase *mClientMockCreateDatabase) Inspect(f func(ctx context.Context, serviceID string, db Database)) *mClientMockCreateDatabase {
	if mmCreateDatabase.mock.inspectFuncCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateDatabase")
	}

	mmCreateDatabase.mock.inspectFuncCreateDatabase = f

	return mmCreateDatabase
}

// Return sets up results that will be returned by Client.CreateDatabase
func (mmCreateDatabase *mClientMockCreateDatabase) Return(err error) *ClientMock {
	if mmCreateDatabase.mock.funcCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Set")
	}

	if mmCreateDatabase.defaultExpectation == nil {
		mmCreateDatabase.defaultExpectation = &ClientMockCreateDatabaseExpectation{mock: mmCreateDatabase.mock}
	}
	mmCreateDatabase.defaultExpectation.results = &ClientMockCreateDatabaseResults{err}
	return mmCreateDatabase.mock
}

// Set uses given function f to mock the Client.CreateDatabase method
func (mmCreateDatabase *mClientMockCreateDatabase) Set(f func(ctx context.Context, serviceID string, db Database) (err error)) *ClientMock {
	if mmCreateDatabase.defaultExpectation != nil {
		mmCreateDatabase.mock.t.Fatalf("Default expectation is already set for the Client.CreateDatabase method")
	}

	if len(mmCreateDatabase.expectations) > 0 {
		mmCreateDatabase.mock.t.Fatalf("Some expectations are already set for the Client.CreateDatabase method")
	}

	mmCreateDatabase.mock.funcCreateDatabase = f
	return mmCreateDatabase.mock
}

// When sets expectation for the Client.CreateDatabase which will trigger the result defined by the following
// Then helper
func (mmCreateDatabase *mClientMockCreateDatabase) When(ctx context.Context, serviceID string, db Database) *ClientMockCreateDatabaseExpectation {
	if mmCreateDatabase.mock.funcCreateDatabase != nil {
		mmCreateDatabase.mock.t.Fatalf("ClientMock.CreateDatabase mock is already set by Set")
	}

	expectation := &ClientMockCreateDatabaseExpectation{
		mock:   mmCreateDatabase.mock,
		params: &ClientMockCreateDatabaseParams{ctx, serviceID, db},
	}
	mmCreateDatabase.expectations = append(mmCreateDatabase.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateDatabase return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateDatabaseExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockCreateDatabaseResults{err}
	return e.mock
}

// Times sets number of times Client.CreateDatabase should be invoked
func (mmCreateDatabase *mClientMockCreateDatabase) Times(n uint64) *mClientMockCreateDatabase {
	if n == 0 {
		mmCreateDatabase.mock.t.Fatalf("Times of ClientMock.CreateDatabase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateDatabase.expectedInvocations, n)
	return mmCreateDatabase
}

func (mmCreateDatabase *mClientMockCreateDatabase) invocationsDone() bool {
	if len(mmCreateDatabase.expectations) == 0 && mmCreateDatabase.defaultExpectation == nil && mmCreateDatabase.mock.funcCreateDatabase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateDatabase.mock.afterCreateDatabaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateDatabase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateDatabase implements Client
func (mmCreateDatabase *ClientMock) CreateDatabase(ctx context.Context, serviceID string, db Database) (err error) {
	mm_atomic.AddUint64(&mmCreateDatabase.beforeCreateDatabaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateDatabase.afterCreateDatabaseCounter, 1)

	if mmCreateDatabase.inspectFuncCreateDatabase != nil {
		mmCreateDatabase.inspectFuncCreateDatabase(ctx, serviceID, db)
	}

	mm_params := ClientMockCreateDatabaseParams{ctx, serviceID, db}

	// Record call args
	mmCreateDatabase.CreateDatabaseMock.mutex.Lock()
	mmCreateDatabase.CreateDatabaseMock.callArgs = append(mmCreateDatabase.CreateDatabaseMock.callArgs, &mm_params)
	mmCreateDatabase.CreateDatabaseMock.mutex.Unlock()

	for _, e := range mmCreateDatabase.CreateDatabaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateDatabase.CreateDatabaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateDatabase.CreateDatabaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateDatabase.CreateDatabaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateDatabase.CreateDatabaseMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateDatabaseParams{ctx, serviceID, db}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateDatabase.t.Errorf("ClientMock.CreateDatabase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmCreateDatabase.t.Errorf("ClientMock.CreateDatabase got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.db != nil && !minimock.Equal(*mm_want_ptrs.db, mm_got.db) {
				mmCreateDatabase.t.Errorf("ClientMock.CreateDatabase got unexpected parameter db, want: %#v, got: %#v%s\n", *mm_want_ptrs.db, mm_got.db, minimock.Diff(*mm_want_ptrs.db, mm_got.db))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateDatabase.t.Errorf("ClientMock.CreateDatabase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateDatabase.CreateDatabaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateDatabase.t.Fatal("No results are set for the ClientMock.CreateDatabase")
		}
		return (*mm_results).err
	}
	if mmCreateDatabase.funcCreateDatabase != nil {
		return mmCreateDatabase.funcCreateDatabase(ctx, serviceID, db)
	}
	mmCreateDatabase.t.Fatalf("Unexpected call to ClientMock.CreateDatabase. %v %v %v", ctx, serviceID, db)
	return
}

// CreateDatabaseAfterCounter returns a count of finished ClientMock.CreateDatabase invocations
func (mmCreateDatabase *ClientMock) CreateDatabaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDatabase.afterCreateDatabaseCounter)
}

// CreateDatabaseBeforeCounter returns a count of ClientMock.CreateDatabase invocations
func (mmCreateDatabase *ClientMock) CreateDatabaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDatabase.beforeCreateDatabaseCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateDatabase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateDatabase *mClientMockCreateDatabase) Calls() []*ClientMockCreateDatabaseParams {
	mmCreateDatabase.mutex.RLock()

	argCopy := make([]*ClientMockCreateDatabaseParams, len(mmCreateDatabase.callArgs))
	copy(argCopy, mmCreateDatabase.callArgs)

	mmCreateDatabase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDatabaseDone returns true if the count of the CreateDatabase invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateDatabaseDone() bool {
	if m.CreateDatabaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateDatabaseMock.invocationsDone()
}

// MinimockCreateDatabaseInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateDatabaseInspect() {
	for _, e := range m.CreateDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateDatabase with params: %#v", *e.params)
		}
	}

	afterCreateDatabaseCounter := mm_atomic.LoadUint64(&m.afterCreateDatabaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDatabaseMock.defaultExpectation != nil && afterCreateDatabaseCounter < 1 {
		if m.CreateDatabaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateDatabase")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateDatabase with params: %#v", *m.CreateDatabaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDatabase != nil && afterCreateDatabaseCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateDatabase")
	}

	if !m.CreateDatabaseMock.invocationsDone() && afterCreateDatabaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateDatabase but found %d calls",
			mm_atomic.LoadUint64(&m.CreateDatabaseMock.expectedInvocations), afterCreateDatabaseCounter)
	}
}

type mClientMockCreateQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateQueryEndpointExpectation
	expectations       []*ClientMockCreateQueryEndpointExpectation

	callArgs []*ClientMockCreateQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateQueryEndpointExpectation specifies expectation struct of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateQueryEndpointParams
	paramPtrs *ClientMockCreateQueryEndpointParamPtrs
	results   *ClientMockCreateQueryEndpointResults
	Counter   uint64
}

// ClientMockCreateQueryEndpointParams contains parameters of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
	endpoint  ServiceQueryEndpoint
}

// ClientMockCreateQueryEndpointParamPtrs contains pointers to parameters of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	endpoint  *ServiceQueryEndpoint
}

// ClientMockCreateQueryEndpointResults contains results of the Client.CreateQueryEndpoint
type ClientMockCreateQueryEndpointResults struct {
	sp1 *ServiceQueryEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Optional() *mClientMockCreateQueryEndpoint {
	mmCreateQueryEndpoint.optional = true
	return mmCreateQueryEndpoint
}

// Expect sets up expected params for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Expect(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmCreateQueryEndpoint.defaultExpectation.params = &ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}
	for _, e := range mmCreateQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmCreateQueryEndpoint.defaultExpectation.params) {
			mmCreateQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmCreateQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmCreateQueryEndpoint
}

// ExpectEndpointParam3 sets up expected param endpoint for Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) ExpectEndpointParam3(endpoint ServiceQueryEndpoint) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{}
	}

	if mmCreateQueryEndpoint.defaultExpectation.params != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Expect")
	}

	if mmCreateQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateQueryEndpointParamPtrs{}
	}
	mmCreateQueryEndpoint.defaultExpectation.paramPtrs.endpoint = &endpoint

	return mmCreateQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint)) *mClientMockCreateQueryEndpoint {
	if mmCreateQueryEndpoint.mock.inspectFuncCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateQueryEndpoint")
	}

	mmCreateQueryEndpoint.mock.inspectFuncCreateQueryEndpoint = f

	return mmCreateQueryEndpoint
}

// Return sets up results that will be returned by Client.CreateQueryEndpoint
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Return(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	if mmCreateQueryEndpoint.defaultExpectation == nil {
		mmCreateQueryEndpoint.defaultExpectation = &ClientMockCreateQueryEndpointExpectation{mock: mmCreateQueryEndpoint.mock}
	}
	mmCreateQueryEndpoint.defaultExpectation.results = &ClientMockCreateQueryEndpointResults{sp1, err}
	return mmCreateQueryEndpoint.mock
}

// Set uses given function f to mock the Client.CreateQueryEndpoint method
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Set(f func(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error)) *ClientMock {
	if mmCreateQueryEndpoint.defaultExpectation != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.CreateQueryEndpoint method")
	}

	if len(mmCreateQueryEndpoint.expectations) > 0 {
		mmCreateQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.CreateQueryEndpoint method")
	}

	mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint = f
	return mmCreateQueryEndpoint.mock
}

// When sets expectation for the Client.CreateQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) When(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) *ClientMockCreateQueryEndpointExpectation {
	if mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.mock.t.Fatalf("ClientMock.CreateQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockCreateQueryEndpointExpectation{
		mock:   mmCreateQueryEndpoint.mock,
		params: &ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint},
	}
	mmCreateQueryEndpoint.expectations = append(mmCreateQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateQueryEndpointExpectation) Then(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	e.results = &ClientMockCreateQueryEndpointResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.CreateQueryEndpoint should be invoked
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Times(n uint64) *mClientMockCreateQueryEndpoint {
	if n == 0 {
		mmCreateQueryEndpoint.mock.t.Fatalf("Times of ClientMock.CreateQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateQueryEndpoint.expectedInvocations, n)
	return mmCreateQueryEndpoint
}

func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) invocationsDone() bool {
	if len(mmCreateQueryEndpoint.expectations) == 0 && mmCreateQueryEndpoint.defaultExpectation == nil && mmCreateQueryEndpoint.mock.funcCreateQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateQueryEndpoint.mock.afterCreateQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateQueryEndpoint implements Client
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpoint(ctx context.Context, serviceID string, endpoint ServiceQueryEndpoint) (sp1 *ServiceQueryEndpoint, err error) {
	mm_atomic.AddUint64(&mmCreateQueryEndpoint.beforeCreateQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateQueryEndpoint.afterCreateQueryEndpointCounter, 1)

	if mmCreateQueryEndpoint.inspectFuncCreateQueryEndpoint != nil {
		mmCreateQueryEndpoint.inspectFuncCreateQueryEndpoint(ctx, serviceID, endpoint)
	}

	mm_params := ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}

	// Record call args
	mmCreateQueryEndpoint.CreateQueryEndpointMock.mutex.Lock()
	mmCreateQueryEndpoint.CreateQueryEndpointMock.callArgs = append(mmCreateQueryEndpoint.CreateQueryEndpointMock.callArgs, &mm_params)
	mmCreateQueryEndpoint.CreateQueryEndpointMock.mutex.Unlock()

	for _, e := range mmCreateQueryEndpoint.CreateQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateQueryEndpointParams{ctx, serviceID, endpoint}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.endpoint != nil && !minimock.Equal(*mm_want_ptrs.endpoint, mm_got.endpoint) {
				mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameter endpoint, want: %#v, got: %#v%s\n", *mm_want_ptrs.endpoint, mm_got.endpoint, minimock.Diff(*mm_want_ptrs.endpoint, mm_got.endpoint))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateQueryEndpoint.t.Errorf("ClientMock.CreateQueryEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateQueryEndpoint.CreateQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateQueryEndpoint.t.Fatal("No results are set for the ClientMock.CreateQueryEndpoint")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmCreateQueryEndpoint.funcCreateQueryEndpoint != nil {
		return mmCreateQueryEndpoint.funcCreateQueryEndpoint(ctx, serviceID, endpoint)
	}
	mmCreateQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.CreateQueryEndpoint. %v %v %v", ctx, serviceID, endpoint)
	return
}

// CreateQueryEndpointAfterCounter returns a count of finished ClientMock.CreateQueryEndpoint invocations
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateQueryEndpoint.afterCreateQueryEndpointCounter)
}

// CreateQueryEndpointBeforeCounter returns a count of ClientMock.CreateQueryEndpoint invocations
func (mmCreateQueryEndpoint *ClientMock) CreateQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateQueryEndpoint.beforeCreateQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateQueryEndpoint *mClientMockCreateQueryEndpoint) Calls() []*ClientMockCreateQueryEndpointParams {
	mmCreateQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockCreateQueryEndpointParams, len(mmCreateQueryEndpoint.callArgs))
	copy(argCopy, mmCreateQueryEndpoint.callArgs)

	mmCreateQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockCreateQueryEndpointDone returns true if the count of the CreateQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateQueryEndpointDone() bool {
	if m.CreateQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateQueryEndpointMock.invocationsDone()
}

// MinimockCreateQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateQueryEndpointInspect() {
	for _, e := range m.CreateQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint with params: %#v", *e.params)
		}
	}

	afterCreateQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterCreateQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateQueryEndpointMock.defaultExpectation != nil && afterCreateQueryEndpointCounter < 1 {
		if m.CreateQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateQueryEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateQueryEndpoint with params: %#v", *m.CreateQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateQueryEndpoint != nil && afterCreateQueryEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateQueryEndpoint")
	}

	if !m.CreateQueryEndpointMock.invocationsDone() && afterCreateQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateQueryEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.CreateQueryEndpointMock.expectedInvocations), afterCreateQueryEndpointCounter)
	}
}

type mClientMockCreateReversePrivateEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateReversePrivateEndpointExpectation
	expectations       []*ClientMockCreateReversePrivateEndpointExpectation

	callArgs []*ClientMockCreateReversePrivateEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateReversePrivateEndpointExpectation specifies expectation struct of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateReversePrivateEndpointParams
	paramPtrs *ClientMockCreateReversePrivateEndpointParamPtrs
	results   *ClientMockCreateReversePrivateEndpointResults
	Counter   uint64
}

// ClientMockCreateReversePrivateEndpointParams contains parameters of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointParams struct {
	ctx       context.Context
	serviceId string
	request   CreateReversePrivateEndpoint
}

// ClientMockCreateReversePrivateEndpointParamPtrs contains pointers to parameters of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	request   *CreateReversePrivateEndpoint
}

// ClientMockCreateReversePrivateEndpointResults contains results of the Client.CreateReversePrivateEndpoint
type ClientMockCreateReversePrivateEndpointResults struct {
	rp1 *ReversePrivateEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Optional() *mClientMockCreateReversePrivateEndpoint {
	mmCreateReversePrivateEndpoint.optional = true
	return mmCreateReversePrivateEndpoint
}

// Expect sets up expected params for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Expect(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by ExpectParams functions")
	}

	mmCreateReversePrivateEndpoint.defaultExpectation.params = &ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request}
	for _, e := range mmCreateReversePrivateEndpoint.expectations {
		if minimock.Equal(e.params, mmCreateReversePrivateEndpoint.defaultExpectation.params) {
			mmCreateReversePrivateEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReversePrivateEndpoint.defaultExpectation.params)
		}
	}

	return mmCreateReversePrivateEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.params != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Expect")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateReversePrivateEndpointParamPtrs{}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateReversePrivateEndpoint
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) ExpectServiceIdParam2(serviceId string) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.params != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Expect")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateReversePrivateEndpointParamPtrs{}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmCreateReversePrivateEndpoint
}

// ExpectRequestParam3 sets up expected param request for Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) ExpectRequestParam3(request CreateReversePrivateEndpoint) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{}
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.params != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Expect")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockCreateReversePrivateEndpointParamPtrs{}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.paramPtrs.request = &request

	return mmCreateReversePrivateEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Inspect(f func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint)) *mClientMockCreateReversePrivateEndpoint {
	if mmCreateReversePrivateEndpoint.mock.inspectFuncCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateReversePrivateEndpoint")
	}

	mmCreateReversePrivateEndpoint.mock.inspectFuncCreateReversePrivateEndpoint = f

	return mmCreateReversePrivateEndpoint
}

// Return sets up results that will be returned by Client.CreateReversePrivateEndpoint
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Return(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	if mmCreateReversePrivateEndpoint.defaultExpectation == nil {
		mmCreateReversePrivateEndpoint.defaultExpectation = &ClientMockCreateReversePrivateEndpointExpectation{mock: mmCreateReversePrivateEndpoint.mock}
	}
	mmCreateReversePrivateEndpoint.defaultExpectation.results = &ClientMockCreateReversePrivateEndpointResults{rp1, err}
	return mmCreateReversePrivateEndpoint.mock
}

// Set uses given function f to mock the Client.CreateReversePrivateEndpoint method
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Set(f func(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) (rp1 *ReversePrivateEndpoint, err error)) *ClientMock {
	if mmCreateReversePrivateEndpoint.defaultExpectation != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.CreateReversePrivateEndpoint method")
	}

	if len(mmCreateReversePrivateEndpoint.expectations) > 0 {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.CreateReversePrivateEndpoint method")
	}

	mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint = f
	return mmCreateReversePrivateEndpoint.mock
}

// When sets expectation for the Client.CreateReversePrivateEndpoint which will trigger the result defined by the following
// Then helper
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) When(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) *ClientMockCreateReversePrivateEndpointExpectation {
	if mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("ClientMock.CreateReversePrivateEndpoint mock is already set by Set")
	}

	expectation := &ClientMockCreateReversePrivateEndpointExpectation{
		mock:   mmCreateReversePrivateEndpoint.mock,
		params: &ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request},
	}
	mmCreateReversePrivateEndpoint.expectations = append(mmCreateReversePrivateEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateReversePrivateEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateReversePrivateEndpointExpectation) Then(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockCreateReversePrivateEndpointResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.CreateReversePrivateEndpoint should be invoked
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Times(n uint64) *mClientMockCreateReversePrivateEndpoint {
	if n == 0 {
		mmCreateReversePrivateEndpoint.mock.t.Fatalf("Times of ClientMock.CreateReversePrivateEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReversePrivateEndpoint.expectedInvocations, n)
	return mmCreateReversePrivateEndpoint
}

func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) invocationsDone() bool {
	if len(mmCreateReversePrivateEndpoint.expectations) == 0 && mmCreateReversePrivateEndpoint.defaultExpectation == nil && mmCreateReversePrivateEndpoint.mock.funcCreateReversePrivateEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.mock.afterCreateReversePrivateEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReversePrivateEndpoint implements Client
func (mmCreateReversePrivateEndpoint *ClientMock) CreateReversePrivateEndpoint(ctx context.Context, serviceId string, request CreateReversePrivateEndpoint) (rp1 *ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmCreateReversePrivateEndpoint.beforeCreateReversePrivateEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReversePrivateEndpoint.afterCreateReversePrivateEndpointCounter, 1)

	if mmCreateReversePrivateEndpoint.inspectFuncCreateReversePrivateEndpoint != nil {
		mmCreateReversePrivateEndpoint.inspectFuncCreateReversePrivateEndpoint(ctx, serviceId, request)
	}

	mm_params := ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request}

	// Record call args
	mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.mutex.Lock()
	mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.callArgs = append(mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.callArgs, &mm_params)
	mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.mutex.Unlock()

	for _, e := range mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateReversePrivateEndpointParams{ctx, serviceId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameter request, want: %#v, got: %#v%s\n", *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReversePrivateEndpoint.t.Errorf("ClientMock.CreateReversePrivateEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReversePrivateEndpoint.CreateReversePrivateEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReversePrivateEndpoint.t.Fatal("No results are set for the ClientMock.CreateReversePrivateEndpoint")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateReversePrivateEndpoint.funcCreateReversePrivateEndpoint != nil {
		return mmCreateReversePrivateEndpoint.funcCreateReversePrivateEndpoint(ctx, serviceId, request)
	}
	mmCreateReversePrivateEndpoint.t.Fatalf("Unexpected call to ClientMock.CreateReversePrivateEndpoint. %v %v %v", ctx, serviceId, request)
	return
}

// CreateReversePrivateEndpointAfterCounter returns a count of finished ClientMock.CreateReversePrivateEndpoint invocations
func (mmCreateReversePrivateEndpoint *ClientMock) CreateReversePrivateEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.afterCreateReversePrivateEndpointCounter)
}

// CreateReversePrivateEndpointBeforeCounter returns a count of ClientMock.CreateReversePrivateEndpoint invocations
func (mmCreateReversePrivateEndpoint *ClientMock) CreateReversePrivateEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReversePrivateEndpoint.beforeCreateReversePrivateEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateReversePrivateEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReversePrivateEndpoint *mClientMockCreateReversePrivateEndpoint) Calls() []*ClientMockCreateReversePrivateEndpointParams {
	mmCreateReversePrivateEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockCreateReversePrivateEndpointParams, len(mmCreateReversePrivateEndpoint.callArgs))
	copy(argCopy, mmCreateReversePrivateEndpoint.callArgs)

	mmCreateReversePrivateEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReversePrivateEndpointDone returns true if the count of the CreateReversePrivateEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateReversePrivateEndpointDone() bool {
	if m.CreateReversePrivateEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReversePrivateEndpointMock.invocationsDone()
}

// MinimockCreateReversePrivateEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateReversePrivateEndpointInspect() {
	for _, e := range m.CreateReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateReversePrivateEndpoint with params: %#v", *e.params)
		}
	}

	afterCreateReversePrivateEndpointCounter := mm_atomic.LoadUint64(&m.afterCreateReversePrivateEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReversePrivateEndpointMock.defaultExpectation != nil && afterCreateReversePrivateEndpointCounter < 1 {
		if m.CreateReversePrivateEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateReversePrivateEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateReversePrivateEndpoint with params: %#v", *m.CreateReversePrivateEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReversePrivateEndpoint != nil && afterCreateReversePrivateEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateReversePrivateEndpoint")
	}

	if !m.CreateReversePrivateEndpointMock.invocationsDone() && afterCreateReversePrivateEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateReversePrivateEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReversePrivateEndpointMock.expectedInvocations), afterCreateReversePrivateEndpointCounter)
	}
}

type mClientMockCreateRole struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateRoleExpectation
	expectations       []*ClientMockCreateRoleExpectation

	callArgs []*ClientMockCreateRoleParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateRoleExpectation specifies expectation struct of the Client.CreateRole
type ClientMockCreateRoleExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateRoleParams
	paramPtrs *ClientMockCreateRoleParamPtrs
	results   *ClientMockCreateRoleResults
	Counter   uint64
}

// ClientMockCreateRoleParams contains parameters of the Client.CreateRole
type ClientMockCreateRoleParams struct {
	ctx       context.Context
	serviceId string
	role      Role
}

// ClientMockCreateRoleParamPtrs contains pointers to parameters of the Client.CreateRole
type ClientMockCreateRoleParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	role      *Role
}

// ClientMockCreateRoleResults contains results of the Client.CreateRole
type ClientMockCreateRoleResults struct {
	rp1 *Role
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRole *mClientMockCreateRole) Optional() *mClientMockCreateRole {
	mmCreateRole.optional = true
	return mmCreateRole
}

// Expect sets up expected params for Client.CreateRole
func (mmCreateRole *mClientMockCreateRole) Expect(ctx context.Context, serviceId string, role Role) *mClientMockCreateRole {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &ClientMockCreateRoleExpectation{}
	}

	if mmCreateRole.defaultExpectation.paramPtrs != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by ExpectParams functions")
	}

	mmCreateRole.defaultExpectation.params = &ClientMockCreateRoleParams{ctx, serviceId, role}
	for _, e := range mmCreateRole.expectations {
		if minimock.Equal(e.params, mmCreateRole.defaultExpectation.params) {
			mmCreateRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRole.defaultExpectation.params)
		}
	}

	return mmCreateRole
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateRole
func (mmCreateRole *mClientMockCreateRole) ExpectCtxParam1(ctx context.Context) *mClientMockCreateRole {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &ClientMockCreateRoleExpectation{}
	}

	if mmCreateRole.defaultExpectation.params != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Expect")
	}

	if mmCreateRole.defaultExpectation.paramPtrs == nil {
		mmCreateRole.defaultExpectation.paramPtrs = &ClientMockCreateRoleParamPtrs{}
	}
	mmCreateRole.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateRole
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateRole
func (mmCreateRole *mClientMockCreateRole) ExpectServiceIdParam2(serviceId string) *mClientMockCreateRole {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &ClientMockCreateRoleExpectation{}
	}

	if mmCreateRole.defaultExpectation.params != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Expect")
	}

	if mmCreateRole.defaultExpectation.paramPtrs == nil {
		mmCreateRole.defaultExpectation.paramPtrs = &ClientMockCreateRoleParamPtrs{}
	}
	mmCreateRole.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmCreateRole
}

// ExpectRoleParam3 sets up expected param role for Client.CreateRole
func (mmCreateRole *mClientMockCreateRole) ExpectRoleParam3(role Role) *mClientMockCreateRole {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &ClientMockCreateRoleExpectation{}
	}

	if mmCreateRole.defaultExpectation.params != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Expect")
	}

	if mmCreateRole.defaultExpectation.paramPtrs == nil {
		mmCreateRole.defaultExpectation.paramPtrs = &ClientMockCreateRoleParamPtrs{}
	}
	mmCreateRole.defaultExpectation.paramPtrs.role = &role

	return mmCreateRole
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateRole
func (mmCreateRole *mClientMockCreateRole) Inspect(f func(ctx context.Context, serviceId string, role Role)) *mClientMockCreateRole {
	if mmCreateRole.mock.inspectFuncCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateRole")
	}

	mmCreateRole.mock.inspectFuncCreateRole = f

	return mmCreateRole
}

// Return sets up results that will be returned by Client.CreateRole
func (mmCreateRole *mClientMockCreateRole) Return(rp1 *Role, err error) *ClientMock {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &ClientMockCreateRoleExpectation{mock: mmCreateRole.mock}
	}
	mmCreateRole.defaultExpectation.results = &ClientMockCreateRoleResults{rp1, err}
	return mmCreateRole.mock
}

// Set uses given function f to mock the Client.CreateRole method
func (mmCreateRole *mClientMockCreateRole) Set(f func(ctx context.Context, serviceId string, role Role) (rp1 *Role, err error)) *ClientMock {
	if mmCreateRole.defaultExpectation != nil {
		mmCreateRole.mock.t.Fatalf("Default expectation is already set for the Client.CreateRole method")
	}

	if len(mmCreateRole.expectations) > 0 {
		mmCreateRole.mock.t.Fatalf("Some expectations are already set for the Client.CreateRole method")
	}

	mmCreateRole.mock.funcCreateRole = f
	return mmCreateRole.mock
}

// When sets expectation for the Client.CreateRole which will trigger the result defined by the following
// Then helper
func (mmCreateRole *mClientMockCreateRole) When(ctx context.Context, serviceId string, role Role) *ClientMockCreateRoleExpectation {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("ClientMock.CreateRole mock is already set by Set")
	}

	expectation := &ClientMockCreateRoleExpectation{
		mock:   mmCreateRole.mock,
		params: &ClientMockCreateRoleParams{ctx, serviceId, role},
	}
	mmCreateRole.expectations = append(mmCreateRole.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateRole return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateRoleExpectation) Then(rp1 *Role, err error) *ClientMock {
	e.results = &ClientMockCreateRoleResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.CreateRole should be invoked
func (mmCreateRole *mClientMockCreateRole) Times(n uint64) *mClientMockCreateRole {
	if n == 0 {
		mmCreateRole.mock.t.Fatalf("Times of ClientMock.CreateRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRole.expectedInvocations, n)
	return mmCreateRole
}

func (mmCreateRole *mClientMockCreateRole) invocationsDone() bool {
	if len(mmCreateRole.expectations) == 0 && mmCreateRole.defaultExpectation == nil && mmCreateRole.mock.funcCreateRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRole.mock.afterCreateRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRole implements Client
func (mmCreateRole *ClientMock) CreateRole(ctx context.Context, serviceId string, role Role) (rp1 *Role, err error) {
	mm_atomic.AddUint64(&mmCreateRole.beforeCreateRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRole.afterCreateRoleCounter, 1)

	if mmCreateRole.inspectFuncCreateRole != nil {
		mmCreateRole.inspectFuncCreateRole(ctx, serviceId, role)
	}

	mm_params := ClientMockCreateRoleParams{ctx, serviceId, role}

	// Record call args
	mmCreateRole.CreateRoleMock.mutex.Lock()
	mmCreateRole.CreateRoleMock.callArgs = append(mmCreateRole.CreateRoleMock.callArgs, &mm_params)
	mmCreateRole.CreateRoleMock.mutex.Unlock()

	for _, e := range mmCreateRole.CreateRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateRole.CreateRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRole.CreateRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRole.CreateRoleMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRole.CreateRoleMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateRoleParams{ctx, serviceId, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRole.t.Errorf("ClientMock.CreateRole got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateRole.t.Errorf("ClientMock.CreateRole got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCreateRole.t.Errorf("ClientMock.CreateRole got unexpected parameter role, want: %#v, got: %#v%s\n", *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRole.t.Errorf("ClientMock.CreateRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRole.CreateRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRole.t.Fatal("No results are set for the ClientMock.CreateRole")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateRole.funcCreateRole != nil {
		return mmCreateRole.funcCreateRole(ctx, serviceId, role)
	}
	mmCreateRole.t.Fatalf("Unexpected call to ClientMock.CreateRole. %v %v %v", ctx, serviceId, role)
	return
}

// CreateRoleAfterCounter returns a count of finished ClientMock.CreateRole invocations
func (mmCreateRole *ClientMock) CreateRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRole.afterCreateRoleCounter)
}

// CreateRoleBeforeCounter returns a count of ClientMock.CreateRole invocations
func (mmCreateRole *ClientMock) CreateRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRole.beforeCreateRoleCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRole *mClientMockCreateRole) Calls() []*ClientMockCreateRoleParams {
	mmCreateRole.mutex.RLock()

	argCopy := make([]*ClientMockCreateRoleParams, len(mmCreateRole.callArgs))
	copy(argCopy, mmCreateRole.callArgs)

	mmCreateRole.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRoleDone returns true if the count of the CreateRole invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateRoleDone() bool {
	if m.CreateRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRoleMock.invocationsDone()
}

// MinimockCreateRoleInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateRoleInspect() {
	for _, e := range m.CreateRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateRole with params: %#v", *e.params)
		}
	}

	afterCreateRoleCounter := mm_atomic.LoadUint64(&m.afterCreateRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRoleMock.defaultExpectation != nil && afterCreateRoleCounter < 1 {
		if m.CreateRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateRole")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateRole with params: %#v", *m.CreateRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRole != nil && afterCreateRoleCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateRole")
	}

	if !m.CreateRoleMock.invocationsDone() && afterCreateRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateRole but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRoleMock.expectedInvocations), afterCreateRoleCounter)
	}
}

type mClientMockCreateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateServiceExpectation
	expectations       []*ClientMockCreateServiceExpectation

	callArgs []*ClientMockCreateServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateServiceExpectation specifies expectation struct of the Client.CreateService
type ClientMockCreateServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateServiceParams
	paramPtrs *ClientMockCreateServiceParamPtrs
	results   *ClientMockCreateServiceResults
	Counter   uint64
}

// ClientMockCreateServiceParams contains parameters of the Client.CreateService
type ClientMockCreateServiceParams struct {
	ctx context.Context
	s   Service
}

// ClientMockCreateServiceParamPtrs contains pointers to parameters of the Client.CreateService
type ClientMockCreateServiceParamPtrs struct {
	ctx *context.Context
	s   *Service
}

// ClientMockCreateServiceResults contains results of the Client.CreateService
type ClientMockCreateServiceResults struct {
	sp1 *Service
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateService *mClientMockCreateService) Optional() *mClientMockCreateService {
	mmCreateService.optional = true
	return mmCreateService
}

// Expect sets up expected params for Client.CreateService
func (mmCreateService *mClientMockCreateService) Expect(ctx context.Context, s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.paramPtrs != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by ExpectParams functions")
	}

	mmCreateService.defaultExpectation.params = &ClientMockCreateServiceParams{ctx, s}
	for _, e := range mmCreateService.expectations {
		if minimock.Equal(e.params, mmCreateService.defaultExpectation.params) {
			mmCreateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateService.defaultExpectation.params)
		}
	}

	return mmCreateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectCtxParam1(ctx context.Context) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateService
}

// ExpectSParam2 sets up expected param s for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectSParam2(s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.s = &s

	return mmCreateService
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateService
func (mmCreateService *mClientMockCreateService) Inspect(f func(ctx context.Context, s Service)) *mClientMockCreateService {
	if mmCreateService.mock.inspectFuncCreateService != nil {
		mmCreateService.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateService")
	}

	mmCreateService.mock.inspectFuncCreateService = f

	return mmCreateService
}

// Return sets up results that will be returned by Client.CreateService
func (mmCreateService *mClientMockCreateService) Return(sp1 *Service, s1 string, err error) *ClientMock {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{mock: mmCreateService.mock}
	}
	mmCreateService.defaultExpectation.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return mmCreateService.mock
}

// Set uses given function f to mock the Client.CreateService method
func (mmCreateService *mClientMockCreateService) Set(f func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)) *ClientMock {
	if mmCreateService.defaultExpectation != nil {
		mmCreateService.mock.t.Fatalf("Default expectation is already set for the Client.CreateService method")
	}

	if len(mmCreateService.expectations) > 0 {
		mmCreateService.mock.t.Fatalf("Some expectations are already set for the Client.CreateService method")
	}

	mmCreateService.mock.funcCreateService = f
	return mmCreateService.mock
}

// When sets expectation for the Client.CreateService which will trigger the result defined by the following
// Then helper
func (mmCreateService *mClientMockCreateService) When(ctx context.Context, s Service) *ClientMockCreateServiceExpectation {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	expectation := &ClientMockCreateServiceExpectation{
		mock:   mmCreateService.mock,
		params: &ClientMockCreateServiceParams{ctx, s},
	}
	mmCreateService.expectations = append(mmCreateService.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateService return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateServiceExpectation) Then(sp1 *Service, s1 string, err error) *ClientMock {
	e.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return e.mock
}

// Times sets number of times Client.CreateService should be invoked
func (mmCreateService *mClientMockCreateService) Times(n uint64) *mClientMockCreateService {
	if n == 0 {
		mmCreateService.mock.t.Fatalf("Times of ClientMock.CreateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateService.expectedInvocations, n)
	return mmCreateService
}

func (mmCreateService *mClientMockCreateService) invocationsDone() bool {
	if len(mmCreateService.expectations) == 0 && mmCreateService.defaultExpectation == nil && mmCreateService.mock.funcCreateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateService.mock.afterCreateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateService implements Client
func (mmCreateService *ClientMock) CreateService(ctx context.Context, s Service) (sp1 *Service, s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateService.beforeCreateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateService.afterCreateServiceCounter, 1)

	if mmCreateService.inspectFuncCreateService != nil {
		mmCreateService.inspectFuncCreateService(ctx, s)
	}

	mm_params := ClientMockCreateServiceParams{ctx, s}

	// Record call args
	mmCreateService.CreateServiceMock.mutex.Lock()
	mmCreateService.CreateServiceMock.callArgs = append(mmCreateService.CreateServiceMock.callArgs, &mm_params)
	mmCreateService.CreateServiceMock.mutex.Unlock()

	for _, e := range mmCreateService.CreateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.err
		}
	}

	if mmCreateService.CreateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateService.CreateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateService.CreateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmCreateService.CreateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateServiceParams{ctx, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateService.CreateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateService.t.Fatal("No results are set for the ClientMock.CreateService")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).err
	}
	if mmCreateService.funcCreateService != nil {
		return mmCreateService.funcCreateService(ctx, s)
	}
	mmCreateService.t.Fatalf("Unexpected call to ClientMock.CreateService. %v %v", ctx, s)
	return
}

// CreateServiceAfterCounter returns a count of finished ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.afterCreateServiceCounter)
}

// CreateServiceBeforeCounter returns a count of ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.beforeCreateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateService *mClientMockCreateService) Calls() []*ClientMockCreateServiceParams {
	mmCreateService.mutex.RLock()

	argCopy := make([]*ClientMockCreateServiceParams, len(mmCreateService.callArgs))
	copy(argCopy, mmCreateService.callArgs)

	mmCreateService.mutex.RUnlock()

	return argCopy
}

// MinimockCreateServiceDone returns true if the count of the CreateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateServiceDone() bool {
	if m.CreateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateServiceMock.invocationsDone()
}

// MinimockCreateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateServiceInspect() {
	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateService with params: %#v", *e.params)
		}
	}

	afterCreateServiceCounter := mm_atomic.LoadUint64(&m.afterCreateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceMock.defaultExpectation != nil && afterCreateServiceCounter < 1 {
		if m.CreateServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateService")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateService with params: %#v", *m.CreateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateService != nil && afterCreateServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateService")
	}

	if !m.CreateServiceMock.invocationsDone() && afterCreateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateService but found %d calls",
			mm_atomic.LoadUint64(&m.CreateServiceMock.expectedInvocations), afterCreateServiceCounter)
	}
}

type mClientMockCreateUser struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateUserExpectation
	expectations       []*ClientMockCreateUserExpectation

	callArgs []*ClientMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateUserExpectation specifies expectation struct of the Client.CreateUser
type ClientMockCreateUserExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateUserParams
	paramPtrs *ClientMockCreateUserParamPtrs
	results   *ClientMockCreateUserResults
	Counter   uint64
}

// ClientMockCreateUserParams contains parameters of the Client.CreateUser
type ClientMockCreateUserParams struct {
	ctx       context.Context
	serviceId string
	user      User
}

// ClientMockCreateUserParamPtrs contains pointers to parameters of the Client.CreateUser
type ClientMockCreateUserParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	user      *User
}

// ClientMockCreateUserResults contains results of the Client.CreateUser
type ClientMockCreateUserResults struct {
	up1 *User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mClientMockCreateUser) Optional() *mClientMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) Expect(ctx context.Context, serviceId string, user User) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &ClientMockCreateUserParams{ctx, serviceId, user}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) ExpectCtxParam1(ctx context.Context) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ClientMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateUser
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) ExpectServiceIdParam2(serviceId string) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ClientMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmCreateUser
}

// ExpectUserParam3 sets up expected param user for Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) ExpectUserParam3(user User) *mClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ClientMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) Inspect(f func(ctx context.Context, serviceId string, user User)) *mClientMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Client.CreateUser
func (mmCreateUser *mClientMockCreateUser) Return(up1 *User, err error) *ClientMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ClientMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &ClientMockCreateUserResults{up1, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the Client.CreateUser method
func (mmCreateUser *mClientMockCreateUser) Set(f func(ctx context.Context, serviceId string, user User) (up1 *User, err error)) *ClientMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Client.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Client.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Client.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mClientMockCreateUser) When(ctx context.Context, serviceId string, user User) *ClientMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ClientMock.CreateUser mock is already set by Set")
	}

	expectation := &ClientMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &ClientMockCreateUserParams{ctx, serviceId, user},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateUser return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateUserExpectation) Then(up1 *User, err error) *ClientMock {
	e.results = &ClientMockCreateUserResults{up1, err}
	return e.mock
}

// Times sets number of times Client.CreateUser should be invoked
func (mmCreateUser *mClientMockCreateUser) Times(n uint64) *mClientMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of ClientMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	return mmCreateUser
}

func (mmCreateUser *mClientMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements Client
func (mmCreateUser *ClientMock) CreateUser(ctx context.Context, serviceId string, user User) (up1 *User, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, serviceId, user)
	}

	mm_params := ClientMockCreateUserParams{ctx, serviceId, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateUserParams{ctx, serviceId, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("ClientMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the ClientMock.CreateUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, serviceId, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to ClientMock.CreateUser. %v %v %v", ctx, serviceId, user)
	return
}

// CreateUserAfterCounter returns a count of finished ClientMock.CreateUser invocations
func (mmCreateUser *ClientMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of ClientMock.CreateUser invocations
func (mmCreateUser *ClientMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mClientMockCreateUser) Calls() []*ClientMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*ClientMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateUser with params: %#v", *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateUser")
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
	}
}

type mClientMockDeleteApiKey struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteApiKeyExpectation
	expectations       []*ClientMockDeleteApiKeyExpectation

	callArgs []*ClientMockDeleteApiKeyParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteApiKeyExpectation specifies expectation struct of the Client.DeleteApiKey
type ClientMockDeleteApiKeyExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteApiKeyParams
	paramPtrs *ClientMockDeleteApiKeyParamPtrs
	results   *ClientMockDeleteApiKeyResults
	Counter   uint64
}

// ClientMockDeleteApiKeyParams contains parameters of the Client.DeleteApiKey
type ClientMockDeleteApiKeyParams struct {
	ctx context.Context
	id  string
}

// ClientMockDeleteApiKeyParamPtrs contains pointers to parameters of the Client.DeleteApiKey
type ClientMockDeleteApiKeyParamPtrs struct {
	ctx *context.Context
	id  *string
}

// ClientMockDeleteApiKeyResults contains results of the Client.DeleteApiKey
type ClientMockDeleteApiKeyResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteApiKey *mClientMockDeleteApiKey) Optional() *mClientMockDeleteApiKey {
	mmDeleteApiKey.optional = true
	return mmDeleteApiKey
}

// Expect sets up expected params for Client.DeleteApiKey
func (mmDeleteApiKey *mClientMockDeleteApiKey) Expect(ctx context.Context, id string) *mClientMockDeleteApiKey {
	if mmDeleteApiKey.mock.funcDeleteApiKey != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Set")
	}

	if mmDeleteApiKey.defaultExpectation == nil {
		mmDeleteApiKey.defaultExpectation = &ClientMockDeleteApiKeyExpectation{}
	}

	if mmDeleteApiKey.defaultExpectation.paramPtrs != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by ExpectParams functions")
	}

	mmDeleteApiKey.defaultExpectation.params = &ClientMockDeleteApiKeyParams{ctx, id}
	for _, e := range mmDeleteApiKey.expectations {
		if minimock.Equal(e.params, mmDeleteApiKey.defaultExpectation.params) {
			mmDeleteApiKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteApiKey.defaultExpectation.params)
		}
	}

	return mmDeleteApiKey
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteApiKey
func (mmDeleteApiKey *mClientMockDeleteApiKey) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteApiKey {
	if mmDeleteApiKey.mock.funcDeleteApiKey != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Set")
	}

	if mmDeleteApiKey.defaultExpectation == nil {
		mmDeleteApiKey.defaultExpectation = &ClientMockDeleteApiKeyExpectation{}
	}

	if mmDeleteApiKey.defaultExpectation.params != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Expect")
	}

	if mmDeleteApiKey.defaultExpectation.paramPtrs == nil {
		mmDeleteApiKey.defaultExpectation.paramPtrs = &ClientMockDeleteApiKeyParamPtrs{}
	}
	mmDeleteApiKey.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteApiKey
}

// ExpectIdParam2 sets up expected param id for Client.DeleteApiKey
func (mmDeleteApiKey *mClientMockDeleteApiKey) ExpectIdParam2(id string) *mClientMockDeleteApiKey {
	if mmDeleteApiKey.mock.funcDeleteApiKey != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Set")
	}

	if mmDeleteApiKey.defaultExpectation == nil {
		mmDeleteApiKey.defaultExpectation = &ClientMockDeleteApiKeyExpectation{}
	}

	if mmDeleteApiKey.defaultExpectation.params != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Expect")
	}

	if mmDeleteApiKey.defaultExpectation.paramPtrs == nil {
		mmDeleteApiKey.defaultExpectation.paramPtrs = &ClientMockDeleteApiKeyParamPtrs{}
	}
	mmDeleteApiKey.defaultExpectation.paramPtrs.id = &id

	return mmDeleteApiKey
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteApiKey
func (mmDeleteApiKey *mClientMockDeleteApiKey) Inspect(f func(ctx context.Context, id string)) *mClientMockDeleteApiKey {
	if mmDeleteApiKey.mock.inspectFuncDeleteApiKey != nil {
		mmDeleteApiKey.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteApiKey")
	}

	mmDeleteApiKey.mock.inspectFuncDeleteApiKey = f

	return mmDeleteApiKey
}

// Return sets up results that will be returned by Client.DeleteApiKey
func (mmDeleteApiKey *mClientMockDeleteApiKey) Return(err error) *ClientMock {
	if mmDeleteApiKey.mock.funcDeleteApiKey != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Set")
	}

	if mmDeleteApiKey.defaultExpectation == nil {
		mmDeleteApiKey.defaultExpectation = &ClientMockDeleteApiKeyExpectation{mock: mmDeleteApiKey.mock}
	}
	mmDeleteApiKey.defaultExpectation.results = &ClientMockDeleteApiKeyResults{err}
	return mmDeleteApiKey.mock
}

// Set uses given function f to mock the Client.DeleteApiKey method
func (mmDeleteApiKey *mClientMockDeleteApiKey) Set(f func(ctx context.Context, id string) (err error)) *ClientMock {
	if mmDeleteApiKey.defaultExpectation != nil {
		mmDeleteApiKey.mock.t.Fatalf("Default expectation is already set for the Client.DeleteApiKey method")
	}

	if len(mmDeleteApiKey.expectations) > 0 {
		mmDeleteApiKey.mock.t.Fatalf("Some expectations are already set for the Client.DeleteApiKey method")
	}

	mmDeleteApiKey.mock.funcDeleteApiKey = f
	return mmDeleteApiKey.mock
}

// When sets expectation for the Client.DeleteApiKey which will trigger the result defined by the following
// Then helper
func (mmDeleteApiKey *mClientMockDeleteApiKey) When(ctx context.Context, id string) *ClientMockDeleteApiKeyExpectation {
	if mmDeleteApiKey.mock.funcDeleteApiKey != nil {
		mmDeleteApiKey.mock.t.Fatalf("ClientMock.DeleteApiKey mock is already set by Set")
	}

	expectation := &ClientMockDeleteApiKeyExpectation{
		mock:   mmDeleteApiKey.mock,
		params: &ClientMockDeleteApiKeyParams{ctx, id},
	}
	mmDeleteApiKey.expectations = append(mmDeleteApiKey.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteApiKey return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteApiKeyExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteApiKeyResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteApiKey should be invoked
func (mmDeleteApiKey *mClientMockDeleteApiKey) Times(n uint64) *mClientMockDeleteApiKey {
	if n == 0 {
		mmDeleteApiKey.mock.t.Fatalf("Times of ClientMock.DeleteApiKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteApiKey.expectedInvocations, n)
	return mmDeleteApiKey
}

func (mmDeleteApiKey *mClientMockDeleteApiKey) invocationsDone() bool {
	if len(mmDeleteApiKey.expectations) == 0 && mmDeleteApiKey.defaultExpectation == nil && mmDeleteApiKey.mock.funcDeleteApiKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteApiKey.mock.afterDeleteApiKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteApiKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteApiKey implements Client
func (mmDeleteApiKey *ClientMock) DeleteApiKey(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteApiKey.beforeDeleteApiKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteApiKey.afterDeleteApiKeyCounter, 1)

	if mmDeleteApiKey.inspectFuncDeleteApiKey != nil {
		mmDeleteApiKey.inspectFuncDeleteApiKey(ctx, id)
	}

	mm_params := ClientMockDeleteApiKeyParams{ctx, id}

	// Record call args
	mmDeleteApiKey.DeleteApiKeyMock.mutex.Lock()
	mmDeleteApiKey.DeleteApiKeyMock.callArgs = append(mmDeleteApiKey.DeleteApiKeyMock.callArgs, &mm_params)
	mmDeleteApiKey.DeleteApiKeyMock.mutex.Unlock()

	for _, e := range mmDeleteApiKey.DeleteApiKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteApiKey.DeleteApiKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteApiKey.DeleteApiKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteApiKey.DeleteApiKeyMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteApiKey.DeleteApiKeyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteApiKeyParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteApiKey.t.Errorf("ClientMock.DeleteApiKey got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteApiKey.t.Errorf("ClientMock.DeleteApiKey got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteApiKey.t.Errorf("ClientMock.DeleteApiKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteApiKey.DeleteApiKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteApiKey.t.Fatal("No results are set for the ClientMock.DeleteApiKey")
		}
		return (*mm_results).err
	}
	if mmDeleteApiKey.funcDeleteApiKey != nil {
		return mmDeleteApiKey.funcDeleteApiKey(ctx, id)
	}
	mmDeleteApiKey.t.Fatalf("Unexpected call to ClientMock.DeleteApiKey. %v %v", ctx, id)
	return
}

// DeleteApiKeyAfterCounter returns a count of finished ClientMock.DeleteApiKey invocations
func (mmDeleteApiKey *ClientMock) DeleteApiKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApiKey.afterDeleteApiKeyCounter)
}

// DeleteApiKeyBeforeCounter returns a count of ClientMock.DeleteApiKey invocations
func (mmDeleteApiKey *ClientMock) DeleteApiKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApiKey.beforeDeleteApiKeyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteApiKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteApiKey *mClientMockDeleteApiKey) Calls() []*ClientMockDeleteApiKeyParams {
	mmDeleteApiKey.mutex.RLock()

	argCopy := make([]*ClientMockDeleteApiKeyParams, len(mmDeleteApiKey.callArgs))
	copy(argCopy, mmDeleteApiKey.callArgs)

	mmDeleteApiKey.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteApiKeyDone returns true if the count of the DeleteApiKey invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteApiKeyDone() bool {
	if m.DeleteApiKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteApiKeyMock.invocationsDone()
}

// MinimockDeleteApiKeyInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteApiKeyInspect() {
	for _, e := range m.DeleteApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteApiKey with params: %#v", *e.params)
		}
	}

	afterDeleteApiKeyCounter := mm_atomic.LoadUint64(&m.afterDeleteApiKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteApiKeyMock.defaultExpectation != nil && afterDeleteApiKeyCounter < 1 {
		if m.DeleteApiKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteApiKey")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteApiKey with params: %#v", *m.DeleteApiKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteApiKey != nil && afterDeleteApiKeyCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteApiKey")
	}

	if !m.DeleteApiKeyMock.invocationsDone() && afterDeleteApiKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteApiKey but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteApiKeyMock.expectedInvocations), afterDeleteApiKeyCounter)
	}
}

type mClientMockDeleteClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteClickPipeExpectation
	expectations       []*ClientMockDeleteClickPipeExpectation

	callArgs []*ClientMockDeleteClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteClickPipeExpectation specifies expectation struct of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteClickPipeParams
	paramPtrs *ClientMockDeleteClickPipeParamPtrs
	results   *ClientMockDeleteClickPipeResults
	Counter   uint64
}

// ClientMockDeleteClickPipeParams contains parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockDeleteClickPipeParamPtrs contains pointers to parameters of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockDeleteClickPipeResults contains results of the Client.DeleteClickPipe
type ClientMockDeleteClickPipeResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Optional() *mClientMockDeleteClickPipe {
	mmDeleteClickPipe.optional = true
	return mmDeleteClickPipe
}

// Expect sets up expected params for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by ExpectParams functions")
	}

	mmDeleteClickPipe.defaultExpectation.params = &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}
	for _, e := range mmDeleteClickPipe.expectations {
		if minimock.Equal(e.params, mmDeleteClickPipe.defaultExpectation.params) {
			mmDeleteClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteClickPipe.defaultExpectation.params)
		}
	}

	return mmDeleteClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmDeleteClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{}
	}

	if mmDeleteClickPipe.defaultExpectation.params != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Expect")
	}

	if mmDeleteClickPipe.defaultExpectation.paramPtrs == nil {
		mmDeleteClickPipe.defaultExpectation.paramPtrs = &ClientMockDeleteClickPipeParamPtrs{}
	}
	mmDeleteClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmDeleteClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockDeleteClickPipe {
	if mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteClickPipe")
	}

	mmDeleteClickPipe.mock.inspectFuncDeleteClickPipe = f

	return mmDeleteClickPipe
}

// Return sets up results that will be returned by Client.DeleteClickPipe
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Return(err error) *ClientMock {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	if mmDeleteClickPipe.defaultExpectation == nil {
		mmDeleteClickPipe.defaultExpectation = &ClientMockDeleteClickPipeExpectation{mock: mmDeleteClickPipe.mock}
	}
	mmDeleteClickPipe.defaultExpectation.results = &ClientMockDeleteClickPipeResults{err}
	return mmDeleteClickPipe.mock
}

// Set uses given function f to mock the Client.DeleteClickPipe method
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (err error)) *ClientMock {
	if mmDeleteClickPipe.defaultExpectation != nil {
		mmDeleteClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.DeleteClickPipe method")
	}

	if len(mmDeleteClickPipe.expectations) > 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.DeleteClickPipe method")
	}

	mmDeleteClickPipe.mock.funcDeleteClickPipe = f
	return mmDeleteClickPipe.mock
}

// When sets expectation for the Client.DeleteClickPipe which will trigger the result defined by the following
// Then helper
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockDeleteClickPipeExpectation {
	if mmDeleteClickPipe.mock.funcDeleteClickPipe != nil {
		mmDeleteClickPipe.mock.t.Fatalf("ClientMock.DeleteClickPipe mock is already set by Set")
	}

	expectation := &ClientMockDeleteClickPipeExpectation{
		mock:   mmDeleteClickPipe.mock,
		params: &ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId},
	}
	mmDeleteClickPipe.expectations = append(mmDeleteClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteClickPipeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteClickPipeResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteClickPipe should be invoked
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Times(n uint64) *mClientMockDeleteClickPipe {
	if n == 0 {
		mmDeleteClickPipe.mock.t.Fatalf("Times of ClientMock.DeleteClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteClickPipe.expectedInvocations, n)
	return mmDeleteClickPipe
}

func (mmDeleteClickPipe *mClientMockDeleteClickPipe) invocationsDone() bool {
	if len(mmDeleteClickPipe.expectations) == 0 && mmDeleteClickPipe.defaultExpectation == nil && mmDeleteClickPipe.mock.funcDeleteClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.mock.afterDeleteClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteClickPipe implements Client
func (mmDeleteClickPipe *ClientMock) DeleteClickPipe(ctx context.Context, serviceId string, clickPipeId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter, 1)

	if mmDeleteClickPipe.inspectFuncDeleteClickPipe != nil {
		mmDeleteClickPipe.inspectFuncDeleteClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Lock()
	mmDeleteClickPipe.DeleteClickPipeMock.callArgs = append(mmDeleteClickPipe.DeleteClickPipeMock.callArgs, &mm_params)
	mmDeleteClickPipe.DeleteClickPipeMock.mutex.Unlock()

	for _, e := range mmDeleteClickPipe.DeleteClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteClickPipe.t.Errorf("ClientMock.DeleteClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteClickPipe.DeleteClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteClickPipe.t.Fatal("No results are set for the ClientMock.DeleteClickPipe")
		}
		return (*mm_results).err
	}
	if mmDeleteClickPipe.funcDeleteClickPipe != nil {
		return mmDeleteClickPipe.funcDeleteClickPipe(ctx, serviceId, clickPipeId)
	}
	mmDeleteClickPipe.t.Fatalf("Unexpected call to ClientMock.DeleteClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// DeleteClickPipeAfterCounter returns a count of finished ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.afterDeleteClickPipeCounter)
}

// DeleteClickPipeBeforeCounter returns a count of ClientMock.DeleteClickPipe invocations
func (mmDeleteClickPipe *ClientMock) DeleteClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClickPipe.beforeDeleteClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteClickPipe *mClientMockDeleteClickPipe) Calls() []*ClientMockDeleteClickPipeParams {
	mmDeleteClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockDeleteClickPipeParams, len(mmDeleteClickPipe.callArgs))
	copy(argCopy, mmDeleteClickPipe.callArgs)

	mmDeleteClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteClickPipeDone returns true if the count of the DeleteClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteClickPipeDone() bool {
	if m.DeleteClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteClickPipeMock.invocationsDone()
}

// MinimockDeleteClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteClickPipeInspect() {
	for _, e := range m.DeleteClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe with params: %#v", *e.params)
		}
	}

	afterDeleteClickPipeCounter := mm_atomic.LoadUint64(&m.afterDeleteClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClickPipeMock.defaultExpectation != nil && afterDeleteClickPipeCounter < 1 {
		if m.DeleteClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteClickPipe with params: %#v", *m.DeleteClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClickPipe != nil && afterDeleteClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteClickPipe")
	}

	if !m.DeleteClickPipeMock.invocationsDone() && afterDeleteClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteClickPipeMock.expectedInvocations), afterDeleteClickPipeCounter)
	}
}

type mClientMockDeleteDatabase struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteDatabaseExpectation
	expectations       []*ClientMockDeleteDatabaseExpectation

	callArgs []*ClientMockDeleteDatabaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteDatabaseExpectation specifies expectation struct of the Client.DeleteDatabase
type ClientMockDeleteDatabaseExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteDatabaseParams
	paramPtrs *ClientMockDeleteDatabaseParamPtrs
	results   *ClientMockDeleteDatabaseResults
	Counter   uint64
}

// ClientMockDeleteDatabaseParams contains parameters of the Client.DeleteDatabase
type ClientMockDeleteDatabaseParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockDeleteDatabaseParamPtrs contains pointers to parameters of the Client.DeleteDatabase
type ClientMockDeleteDatabaseParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockDeleteDatabaseResults contains results of the Client.DeleteDatabase
type ClientMockDeleteDatabaseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteDatabase *mClientMockDeleteDatabase) Optional() *mClientMockDeleteDatabase {
	mmDeleteDatabase.optional = true
	return mmDeleteDatabase
}

// Expect sets up expected params for Client.DeleteDatabase
func (mmDeleteDatabase *mClientMockDeleteDatabase) Expect(ctx context.Context, serviceID string, name string) *mClientMockDeleteDatabase {
	if mmDeleteDatabase.mock.funcDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Set")
	}

	if mmDeleteDatabase.defaultExpectation == nil {
		mmDeleteDatabase.defaultExpectation = &ClientMockDeleteDatabaseExpectation{}
	}

	if mmDeleteDatabase.defaultExpectation.paramPtrs != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by ExpectParams functions")
	}

	mmDeleteDatabase.defaultExpectation.params = &ClientMockDeleteDatabaseParams{ctx, serviceID, name}
	for _, e := range mmDeleteDatabase.expectations {
		if minimock.Equal(e.params, mmDeleteDatabase.defaultExpectation.params) {
			mmDeleteDatabase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteDatabase.defaultExpectation.params)
		}
	}

	return mmDeleteDatabase
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteDatabase
func (mmDeleteDatabase *mClientMockDeleteDatabase) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteDatabase {
	if mmDeleteDatabase.mock.funcDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Set")
	}

	if mmDeleteDatabase.defaultExpectation == nil {
		mmDeleteDatabase.defaultExpectation = &ClientMockDeleteDatabaseExpectation{}
	}

	if mmDeleteDatabase.defaultExpectation.params != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Expect")
	}

	if mmDeleteDatabase.defaultExpectation.paramPtrs == nil {
		mmDeleteDatabase.defaultExpectation.paramPtrs = &ClientMockDeleteDatabaseParamPtrs{}
	}
	mmDeleteDatabase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteDatabase
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteDatabase
func (mmDeleteDatabase *mClientMockDeleteDatabase) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteDatabase {
	if mmDeleteDatabase.mock.funcDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Set")
	}

	if mmDeleteDatabase.defaultExpectation == nil {
		mmDeleteDatabase.defaultExpectation = &ClientMockDeleteDatabaseExpectation{}
	}

	if mmDeleteDatabase.defaultExpectation.params != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Expect")
	}

	if mmDeleteDatabase.defaultExpectation.paramPtrs == nil {
		mmDeleteDatabase.defaultExpectation.paramPtrs = &ClientMockDeleteDatabaseParamPtrs{}
	}
	mmDeleteDatabase.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmDeleteDatabase
}

// ExpectNameParam3 sets up expected param name for Client.DeleteDatabase
func (mmDeleteDatabase *mClientMockDeleteDatabase) ExpectNameParam3(name string) *mClientMockDeleteDatabase {
	if mmDeleteDatabase.mock.funcDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Set")
	}

	if mmDeleteDatabase.defaultExpectation == nil {
		mmDeleteDatabase.defaultExpectation = &ClientMockDeleteDatabaseExpectation{}
	}

	if mmDeleteDatabase.defaultExpectation.params != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Expect")
	}

	if mmDeleteDatabase.defaultExpectation.paramPtrs == nil {
		mmDeleteDatabase.defaultExpectation.paramPtrs = &ClientMockDeleteDatabaseParamPtrs{}
	}
	mmDeleteDatabase.defaultExpectation.paramPtrs.name = &name

	return mmDeleteDatabase
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteDatabase
func (mmDeleteDatabase *mClientMockDeleteDatabase) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockDeleteDatabase {
	if mmDeleteDatabase.mock.inspectFuncDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteDatabase")
	}

	mmDeleteDatabase.mock.inspectFuncDeleteDatabase = f

	return mmDeleteDatabase
}

// Return sets up results that will be returned by Client.DeleteDatabase
func (mmDeleteDatabase *mClientMockDeleteDatabase) Return(err error) *ClientMock {
	if mmDeleteDatabase.mock.funcDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Set")
	}

	if mmDeleteDatabase.defaultExpectation == nil {
		mmDeleteDatabase.defaultExpectation = &ClientMockDeleteDatabaseExpectation{mock: mmDeleteDatabase.mock}
	}
	mmDeleteDatabase.defaultExpectation.results = &ClientMockDeleteDatabaseResults{err}
	return mmDeleteDatabase.mock
}

// Set uses given function f to mock the Client.DeleteDatabase method
func (mmDeleteDatabase *mClientMockDeleteDatabase) Set(f func(ctx context.Context, serviceID string, name string) (err error)) *ClientMock {
	if mmDeleteDatabase.defaultExpectation != nil {
		mmDeleteDatabase.mock.t.Fatalf("Default expectation is already set for the Client.DeleteDatabase method")
	}

	if len(mmDeleteDatabase.expectations) > 0 {
		mmDeleteDatabase.mock.t.Fatalf("Some expectations are already set for the Client.DeleteDatabase method")
	}

	mmDeleteDatabase.mock.funcDeleteDatabase = f
	return mmDeleteDatabase.mock
}

// When sets expectation for the Client.DeleteDatabase which will trigger the result defined by the following
// Then helper
func (mmDeleteDatabase *mClientMockDeleteDatabase) When(ctx context.Context, serviceID string, name string) *ClientMockDeleteDatabaseExpectation {
	if mmDeleteDatabase.mock.funcDeleteDatabase != nil {
		mmDeleteDatabase.mock.t.Fatalf("ClientMock.DeleteDatabase mock is already set by Set")
	}

	expectation := &ClientMockDeleteDatabaseExpectation{
		mock:   mmDeleteDatabase.mock,
		params: &ClientMockDeleteDatabaseParams{ctx, serviceID, name},
	}
	mmDeleteDatabase.expectations = append(mmDeleteDatabase.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteDatabase return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteDatabaseExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteDatabaseResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteDatabase should be invoked
func (mmDeleteDatabase *mClientMockDeleteDatabase) Times(n uint64) *mClientMockDeleteDatabase {
	if n == 0 {
		mmDeleteDatabase.mock.t.Fatalf("Times of ClientMock.DeleteDatabase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteDatabase.expectedInvocations, n)
	return mmDeleteDatabase
}

func (mmDeleteDatabase *mClientMockDeleteDatabase) invocationsDone() bool {
	if len(mmDeleteDatabase.expectations) == 0 && mmDeleteDatabase.defaultExpectation == nil && mmDeleteDatabase.mock.funcDeleteDatabase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteDatabase.mock.afterDeleteDatabaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteDatabase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteDatabase implements Client
func (mmDeleteDatabase *ClientMock) DeleteDatabase(ctx context.Context, serviceID string, name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteDatabase.beforeDeleteDatabaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteDatabase.afterDeleteDatabaseCounter, 1)

	if mmDeleteDatabase.inspectFuncDeleteDatabase != nil {
		mmDeleteDatabase.inspectFuncDeleteDatabase(ctx, serviceID, name)
	}

	mm_params := ClientMockDeleteDatabaseParams{ctx, serviceID, name}

	// Record call args
	mmDeleteDatabase.DeleteDatabaseMock.mutex.Lock()
	mmDeleteDatabase.DeleteDatabaseMock.callArgs = append(mmDeleteDatabase.DeleteDatabaseMock.callArgs, &mm_params)
	mmDeleteDatabase.DeleteDatabaseMock.mutex.Unlock()

	for _, e := range mmDeleteDatabase.DeleteDatabaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteDatabase.DeleteDatabaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteDatabase.DeleteDatabaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteDatabase.DeleteDatabaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteDatabase.DeleteDatabaseMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteDatabaseParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteDatabase.t.Errorf("ClientMock.DeleteDatabase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteDatabase.t.Errorf("ClientMock.DeleteDatabase got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteDatabase.t.Errorf("ClientMock.DeleteDatabase got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteDatabase.t.Errorf("ClientMock.DeleteDatabase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteDatabase.DeleteDatabaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteDatabase.t.Fatal("No results are set for the ClientMock.DeleteDatabase")
		}
		return (*mm_results).err
	}
	if mmDeleteDatabase.funcDeleteDatabase != nil {
		return mmDeleteDatabase.funcDeleteDatabase(ctx, serviceID, name)
	}
	mmDeleteDatabase.t.Fatalf("Unexpected call to ClientMock.DeleteDatabase. %v %v %v", ctx, serviceID, name)
	return
}

// DeleteDatabaseAfterCounter returns a count of finished ClientMock.DeleteDatabase invocations
func (mmDeleteDatabase *ClientMock) DeleteDatabaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteDatabase.afterDeleteDatabaseCounter)
}

// DeleteDatabaseBeforeCounter returns a count of ClientMock.DeleteDatabase invocations
func (mmDeleteDatabase *ClientMock) DeleteDatabaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteDatabase.beforeDeleteDatabaseCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteDatabase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteDatabase *mClientMockDeleteDatabase) Calls() []*ClientMockDeleteDatabaseParams {
	mmDeleteDatabase.mutex.RLock()

	argCopy := make([]*ClientMockDeleteDatabaseParams, len(mmDeleteDatabase.callArgs))
	copy(argCopy, mmDeleteDatabase.callArgs)

	mmDeleteDatabase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDatabaseDone returns true if the count of the DeleteDatabase invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteDatabaseDone() bool {
	if m.DeleteDatabaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteDatabaseMock.invocationsDone()
}

// MinimockDeleteDatabaseInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteDatabaseInspect() {
	for _, e := range m.DeleteDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteDatabase with params: %#v", *e.params)
		}
	}

	afterDeleteDatabaseCounter := mm_atomic.LoadUint64(&m.afterDeleteDatabaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteDatabaseMock.defaultExpectation != nil && afterDeleteDatabaseCounter < 1 {
		if m.DeleteDatabaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteDatabase")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteDatabase with params: %#v", *m.DeleteDatabaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteDatabase != nil && afterDeleteDatabaseCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteDatabase")
	}

	if !m.DeleteDatabaseMock.invocationsDone() && afterDeleteDatabaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteDatabase but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteDatabaseMock.expectedInvocations), afterDeleteDatabaseCounter)
	}
}

type mClientMockDeleteQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteQueryEndpointExpectation
	expectations       []*ClientMockDeleteQueryEndpointExpectation

	callArgs []*ClientMockDeleteQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteQueryEndpointExpectation specifies expectation struct of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteQueryEndpointParams
	paramPtrs *ClientMockDeleteQueryEndpointParamPtrs
	results   *ClientMockDeleteQueryEndpointResults
	Counter   uint64
}

// ClientMockDeleteQueryEndpointParams contains parameters of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
}

// ClientMockDeleteQueryEndpointParamPtrs contains pointers to parameters of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
}

// ClientMockDeleteQueryEndpointResults contains results of the Client.DeleteQueryEndpoint
type ClientMockDeleteQueryEndpointResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Optional() *mClientMockDeleteQueryEndpoint {
	mmDeleteQueryEndpoint.optional = true
	return mmDeleteQueryEndpoint
}

// Expect sets up expected params for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Expect(ctx context.Context, serviceID string) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmDeleteQueryEndpoint.defaultExpectation.params = &ClientMockDeleteQueryEndpointParams{ctx, serviceID}
	for _, e := range mmDeleteQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmDeleteQueryEndpoint.defaultExpectation.params) {
			mmDeleteQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmDeleteQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.params != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Expect")
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteQueryEndpointParamPtrs{}
	}
	mmDeleteQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{}
	}

	if mmDeleteQueryEndpoint.defaultExpectation.params != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Expect")
	}

	if mmDeleteQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteQueryEndpointParamPtrs{}
	}
	mmDeleteQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmDeleteQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string)) *mClientMockDeleteQueryEndpoint {
	if mmDeleteQueryEndpoint.mock.inspectFuncDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteQueryEndpoint")
	}

	mmDeleteQueryEndpoint.mock.inspectFuncDeleteQueryEndpoint = f

	return mmDeleteQueryEndpoint
}

// Return sets up results that will be returned by Client.DeleteQueryEndpoint
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Return(err error) *ClientMock {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	if mmDeleteQueryEndpoint.defaultExpectation == nil {
		mmDeleteQueryEndpoint.defaultExpectation = &ClientMockDeleteQueryEndpointExpectation{mock: mmDeleteQueryEndpoint.mock}
	}
	mmDeleteQueryEndpoint.defaultExpectation.results = &ClientMockDeleteQueryEndpointResults{err}
	return mmDeleteQueryEndpoint.mock
}

// Set uses given function f to mock the Client.DeleteQueryEndpoint method
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Set(f func(ctx context.Context, serviceID string) (err error)) *ClientMock {
	if mmDeleteQueryEndpoint.defaultExpectation != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.DeleteQueryEndpoint method")
	}

	if len(mmDeleteQueryEndpoint.expectations) > 0 {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.DeleteQueryEndpoint method")
	}

	mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint = f
	return mmDeleteQueryEndpoint.mock
}

// When sets expectation for the Client.DeleteQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) When(ctx context.Context, serviceID string) *ClientMockDeleteQueryEndpointExpectation {
	if mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.mock.t.Fatalf("ClientMock.DeleteQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockDeleteQueryEndpointExpectation{
		mock:   mmDeleteQueryEndpoint.mock,
		params: &ClientMockDeleteQueryEndpointParams{ctx, serviceID},
	}
	mmDeleteQueryEndpoint.expectations = append(mmDeleteQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteQueryEndpointExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteQueryEndpointResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteQueryEndpoint should be invoked
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Times(n uint64) *mClientMockDeleteQueryEndpoint {
	if n == 0 {
		mmDeleteQueryEndpoint.mock.t.Fatalf("Times of ClientMock.DeleteQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteQueryEndpoint.expectedInvocations, n)
	return mmDeleteQueryEndpoint
}

func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) invocationsDone() bool {
	if len(mmDeleteQueryEndpoint.expectations) == 0 && mmDeleteQueryEndpoint.defaultExpectation == nil && mmDeleteQueryEndpoint.mock.funcDeleteQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.mock.afterDeleteQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteQueryEndpoint implements Client
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpoint(ctx context.Context, serviceID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteQueryEndpoint.beforeDeleteQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteQueryEndpoint.afterDeleteQueryEndpointCounter, 1)

	if mmDeleteQueryEndpoint.inspectFuncDeleteQueryEndpoint != nil {
		mmDeleteQueryEndpoint.inspectFuncDeleteQueryEndpoint(ctx, serviceID)
	}

	mm_params := ClientMockDeleteQueryEndpointParams{ctx, serviceID}

	// Record call args
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.mutex.Lock()
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.callArgs = append(mmDeleteQueryEndpoint.DeleteQueryEndpointMock.callArgs, &mm_params)
	mmDeleteQueryEndpoint.DeleteQueryEndpointMock.mutex.Unlock()

	for _, e := range mmDeleteQueryEndpoint.DeleteQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteQueryEndpointParams{ctx, serviceID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteQueryEndpoint.t.Errorf("ClientMock.DeleteQueryEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteQueryEndpoint.DeleteQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteQueryEndpoint.t.Fatal("No results are set for the ClientMock.DeleteQueryEndpoint")
		}
		return (*mm_results).err
	}
	if mmDeleteQueryEndpoint.funcDeleteQueryEndpoint != nil {
		return mmDeleteQueryEndpoint.funcDeleteQueryEndpoint(ctx, serviceID)
	}
	mmDeleteQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.DeleteQueryEndpoint. %v %v", ctx, serviceID)
	return
}

// DeleteQueryEndpointAfterCounter returns a count of finished ClientMock.DeleteQueryEndpoint invocations
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.afterDeleteQueryEndpointCounter)
}

// DeleteQueryEndpointBeforeCounter returns a count of ClientMock.DeleteQueryEndpoint invocations
func (mmDeleteQueryEndpoint *ClientMock) DeleteQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteQueryEndpoint.beforeDeleteQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteQueryEndpoint *mClientMockDeleteQueryEndpoint) Calls() []*ClientMockDeleteQueryEndpointParams {
	mmDeleteQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockDeleteQueryEndpointParams, len(mmDeleteQueryEndpoint.callArgs))
	copy(argCopy, mmDeleteQueryEndpoint.callArgs)

	mmDeleteQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteQueryEndpointDone returns true if the count of the DeleteQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteQueryEndpointDone() bool {
	if m.DeleteQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteQueryEndpointMock.invocationsDone()
}

// MinimockDeleteQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteQueryEndpointInspect() {
	for _, e := range m.DeleteQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint with params: %#v", *e.params)
		}
	}

	afterDeleteQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterDeleteQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteQueryEndpointMock.defaultExpectation != nil && afterDeleteQueryEndpointCounter < 1 {
		if m.DeleteQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteQueryEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteQueryEndpoint with params: %#v", *m.DeleteQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteQueryEndpoint != nil && afterDeleteQueryEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteQueryEndpoint")
	}

	if !m.DeleteQueryEndpointMock.invocationsDone() && afterDeleteQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteQueryEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteQueryEndpointMock.expectedInvocations), afterDeleteQueryEndpointCounter)
	}
}

type mClientMockDeleteReversePrivateEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteReversePrivateEndpointExpectation
	expectations       []*ClientMockDeleteReversePrivateEndpointExpectation

	callArgs []*ClientMockDeleteReversePrivateEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteReversePrivateEndpointExpectation specifies expectation struct of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteReversePrivateEndpointParams
	paramPtrs *ClientMockDeleteReversePrivateEndpointParamPtrs
	results   *ClientMockDeleteReversePrivateEndpointResults
	Counter   uint64
}

// ClientMockDeleteReversePrivateEndpointParams contains parameters of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointParams struct {
	ctx                      context.Context
	serviceId                string
	reversePrivateEndpointId string
}

// ClientMockDeleteReversePrivateEndpointParamPtrs contains pointers to parameters of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointParamPtrs struct {
	ctx                      *context.Context
	serviceId                *string
	reversePrivateEndpointId *string
}

// ClientMockDeleteReversePrivateEndpointResults contains results of the Client.DeleteReversePrivateEndpoint
type ClientMockDeleteReversePrivateEndpointResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Optional() *mClientMockDeleteReversePrivateEndpoint {
	mmDeleteReversePrivateEndpoint.optional = true
	return mmDeleteReversePrivateEndpoint
}

// Expect sets up expected params for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Expect(ctx context.Context, serviceId string, reversePrivateEndpointId string) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by ExpectParams functions")
	}

	mmDeleteReversePrivateEndpoint.defaultExpectation.params = &ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}
	for _, e := range mmDeleteReversePrivateEndpoint.expectations {
		if minimock.Equal(e.params, mmDeleteReversePrivateEndpoint.defaultExpectation.params) {
			mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReversePrivateEndpoint.defaultExpectation.params)
		}
	}

	return mmDeleteReversePrivateEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.params != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Expect")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteReversePrivateEndpointParamPtrs{}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteReversePrivateEndpoint
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.params != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Expect")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteReversePrivateEndpointParamPtrs{}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmDeleteReversePrivateEndpoint
}

// ExpectReversePrivateEndpointIdParam3 sets up expected param reversePrivateEndpointId for Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) ExpectReversePrivateEndpointIdParam3(reversePrivateEndpointId string) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{}
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.params != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Expect")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockDeleteReversePrivateEndpointParamPtrs{}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId

	return mmDeleteReversePrivateEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Inspect(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string)) *mClientMockDeleteReversePrivateEndpoint {
	if mmDeleteReversePrivateEndpoint.mock.inspectFuncDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteReversePrivateEndpoint")
	}

	mmDeleteReversePrivateEndpoint.mock.inspectFuncDeleteReversePrivateEndpoint = f

	return mmDeleteReversePrivateEndpoint
}

// Return sets up results that will be returned by Client.DeleteReversePrivateEndpoint
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Return(err error) *ClientMock {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	if mmDeleteReversePrivateEndpoint.defaultExpectation == nil {
		mmDeleteReversePrivateEndpoint.defaultExpectation = &ClientMockDeleteReversePrivateEndpointExpectation{mock: mmDeleteReversePrivateEndpoint.mock}
	}
	mmDeleteReversePrivateEndpoint.defaultExpectation.results = &ClientMockDeleteReversePrivateEndpointResults{err}
	return mmDeleteReversePrivateEndpoint.mock
}

// Set uses given function f to mock the Client.DeleteReversePrivateEndpoint method
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Set(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (err error)) *ClientMock {
	if mmDeleteReversePrivateEndpoint.defaultExpectation != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.DeleteReversePrivateEndpoint method")
	}

	if len(mmDeleteReversePrivateEndpoint.expectations) > 0 {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.DeleteReversePrivateEndpoint method")
	}

	mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint = f
	return mmDeleteReversePrivateEndpoint.mock
}

// When sets expectation for the Client.DeleteReversePrivateEndpoint which will trigger the result defined by the following
// Then helper
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) When(ctx context.Context, serviceId string, reversePrivateEndpointId string) *ClientMockDeleteReversePrivateEndpointExpectation {
	if mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("ClientMock.DeleteReversePrivateEndpoint mock is already set by Set")
	}

	expectation := &ClientMockDeleteReversePrivateEndpointExpectation{
		mock:   mmDeleteReversePrivateEndpoint.mock,
		params: &ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId},
	}
	mmDeleteReversePrivateEndpoint.expectations = append(mmDeleteReversePrivateEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteReversePrivateEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteReversePrivateEndpointExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteReversePrivateEndpointResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteReversePrivateEndpoint should be invoked
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Times(n uint64) *mClientMockDeleteReversePrivateEndpoint {
	if n == 0 {
		mmDeleteReversePrivateEndpoint.mock.t.Fatalf("Times of ClientMock.DeleteReversePrivateEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteReversePrivateEndpoint.expectedInvocations, n)
	return mmDeleteReversePrivateEndpoint
}

func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) invocationsDone() bool {
	if len(mmDeleteReversePrivateEndpoint.expectations) == 0 && mmDeleteReversePrivateEndpoint.defaultExpectation == nil && mmDeleteReversePrivateEndpoint.mock.funcDeleteReversePrivateEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.mock.afterDeleteReversePrivateEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteReversePrivateEndpoint implements Client
func (mmDeleteReversePrivateEndpoint *ClientMock) DeleteReversePrivateEndpoint(ctx context.Context, serviceId string, reversePrivateEndpointId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteReversePrivateEndpoint.beforeDeleteReversePrivateEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteReversePrivateEndpoint.afterDeleteReversePrivateEndpointCounter, 1)

	if mmDeleteReversePrivateEndpoint.inspectFuncDeleteReversePrivateEndpoint != nil {
		mmDeleteReversePrivateEndpoint.inspectFuncDeleteReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}

	mm_params := ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

	// Record call args
	mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.mutex.Lock()
	mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.callArgs = append(mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.callArgs, &mm_params)
	mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.mutex.Unlock()

	for _, e := range mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameter reversePrivateEndpointId, want: %#v, got: %#v%s\n", *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteReversePrivateEndpoint.t.Errorf("ClientMock.DeleteReversePrivateEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteReversePrivateEndpoint.DeleteReversePrivateEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteReversePrivateEndpoint.t.Fatal("No results are set for the ClientMock.DeleteReversePrivateEndpoint")
		}
		return (*mm_results).err
	}
	if mmDeleteReversePrivateEndpoint.funcDeleteReversePrivateEndpoint != nil {
		return mmDeleteReversePrivateEndpoint.funcDeleteReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}
	mmDeleteReversePrivateEndpoint.t.Fatalf("Unexpected call to ClientMock.DeleteReversePrivateEndpoint. %v %v %v", ctx, serviceId, reversePrivateEndpointId)
	return
}

// DeleteReversePrivateEndpointAfterCounter returns a count of finished ClientMock.DeleteReversePrivateEndpoint invocations
func (mmDeleteReversePrivateEndpoint *ClientMock) DeleteReversePrivateEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.afterDeleteReversePrivateEndpointCounter)
}

// DeleteReversePrivateEndpointBeforeCounter returns a count of ClientMock.DeleteReversePrivateEndpoint invocations
func (mmDeleteReversePrivateEndpoint *ClientMock) DeleteReversePrivateEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReversePrivateEndpoint.beforeDeleteReversePrivateEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteReversePrivateEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReversePrivateEndpoint *mClientMockDeleteReversePrivateEndpoint) Calls() []*ClientMockDeleteReversePrivateEndpointParams {
	mmDeleteReversePrivateEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockDeleteReversePrivateEndpointParams, len(mmDeleteReversePrivateEndpoint.callArgs))
	copy(argCopy, mmDeleteReversePrivateEndpoint.callArgs)

	mmDeleteReversePrivateEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteReversePrivateEndpointDone returns true if the count of the DeleteReversePrivateEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteReversePrivateEndpointDone() bool {
	if m.DeleteReversePrivateEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteReversePrivateEndpointMock.invocationsDone()
}

// MinimockDeleteReversePrivateEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteReversePrivateEndpointInspect() {
	for _, e := range m.DeleteReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteReversePrivateEndpoint with params: %#v", *e.params)
		}
	}

	afterDeleteReversePrivateEndpointCounter := mm_atomic.LoadUint64(&m.afterDeleteReversePrivateEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReversePrivateEndpointMock.defaultExpectation != nil && afterDeleteReversePrivateEndpointCounter < 1 {
		if m.DeleteReversePrivateEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteReversePrivateEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteReversePrivateEndpoint with params: %#v", *m.DeleteReversePrivateEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReversePrivateEndpoint != nil && afterDeleteReversePrivateEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteReversePrivateEndpoint")
	}

	if !m.DeleteReversePrivateEndpointMock.invocationsDone() && afterDeleteReversePrivateEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteReversePrivateEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteReversePrivateEndpointMock.expectedInvocations), afterDeleteReversePrivateEndpointCounter)
	}
}

type mClientMockDeleteRole struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteRoleExpectation
	expectations       []*ClientMockDeleteRoleExpectation

	callArgs []*ClientMockDeleteRoleParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteRoleExpectation specifies expectation struct of the Client.DeleteRole
type ClientMockDeleteRoleExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteRoleParams
	paramPtrs *ClientMockDeleteRoleParamPtrs
	results   *ClientMockDeleteRoleResults
	Counter   uint64
}

// ClientMockDeleteRoleParams contains parameters of the Client.DeleteRole
type ClientMockDeleteRoleParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockDeleteRoleParamPtrs contains pointers to parameters of the Client.DeleteRole
type ClientMockDeleteRoleParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockDeleteRoleResults contains results of the Client.DeleteRole
type ClientMockDeleteRoleResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRole *mClientMockDeleteRole) Optional() *mClientMockDeleteRole {
	mmDeleteRole.optional = true
	return mmDeleteRole
}

// Expect sets up expected params for Client.DeleteRole
func (mmDeleteRole *mClientMockDeleteRole) Expect(ctx context.Context, serviceID string, name string) *mClientMockDeleteRole {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &ClientMockDeleteRoleExpectation{}
	}

	if mmDeleteRole.defaultExpectation.paramPtrs != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by ExpectParams functions")
	}

	mmDeleteRole.defaultExpectation.params = &ClientMockDeleteRoleParams{ctx, serviceID, name}
	for _, e := range mmDeleteRole.expectations {
		if minimock.Equal(e.params, mmDeleteRole.defaultExpectation.params) {
			mmDeleteRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRole.defaultExpectation.params)
		}
	}

	return mmDeleteRole
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteRole
func (mmDeleteRole *mClientMockDeleteRole) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteRole {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &ClientMockDeleteRoleExpectation{}
	}

	if mmDeleteRole.defaultExpectation.params != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Expect")
	}

	if mmDeleteRole.defaultExpectation.paramPtrs == nil {
		mmDeleteRole.defaultExpectation.paramPtrs = &ClientMockDeleteRoleParamPtrs{}
	}
	mmDeleteRole.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteRole
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteRole
func (mmDeleteRole *mClientMockDeleteRole) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteRole {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &ClientMockDeleteRoleExpectation{}
	}

	if mmDeleteRole.defaultExpectation.params != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Expect")
	}

	if mmDeleteRole.defaultExpectation.paramPtrs == nil {
		mmDeleteRole.defaultExpectation.paramPtrs = &ClientMockDeleteRoleParamPtrs{}
	}
	mmDeleteRole.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmDeleteRole
}

// ExpectNameParam3 sets up expected param name for Client.DeleteRole
func (mmDeleteRole *mClientMockDeleteRole) ExpectNameParam3(name string) *mClientMockDeleteRole {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &ClientMockDeleteRoleExpectation{}
	}

	if mmDeleteRole.defaultExpectation.params != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Expect")
	}

	if mmDeleteRole.defaultExpectation.paramPtrs == nil {
		mmDeleteRole.defaultExpectation.paramPtrs = &ClientMockDeleteRoleParamPtrs{}
	}
	mmDeleteRole.defaultExpectation.paramPtrs.name = &name

	return mmDeleteRole
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteRole
func (mmDeleteRole *mClientMockDeleteRole) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockDeleteRole {
	if mmDeleteRole.mock.inspectFuncDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteRole")
	}

	mmDeleteRole.mock.inspectFuncDeleteRole = f

	return mmDeleteRole
}

// Return sets up results that will be returned by Client.DeleteRole
func (mmDeleteRole *mClientMockDeleteRole) Return(err error) *ClientMock {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &ClientMockDeleteRoleExpectation{mock: mmDeleteRole.mock}
	}
	mmDeleteRole.defaultExpectation.results = &ClientMockDeleteRoleResults{err}
	return mmDeleteRole.mock
}

// Set uses given function f to mock the Client.DeleteRole method
func (mmDeleteRole *mClientMockDeleteRole) Set(f func(ctx context.Context, serviceID string, name string) (err error)) *ClientMock {
	if mmDeleteRole.defaultExpectation != nil {
		mmDeleteRole.mock.t.Fatalf("Default expectation is already set for the Client.DeleteRole method")
	}

	if len(mmDeleteRole.expectations) > 0 {
		mmDeleteRole.mock.t.Fatalf("Some expectations are already set for the Client.DeleteRole method")
	}

	mmDeleteRole.mock.funcDeleteRole = f
	return mmDeleteRole.mock
}

// When sets expectation for the Client.DeleteRole which will trigger the result defined by the following
// Then helper
func (mmDeleteRole *mClientMockDeleteRole) When(ctx context.Context, serviceID string, name string) *ClientMockDeleteRoleExpectation {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("ClientMock.DeleteRole mock is already set by Set")
	}

	expectation := &ClientMockDeleteRoleExpectation{
		mock:   mmDeleteRole.mock,
		params: &ClientMockDeleteRoleParams{ctx, serviceID, name},
	}
	mmDeleteRole.expectations = append(mmDeleteRole.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteRole return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteRoleExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteRoleResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteRole should be invoked
func (mmDeleteRole *mClientMockDeleteRole) Times(n uint64) *mClientMockDeleteRole {
	if n == 0 {
		mmDeleteRole.mock.t.Fatalf("Times of ClientMock.DeleteRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRole.expectedInvocations, n)
	return mmDeleteRole
}

func (mmDeleteRole *mClientMockDeleteRole) invocationsDone() bool {
	if len(mmDeleteRole.expectations) == 0 && mmDeleteRole.defaultExpectation == nil && mmDeleteRole.mock.funcDeleteRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRole.mock.afterDeleteRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRole implements Client
func (mmDeleteRole *ClientMock) DeleteRole(ctx context.Context, serviceID string, name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRole.beforeDeleteRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRole.afterDeleteRoleCounter, 1)

	if mmDeleteRole.inspectFuncDeleteRole != nil {
		mmDeleteRole.inspectFuncDeleteRole(ctx, serviceID, name)
	}

	mm_params := ClientMockDeleteRoleParams{ctx, serviceID, name}

	// Record call args
	mmDeleteRole.DeleteRoleMock.mutex.Lock()
	mmDeleteRole.DeleteRoleMock.callArgs = append(mmDeleteRole.DeleteRoleMock.callArgs, &mm_params)
	mmDeleteRole.DeleteRoleMock.mutex.Unlock()

	for _, e := range mmDeleteRole.DeleteRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRole.DeleteRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRole.DeleteRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRole.DeleteRoleMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRole.DeleteRoleMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteRoleParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRole.t.Errorf("ClientMock.DeleteRole got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteRole.t.Errorf("ClientMock.DeleteRole got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteRole.t.Errorf("ClientMock.DeleteRole got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRole.t.Errorf("ClientMock.DeleteRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRole.DeleteRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRole.t.Fatal("No results are set for the ClientMock.DeleteRole")
		}
		return (*mm_results).err
	}
	if mmDeleteRole.funcDeleteRole != nil {
		return mmDeleteRole.funcDeleteRole(ctx, serviceID, name)
	}
	mmDeleteRole.t.Fatalf("Unexpected call to ClientMock.DeleteRole. %v %v %v", ctx, serviceID, name)
	return
}

// DeleteRoleAfterCounter returns a count of finished ClientMock.DeleteRole invocations
func (mmDeleteRole *ClientMock) DeleteRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRole.afterDeleteRoleCounter)
}

// DeleteRoleBeforeCounter returns a count of ClientMock.DeleteRole invocations
func (mmDeleteRole *ClientMock) DeleteRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRole.beforeDeleteRoleCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRole *mClientMockDeleteRole) Calls() []*ClientMockDeleteRoleParams {
	mmDeleteRole.mutex.RLock()

	argCopy := make([]*ClientMockDeleteRoleParams, len(mmDeleteRole.callArgs))
	copy(argCopy, mmDeleteRole.callArgs)

	mmDeleteRole.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRoleDone returns true if the count of the DeleteRole invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteRoleDone() bool {
	if m.DeleteRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRoleMock.invocationsDone()
}

// MinimockDeleteRoleInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteRoleInspect() {
	for _, e := range m.DeleteRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteRole with params: %#v", *e.params)
		}
	}

	afterDeleteRoleCounter := mm_atomic.LoadUint64(&m.afterDeleteRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRoleMock.defaultExpectation != nil && afterDeleteRoleCounter < 1 {
		if m.DeleteRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteRole")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteRole with params: %#v", *m.DeleteRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRole != nil && afterDeleteRoleCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteRole")
	}

	if !m.DeleteRoleMock.invocationsDone() && afterDeleteRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteRole but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRoleMock.expectedInvocations), afterDeleteRoleCounter)
	}
}

type mClientMockDeleteService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteServiceExpectation
	expectations       []*ClientMockDeleteServiceExpectation

	callArgs []*ClientMockDeleteServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteServiceExpectation specifies expectation struct of the Client.DeleteService
type ClientMockDeleteServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteServiceParams
	paramPtrs *ClientMockDeleteServiceParamPtrs
	results   *ClientMockDeleteServiceResults
	Counter   uint64
}

// ClientMockDeleteServiceParams contains parameters of the Client.DeleteService
type ClientMockDeleteServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockDeleteServiceParamPtrs contains pointers to parameters of the Client.DeleteService
type ClientMockDeleteServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockDeleteServiceResults contains results of the Client.DeleteService
type ClientMockDeleteServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteService *mClientMockDeleteService) Optional() *mClientMockDeleteService {
	mmDeleteService.optional = true
	return mmDeleteService
}

// Expect sets up expected params for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Expect(ctx context.Context, serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.paramPtrs != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by ExpectParams functions")
	}

	mmDeleteService.defaultExpectation.params = &ClientMockDeleteServiceParams{ctx, serviceId}
	for _, e := range mmDeleteService.expectations {
		if minimock.Equal(e.params, mmDeleteService.defaultExpectation.params) {
			mmDeleteService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteService.defaultExpectation.params)
		}
	}

	return mmDeleteService
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmDeleteService
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockDeleteService {
	if mmDeleteService.mock.inspectFuncDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteService")
	}

	mmDeleteService.mock.inspectFuncDeleteService = f

	return mmDeleteService
}

// Return sets up results that will be returned by Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Return(sp1 *Service, err error) *ClientMock {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{mock: mmDeleteService.mock}
	}
	mmDeleteService.defaultExpectation.results = &ClientMockDeleteServiceResults{sp1, err}
	return mmDeleteService.mock
}

// Set uses given function f to mock the Client.DeleteService method
func (mmDeleteService *mClientMockDeleteService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmDeleteService.defaultExpectation != nil {
		mmDeleteService.mock.t.Fatalf("Default expectation is already set for the Client.DeleteService method")
	}

	if len(mmDeleteService.expectations) > 0 {
		mmDeleteService.mock.t.Fatalf("Some expectations are already set for the Client.DeleteService method")
	}

	mmDeleteService.mock.funcDeleteService = f
	return mmDeleteService.mock
}

// When sets expectation for the Client.DeleteService which will trigger the result defined by the following
// Then helper
func (mmDeleteService *mClientMockDeleteService) When(ctx context.Context, serviceId string) *ClientMockDeleteServiceExpectation {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	expectation := &ClientMockDeleteServiceExpectation{
		mock:   mmDeleteService.mock,
		params: &ClientMockDeleteServiceParams{ctx, serviceId},
	}
	mmDeleteService.expectations = append(mmDeleteService.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteService return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockDeleteServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.DeleteService should be invoked
func (mmDeleteService *mClientMockDeleteService) Times(n uint64) *mClientMockDeleteService {
	if n == 0 {
		mmDeleteService.mock.t.Fatalf("Times of ClientMock.DeleteService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteService.expectedInvocations, n)
	return mmDeleteService
}

func (mmDeleteService *mClientMockDeleteService) invocationsDone() bool {
	if len(mmDeleteService.expectations) == 0 && mmDeleteService.defaultExpectation == nil && mmDeleteService.mock.funcDeleteService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteService.mock.afterDeleteServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteService implements Client
func (mmDeleteService *ClientMock) DeleteService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmDeleteService.beforeDeleteServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteService.afterDeleteServiceCounter, 1)

	if mmDeleteService.inspectFuncDeleteService != nil {
		mmDeleteService.inspectFuncDeleteService(ctx, serviceId)
	}

	mm_params := ClientMockDeleteServiceParams{ctx, serviceId}

	// Record call args
	mmDeleteService.DeleteServiceMock.mutex.Lock()
	mmDeleteService.DeleteServiceMock.callArgs = append(mmDeleteService.DeleteServiceMock.callArgs, &mm_params)
	mmDeleteService.DeleteServiceMock.mutex.Unlock()

	for _, e := range mmDeleteService.DeleteServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDeleteService.DeleteServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteService.DeleteServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteService.DeleteServiceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteService.DeleteServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteService.DeleteServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteService.t.Fatal("No results are set for the ClientMock.DeleteService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDeleteService.funcDeleteService != nil {
		return mmDeleteService.funcDeleteService(ctx, serviceId)
	}
	mmDeleteService.t.Fatalf("Unexpected call to ClientMock.DeleteService. %v %v", ctx, serviceId)
	return
}

// DeleteServiceAfterCounter returns a count of finished ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.afterDeleteServiceCounter)
}

// DeleteServiceBeforeCounter returns a count of ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.beforeDeleteServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteService *mClientMockDeleteService) Calls() []*ClientMockDeleteServiceParams {
	mmDeleteService.mutex.RLock()

	argCopy := make([]*ClientMockDeleteServiceParams, len(mmDeleteService.callArgs))
	copy(argCopy, mmDeleteService.callArgs)

	mmDeleteService.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteServiceDone returns true if the count of the DeleteService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteServiceDone() bool {
	if m.DeleteServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteServiceMock.invocationsDone()
}

// MinimockDeleteServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteServiceInspect() {
	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteService with params: %#v", *e.params)
		}
	}

	afterDeleteServiceCounter := mm_atomic.LoadUint64(&m.afterDeleteServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteServiceMock.defaultExpectation != nil && afterDeleteServiceCounter < 1 {
		if m.DeleteServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteService")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteService with params: %#v", *m.DeleteServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteService != nil && afterDeleteServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteService")
	}

	if !m.DeleteServiceMock.invocationsDone() && afterDeleteServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteService but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteServiceMock.expectedInvocations), afterDeleteServiceCounter)
	}
}

type mClientMockDeleteUser struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteUserExpectation
	expectations       []*ClientMockDeleteUserExpectation

	callArgs []*ClientMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteUserExpectation specifies expectation struct of the Client.DeleteUser
type ClientMockDeleteUserExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteUserParams
	paramPtrs *ClientMockDeleteUserParamPtrs
	results   *ClientMockDeleteUserResults
	Counter   uint64
}

// ClientMockDeleteUserParams contains parameters of the Client.DeleteUser
type ClientMockDeleteUserParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockDeleteUserParamPtrs contains pointers to parameters of the Client.DeleteUser
type ClientMockDeleteUserParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockDeleteUserResults contains results of the Client.DeleteUser
type ClientMockDeleteUserResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mClientMockDeleteUser) Optional() *mClientMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) Expect(ctx context.Context, serviceID string, name string) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &ClientMockDeleteUserParams{ctx, serviceID, name}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ClientMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteUser
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) ExpectServiceIDParam2(serviceID string) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ClientMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmDeleteUser
}

// ExpectNameParam3 sets up expected param name for Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) ExpectNameParam3(name string) *mClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ClientMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.name = &name

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Client.DeleteUser
func (mmDeleteUser *mClientMockDeleteUser) Return(err error) *ClientMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ClientMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &ClientMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

// Set uses given function f to mock the Client.DeleteUser method
func (mmDeleteUser *mClientMockDeleteUser) Set(f func(ctx context.Context, serviceID string, name string) (err error)) *ClientMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Client.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Client.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the Client.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mClientMockDeleteUser) When(ctx context.Context, serviceID string, name string) *ClientMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ClientMock.DeleteUser mock is already set by Set")
	}

	expectation := &ClientMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &ClientMockDeleteUserParams{ctx, serviceID, name},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteUser return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteUserExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteUser should be invoked
func (mmDeleteUser *mClientMockDeleteUser) Times(n uint64) *mClientMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of ClientMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	return mmDeleteUser
}

func (mmDeleteUser *mClientMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements Client
func (mmDeleteUser *ClientMock) DeleteUser(ctx context.Context, serviceID string, name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, serviceID, name)
	}

	mm_params := ClientMockDeleteUserParams{ctx, serviceID, name}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteUserParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("ClientMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the ClientMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, serviceID, name)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to ClientMock.DeleteUser. %v %v %v", ctx, serviceID, name)
	return
}

// DeleteUserAfterCounter returns a count of finished ClientMock.DeleteUser invocations
func (mmDeleteUser *ClientMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of ClientMock.DeleteUser invocations
func (mmDeleteUser *ClientMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mClientMockDeleteUser) Calls() []*ClientMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*ClientMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteUser with params: %#v", *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteUser")
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteUser but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
	}
}

type mClientMockGetApiKey struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetApiKeyExpectation
	expectations       []*ClientMockGetApiKeyExpectation

	callArgs []*ClientMockGetApiKeyParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetApiKeyExpectation specifies expectation struct of the Client.GetApiKey
type ClientMockGetApiKeyExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetApiKeyParams
	paramPtrs *ClientMockGetApiKeyParamPtrs
	results   *ClientMockGetApiKeyResults
	Counter   uint64
}

// ClientMockGetApiKeyParams contains parameters of the Client.GetApiKey
type ClientMockGetApiKeyParams struct {
	ctx  context.Context
	name string
}

// ClientMockGetApiKeyParamPtrs contains pointers to parameters of the Client.GetApiKey
type ClientMockGetApiKeyParamPtrs struct {
	ctx  *context.Context
	name *string
}

// ClientMockGetApiKeyResults contains results of the Client.GetApiKey
type ClientMockGetApiKeyResults struct {
	ap1 *ApiKey
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApiKey *mClientMockGetApiKey) Optional() *mClientMockGetApiKey {
	mmGetApiKey.optional = true
	return mmGetApiKey
}

// Expect sets up expected params for Client.GetApiKey
func (mmGetApiKey *mClientMockGetApiKey) Expect(ctx context.Context, name string) *mClientMockGetApiKey {
	if mmGetApiKey.mock.funcGetApiKey != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Set")
	}

	if mmGetApiKey.defaultExpectation == nil {
		mmGetApiKey.defaultExpectation = &ClientMockGetApiKeyExpectation{}
	}

	if mmGetApiKey.defaultExpectation.paramPtrs != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by ExpectParams functions")
	}

	mmGetApiKey.defaultExpectation.params = &ClientMockGetApiKeyParams{ctx, name}
	for _, e := range mmGetApiKey.expectations {
		if minimock.Equal(e.params, mmGetApiKey.defaultExpectation.params) {
			mmGetApiKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApiKey.defaultExpectation.params)
		}
	}

	return mmGetApiKey
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetApiKey
func (mmGetApiKey *mClientMockGetApiKey) ExpectCtxParam1(ctx context.Context) *mClientMockGetApiKey {
	if mmGetApiKey.mock.funcGetApiKey != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Set")
	}

	if mmGetApiKey.defaultExpectation == nil {
		mmGetApiKey.defaultExpectation = &ClientMockGetApiKeyExpectation{}
	}

	if mmGetApiKey.defaultExpectation.params != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Expect")
	}

	if mmGetApiKey.defaultExpectation.paramPtrs == nil {
		mmGetApiKey.defaultExpectation.paramPtrs = &ClientMockGetApiKeyParamPtrs{}
	}
	mmGetApiKey.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApiKey
}

// ExpectNameParam2 sets up expected param name for Client.GetApiKey
func (mmGetApiKey *mClientMockGetApiKey) ExpectNameParam2(name string) *mClientMockGetApiKey {
	if mmGetApiKey.mock.funcGetApiKey != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Set")
	}

	if mmGetApiKey.defaultExpectation == nil {
		mmGetApiKey.defaultExpectation = &ClientMockGetApiKeyExpectation{}
	}

	if mmGetApiKey.defaultExpectation.params != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Expect")
	}

	if mmGetApiKey.defaultExpectation.paramPtrs == nil {
		mmGetApiKey.defaultExpectation.paramPtrs = &ClientMockGetApiKeyParamPtrs{}
	}
	mmGetApiKey.defaultExpectation.paramPtrs.name = &name

	return mmGetApiKey
}

// Inspect accepts an inspector function that has same arguments as the Client.GetApiKey
func (mmGetApiKey *mClientMockGetApiKey) Inspect(f func(ctx context.Context, name string)) *mClientMockGetApiKey {
	if mmGetApiKey.mock.inspectFuncGetApiKey != nil {
		mmGetApiKey.mock.t.Fatalf("Inspect function is already set for ClientMock.GetApiKey")
	}

	mmGetApiKey.mock.inspectFuncGetApiKey = f

	return mmGetApiKey
}

// Return sets up results that will be returned by Client.GetApiKey
func (mmGetApiKey *mClientMockGetApiKey) Return(ap1 *ApiKey, err error) *ClientMock {
	if mmGetApiKey.mock.funcGetApiKey != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Set")
	}

	if mmGetApiKey.defaultExpectation == nil {
		mmGetApiKey.defaultExpectation = &ClientMockGetApiKeyExpectation{mock: mmGetApiKey.mock}
	}
	mmGetApiKey.defaultExpectation.results = &ClientMockGetApiKeyResults{ap1, err}
	return mmGetApiKey.mock
}

// Set uses given function f to mock the Client.GetApiKey method
func (mmGetApiKey *mClientMockGetApiKey) Set(f func(ctx context.Context, name string) (ap1 *ApiKey, err error)) *ClientMock {
	if mmGetApiKey.defaultExpectation != nil {
		mmGetApiKey.mock.t.Fatalf("Default expectation is already set for the Client.GetApiKey method")
	}

	if len(mmGetApiKey.expectations) > 0 {
		mmGetApiKey.mock.t.Fatalf("Some expectations are already set for the Client.GetApiKey method")
	}

	mmGetApiKey.mock.funcGetApiKey = f
	return mmGetApiKey.mock
}

// When sets expectation for the Client.GetApiKey which will trigger the result defined by the following
// Then helper
func (mmGetApiKey *mClientMockGetApiKey) When(ctx context.Context, name string) *ClientMockGetApiKeyExpectation {
	if mmGetApiKey.mock.funcGetApiKey != nil {
		mmGetApiKey.mock.t.Fatalf("ClientMock.GetApiKey mock is already set by Set")
	}

	expectation := &ClientMockGetApiKeyExpectation{
		mock:   mmGetApiKey.mock,
		params: &ClientMockGetApiKeyParams{ctx, name},
	}
	mmGetApiKey.expectations = append(mmGetApiKey.expectations, expectation)
	return expectation
}

// Then sets up Client.GetApiKey return parameters for the expectation previously defined by the When method
func (e *ClientMockGetApiKeyExpectation) Then(ap1 *ApiKey, err error) *ClientMock {
	e.results = &ClientMockGetApiKeyResults{ap1, err}
	return e.mock
}

// Times sets number of times Client.GetApiKey should be invoked
func (mmGetApiKey *mClientMockGetApiKey) Times(n uint64) *mClientMockGetApiKey {
	if n == 0 {
		mmGetApiKey.mock.t.Fatalf("Times of ClientMock.GetApiKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApiKey.expectedInvocations, n)
	return mmGetApiKey
}

func (mmGetApiKey *mClientMockGetApiKey) invocationsDone() bool {
	if len(mmGetApiKey.expectations) == 0 && mmGetApiKey.defaultExpectation == nil && mmGetApiKey.mock.funcGetApiKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApiKey.mock.afterGetApiKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApiKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApiKey implements Client
func (mmGetApiKey *ClientMock) GetApiKey(ctx context.Context, name string) (ap1 *ApiKey, err error) {
	mm_atomic.AddUint64(&mmGetApiKey.beforeGetApiKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApiKey.afterGetApiKeyCounter, 1)

	if mmGetApiKey.inspectFuncGetApiKey != nil {
		mmGetApiKey.inspectFuncGetApiKey(ctx, name)
	}

	mm_params := ClientMockGetApiKeyParams{ctx, name}

	// Record call args
	mmGetApiKey.GetApiKeyMock.mutex.Lock()
	mmGetApiKey.GetApiKeyMock.callArgs = append(mmGetApiKey.GetApiKeyMock.callArgs, &mm_params)
	mmGetApiKey.GetApiKeyMock.mutex.Unlock()

	for _, e := range mmGetApiKey.GetApiKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApiKey.GetApiKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApiKey.GetApiKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApiKey.GetApiKeyMock.defaultExpectation.params
		mm_want_ptrs := mmGetApiKey.GetApiKeyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetApiKeyParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApiKey.t.Errorf("ClientMock.GetApiKey got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetApiKey.t.Errorf("ClientMock.GetApiKey got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApiKey.t.Errorf("ClientMock.GetApiKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApiKey.GetApiKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApiKey.t.Fatal("No results are set for the ClientMock.GetApiKey")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApiKey.funcGetApiKey != nil {
		return mmGetApiKey.funcGetApiKey(ctx, name)
	}
	mmGetApiKey.t.Fatalf("Unexpected call to ClientMock.GetApiKey. %v %v", ctx, name)
	return
}

// GetApiKeyAfterCounter returns a count of finished ClientMock.GetApiKey invocations
func (mmGetApiKey *ClientMock) GetApiKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApiKey.afterGetApiKeyCounter)
}

// GetApiKeyBeforeCounter returns a count of ClientMock.GetApiKey invocations
func (mmGetApiKey *ClientMock) GetApiKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApiKey.beforeGetApiKeyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetApiKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApiKey *mClientMockGetApiKey) Calls() []*ClientMockGetApiKeyParams {
	mmGetApiKey.mutex.RLock()

	argCopy := make([]*ClientMockGetApiKeyParams, len(mmGetApiKey.callArgs))
	copy(argCopy, mmGetApiKey.callArgs)

	mmGetApiKey.mutex.RUnlock()

	return argCopy
}

// MinimockGetApiKeyDone returns true if the count of the GetApiKey invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetApiKeyDone() bool {
	if m.GetApiKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApiKeyMock.invocationsDone()
}

// MinimockGetApiKeyInspect logs each unmet expectation
func (m *ClientMock) MinimockGetApiKeyInspect() {
	for _, e := range m.GetApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetApiKey with params: %#v", *e.params)
		}
	}

	afterGetApiKeyCounter := mm_atomic.LoadUint64(&m.afterGetApiKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApiKeyMock.defaultExpectation != nil && afterGetApiKeyCounter < 1 {
		if m.GetApiKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetApiKey")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetApiKey with params: %#v", *m.GetApiKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApiKey != nil && afterGetApiKeyCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetApiKey")
	}

	if !m.GetApiKeyMock.invocationsDone() && afterGetApiKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetApiKey but found %d calls",
			mm_atomic.LoadUint64(&m.GetApiKeyMock.expectedInvocations), afterGetApiKeyCounter)
	}
}

type mClientMockGetBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetBackupConfigurationExpectation
	expectations       []*ClientMockGetBackupConfigurationExpectation

	callArgs []*ClientMockGetBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetBackupConfigurationExpectation specifies expectation struct of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetBackupConfigurationParams
	paramPtrs *ClientMockGetBackupConfigurationParamPtrs
	results   *ClientMockGetBackupConfigurationResults
	Counter   uint64
}

// ClientMockGetBackupConfigurationParams contains parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetBackupConfigurationParamPtrs contains pointers to parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetBackupConfigurationResults contains results of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Optional() *mClientMockGetBackupConfiguration {
	mmGetBackupConfiguration.optional = true
	return mmGetBackupConfiguration
}

// Expect sets up expected params for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Expect(ctx context.Context, serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmGetBackupConfiguration.defaultExpectation.params = &ClientMockGetBackupConfigurationParams{ctx, serviceId}
	for _, e := range mmGetBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmGetBackupConfiguration.defaultExpectation.params) {
			mmGetBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmGetBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.GetBackupConfiguration")
	}

	mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration = f

	return mmGetBackupConfiguration
}

// Return sets up results that will be returned by Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{mock: mmGetBackupConfiguration.mock}
	}
	mmGetBackupConfiguration.defaultExpectation.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return mmGetBackupConfiguration.mock
}

// Set uses given function f to mock the Client.GetBackupConfiguration method
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Set(f func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmGetBackupConfiguration.defaultExpectation != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.GetBackupConfiguration method")
	}

	if len(mmGetBackupConfiguration.expectations) > 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.GetBackupConfiguration method")
	}

	mmGetBackupConfiguration.mock.funcGetBackupConfiguration = f
	return mmGetBackupConfiguration.mock
}

// When sets expectation for the Client.GetBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) When(ctx context.Context, serviceId string) *ClientMockGetBackupConfigurationExpectation {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockGetBackupConfigurationExpectation{
		mock:   mmGetBackupConfiguration.mock,
		params: &ClientMockGetBackupConfigurationParams{ctx, serviceId},
	}
	mmGetBackupConfiguration.expectations = append(mmGetBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.GetBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockGetBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.GetBackupConfiguration should be invoked
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Times(n uint64) *mClientMockGetBackupConfiguration {
	if n == 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Times of ClientMock.GetBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBackupConfiguration.expectedInvocations, n)
	return mmGetBackupConfiguration
}

func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) invocationsDone() bool {
	if len(mmGetBackupConfiguration.expectations) == 0 && mmGetBackupConfiguration.defaultExpectation == nil && mmGetBackupConfiguration.mock.funcGetBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.mock.afterGetBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBackupConfiguration implements Client
func (mmGetBackupConfiguration *ClientMock) GetBackupConfiguration(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter, 1)

	if mmGetBackupConfiguration.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.inspectFuncGetBackupConfiguration(ctx, serviceId)
	}

	mm_params := ClientMockGetBackupConfigurationParams{ctx, serviceId}

	// Record call args
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Lock()
	mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs = append(mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs, &mm_params)
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmGetBackupConfiguration.GetBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetBackupConfigurationParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBackupConfiguration.t.Fatal("No results are set for the ClientMock.GetBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBackupConfiguration.funcGetBackupConfiguration != nil {
		return mmGetBackupConfiguration.funcGetBackupConfiguration(ctx, serviceId)
	}
	mmGetBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.GetBackupConfiguration. %v %v", ctx, serviceId)
	return
}

// GetBackupConfigurationAfterCounter returns a count of finished ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter)
}

// GetBackupConfigurationBeforeCounter returns a count of ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Calls() []*ClientMockGetBackupConfigurationParams {
	mmGetBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockGetBackupConfigurationParams, len(mmGetBackupConfiguration.callArgs))
	copy(argCopy, mmGetBackupConfiguration.callArgs)

	mmGetBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockGetBackupConfigurationDone returns true if the count of the GetBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetBackupConfigurationDone() bool {
	if m.GetBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBackupConfigurationMock.invocationsDone()
}

// MinimockGetBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockGetBackupConfigurationInspect() {
	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration with params: %#v", *e.params)
		}
	}

	afterGetBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterGetBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBackupConfigurationMock.defaultExpectation != nil && afterGetBackupConfigurationCounter < 1 {
		if m.GetBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetBackupConfiguration")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration with params: %#v", *m.GetBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBackupConfiguration != nil && afterGetBackupConfigurationCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetBackupConfiguration")
	}

	if !m.GetBackupConfigurationMock.invocationsDone() && afterGetBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetBackupConfiguration but found %d calls",
			mm_atomic.LoadUint64(&m.GetBackupConfigurationMock.expectedInvocations), afterGetBackupConfigurationCounter)
	}
}

type mClientMockGetClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetClickPipeExpectation
	expectations       []*ClientMockGetClickPipeExpectation

	callArgs []*ClientMockGetClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetClickPipeExpectation specifies expectation struct of the Client.GetClickPipe
type ClientMockGetClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetClickPipeParams
	paramPtrs *ClientMockGetClickPipeParamPtrs
	results   *ClientMockGetClickPipeResults
	Counter   uint64
}

// ClientMockGetClickPipeParams contains parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
}

// ClientMockGetClickPipeParamPtrs contains pointers to parameters of the Client.GetClickPipe
type ClientMockGetClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
}

// ClientMockGetClickPipeResults contains results of the Client.GetClickPipe
type ClientMockGetClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClickPipe *mClientMockGetClickPipe) Optional() *mClientMockGetClickPipe {
	mmGetClickPipe.optional = true
	return mmGetClickPipe
}

// Expect sets up expected params for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by ExpectParams functions")
	}

	mmGetClickPipe.defaultExpectation.params = &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}
	for _, e := range mmGetClickPipe.expectations {
		if minimock.Equal(e.params, mmGetClickPipe.defaultExpectation.params) {
			mmGetClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClickPipe.defaultExpectation.params)
		}
	}

	return mmGetClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{}
	}

	if mmGetClickPipe.defaultExpectation.params != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Expect")
	}

	if mmGetClickPipe.defaultExpectation.paramPtrs == nil {
		mmGetClickPipe.defaultExpectation.paramPtrs = &ClientMockGetClickPipeParamPtrs{}
	}
	mmGetClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmGetClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string)) *mClientMockGetClickPipe {
	if mmGetClickPipe.mock.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.GetClickPipe")
	}

	mmGetClickPipe.mock.inspectFuncGetClickPipe = f

	return mmGetClickPipe
}

// Return sets up results that will be returned by Client.GetClickPipe
func (mmGetClickPipe *mClientMockGetClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	if mmGetClickPipe.defaultExpectation == nil {
		mmGetClickPipe.defaultExpectation = &ClientMockGetClickPipeExpectation{mock: mmGetClickPipe.mock}
	}
	mmGetClickPipe.defaultExpectation.results = &ClientMockGetClickPipeResults{cp1, err}
	return mmGetClickPipe.mock
}

// Set uses given function f to mock the Client.GetClickPipe method
func (mmGetClickPipe *mClientMockGetClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmGetClickPipe.defaultExpectation != nil {
		mmGetClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.GetClickPipe method")
	}

	if len(mmGetClickPipe.expectations) > 0 {
		mmGetClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.GetClickPipe method")
	}

	mmGetClickPipe.mock.funcGetClickPipe = f
	return mmGetClickPipe.mock
}

// When sets expectation for the Client.GetClickPipe which will trigger the result defined by the following
// Then helper
func (mmGetClickPipe *mClientMockGetClickPipe) When(ctx context.Context, serviceId string, clickPipeId string) *ClientMockGetClickPipeExpectation {
	if mmGetClickPipe.mock.funcGetClickPipe != nil {
		mmGetClickPipe.mock.t.Fatalf("ClientMock.GetClickPipe mock is already set by Set")
	}

	expectation := &ClientMockGetClickPipeExpectation{
		mock:   mmGetClickPipe.mock,
		params: &ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId},
	}
	mmGetClickPipe.expectations = append(mmGetClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.GetClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockGetClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockGetClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.GetClickPipe should be invoked
func (mmGetClickPipe *mClientMockGetClickPipe) Times(n uint64) *mClientMockGetClickPipe {
	if n == 0 {
		mmGetClickPipe.mock.t.Fatalf("Times of ClientMock.GetClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClickPipe.expectedInvocations, n)
	return mmGetClickPipe
}

func (mmGetClickPipe *mClientMockGetClickPipe) invocationsDone() bool {
	if len(mmGetClickPipe.expectations) == 0 && mmGetClickPipe.defaultExpectation == nil && mmGetClickPipe.mock.funcGetClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.mock.afterGetClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClickPipe implements Client
func (mmGetClickPipe *ClientMock) GetClickPipe(ctx context.Context, serviceId string, clickPipeId string) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmGetClickPipe.beforeGetClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClickPipe.afterGetClickPipeCounter, 1)

	if mmGetClickPipe.inspectFuncGetClickPipe != nil {
		mmGetClickPipe.inspectFuncGetClickPipe(ctx, serviceId, clickPipeId)
	}

	mm_params := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

	// Record call args
	mmGetClickPipe.GetClickPipeMock.mutex.Lock()
	mmGetClickPipe.GetClickPipeMock.callArgs = append(mmGetClickPipe.GetClickPipeMock.callArgs, &mm_params)
	mmGetClickPipe.GetClickPipeMock.mutex.Unlock()

	for _, e := range mmGetClickPipe.GetClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetClickPipe.GetClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClickPipe.GetClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClickPipe.GetClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmGetClickPipe.GetClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetClickPipeParams{ctx, serviceId, clickPipeId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClickPipe.t.Errorf("ClientMock.GetClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClickPipe.GetClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClickPipe.t.Fatal("No results are set for the ClientMock.GetClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetClickPipe.funcGetClickPipe != nil {
		return mmGetClickPipe.funcGetClickPipe(ctx, serviceId, clickPipeId)
	}
	mmGetClickPipe.t.Fatalf("Unexpected call to ClientMock.GetClickPipe. %v %v %v", ctx, serviceId, clickPipeId)
	return
}

// GetClickPipeAfterCounter returns a count of finished ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.afterGetClickPipeCounter)
}

// GetClickPipeBeforeCounter returns a count of ClientMock.GetClickPipe invocations
func (mmGetClickPipe *ClientMock) GetClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClickPipe.beforeGetClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClickPipe *mClientMockGetClickPipe) Calls() []*ClientMockGetClickPipeParams {
	mmGetClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockGetClickPipeParams, len(mmGetClickPipe.callArgs))
	copy(argCopy, mmGetClickPipe.callArgs)

	mmGetClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockGetClickPipeDone returns true if the count of the GetClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetClickPipeDone() bool {
	if m.GetClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClickPipeMock.invocationsDone()
}

// MinimockGetClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetClickPipeInspect() {
	for _, e := range m.GetClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe with params: %#v", *e.params)
		}
	}

	afterGetClickPipeCounter := mm_atomic.LoadUint64(&m.afterGetClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClickPipeMock.defaultExpectation != nil && afterGetClickPipeCounter < 1 {
		if m.GetClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetClickPipe with params: %#v", *m.GetClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClickPipe != nil && afterGetClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetClickPipe")
	}

	if !m.GetClickPipeMock.invocationsDone() && afterGetClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.GetClickPipeMock.expectedInvocations), afterGetClickPipeCounter)
	}
}

type mClientMockGetCurrentApiKey struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetCurrentApiKeyExpectation
	expectations       []*ClientMockGetCurrentApiKeyExpectation

	callArgs []*ClientMockGetCurrentApiKeyParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetCurrentApiKeyExpectation specifies expectation struct of the Client.GetCurrentApiKey
type ClientMockGetCurrentApiKeyExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetCurrentApiKeyParams
	paramPtrs *ClientMockGetCurrentApiKeyParamPtrs
	results   *ClientMockGetCurrentApiKeyResults
	Counter   uint64
}

// ClientMockGetCurrentApiKeyParams contains parameters of the Client.GetCurrentApiKey
type ClientMockGetCurrentApiKeyParams struct {
	ctx context.Context
}

// ClientMockGetCurrentApiKeyParamPtrs contains pointers to parameters of the Client.GetCurrentApiKey
type ClientMockGetCurrentApiKeyParamPtrs struct {
	ctx *context.Context
}

// ClientMockGetCurrentApiKeyResults contains results of the Client.GetCurrentApiKey
type ClientMockGetCurrentApiKeyResults struct {
	ap1 *ApiKey
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Optional() *mClientMockGetCurrentApiKey {
	mmGetCurrentApiKey.optional = true
	return mmGetCurrentApiKey
}

// Expect sets up expected params for Client.GetCurrentApiKey
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Expect(ctx context.Context) *mClientMockGetCurrentApiKey {
	if mmGetCurrentApiKey.mock.funcGetCurrentApiKey != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("ClientMock.GetCurrentApiKey mock is already set by Set")
	}

	if mmGetCurrentApiKey.defaultExpectation == nil {
		mmGetCurrentApiKey.defaultExpectation = &ClientMockGetCurrentApiKeyExpectation{}
	}

	if mmGetCurrentApiKey.defaultExpectation.paramPtrs != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("ClientMock.GetCurrentApiKey mock is already set by ExpectParams functions")
	}

	mmGetCurrentApiKey.defaultExpectation.params = &ClientMockGetCurrentApiKeyParams{ctx}
	for _, e := range mmGetCurrentApiKey.expectations {
		if minimock.Equal(e.params, mmGetCurrentApiKey.defaultExpectation.params) {
			mmGetCurrentApiKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCurrentApiKey.defaultExpectation.params)
		}
	}

	return mmGetCurrentApiKey
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetCurrentApiKey
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) ExpectCtxParam1(ctx context.Context) *mClientMockGetCurrentApiKey {
	if mmGetCurrentApiKey.mock.funcGetCurrentApiKey != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("ClientMock.GetCurrentApiKey mock is already set by Set")
	}

	if mmGetCurrentApiKey.defaultExpectation == nil {
		mmGetCurrentApiKey.defaultExpectation = &ClientMockGetCurrentApiKeyExpectation{}
	}

	if mmGetCurrentApiKey.defaultExpectation.params != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("ClientMock.GetCurrentApiKey mock is already set by Expect")
	}

	if mmGetCurrentApiKey.defaultExpectation.paramPtrs == nil {
		mmGetCurrentApiKey.defaultExpectation.paramPtrs = &ClientMockGetCurrentApiKeyParamPtrs{}
	}
	mmGetCurrentApiKey.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCurrentApiKey
}

// Inspect accepts an inspector function that has same arguments as the Client.GetCurrentApiKey
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Inspect(f func(ctx context.Context)) *mClientMockGetCurrentApiKey {
	if mmGetCurrentApiKey.mock.inspectFuncGetCurrentApiKey != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("Inspect function is already set for ClientMock.GetCurrentApiKey")
	}

	mmGetCurrentApiKey.mock.inspectFuncGetCurrentApiKey = f

	return mmGetCurrentApiKey
}

// Return sets up results that will be returned by Client.GetCurrentApiKey
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Return(ap1 *ApiKey, err error) *ClientMock {
	if mmGetCurrentApiKey.mock.funcGetCurrentApiKey != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("ClientMock.GetCurrentApiKey mock is already set by Set")
	}

	if mmGetCurrentApiKey.defaultExpectation == nil {
		mmGetCurrentApiKey.defaultExpectation = &ClientMockGetCurrentApiKeyExpectation{mock: mmGetCurrentApiKey.mock}
	}
	mmGetCurrentApiKey.defaultExpectation.results = &ClientMockGetCurrentApiKeyResults{ap1, err}
	return mmGetCurrentApiKey.mock
}

// Set uses given function f to mock the Client.GetCurrentApiKey method
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Set(f func(ctx context.Context) (ap1 *ApiKey, err error)) *ClientMock {
	if mmGetCurrentApiKey.defaultExpectation != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("Default expectation is already set for the Client.GetCurrentApiKey method")
	}

	if len(mmGetCurrentApiKey.expectations) > 0 {
		mmGetCurrentApiKey.mock.t.Fatalf("Some expectations are already set for the Client.GetCurrentApiKey method")
	}

	mmGetCurrentApiKey.mock.funcGetCurrentApiKey = f
	return mmGetCurrentApiKey.mock
}

// When sets expectation for the Client.GetCurrentApiKey which will trigger the result defined by the following
// Then helper
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) When(ctx context.Context) *ClientMockGetCurrentApiKeyExpectation {
	if mmGetCurrentApiKey.mock.funcGetCurrentApiKey != nil {
		mmGetCurrentApiKey.mock.t.Fatalf("ClientMock.GetCurrentApiKey mock is already set by Set")
	}

	expectation := &ClientMockGetCurrentApiKeyExpectation{
		mock:   mmGetCurrentApiKey.mock,
		params: &ClientMockGetCurrentApiKeyParams{ctx},
	}
	mmGetCurrentApiKey.expectations = append(mmGetCurrentApiKey.expectations, expectation)
	return expectation
}

// Then sets up Client.GetCurrentApiKey return parameters for the expectation previously defined by the When method
func (e *ClientMockGetCurrentApiKeyExpectation) Then(ap1 *ApiKey, err error) *ClientMock {
	e.results = &ClientMockGetCurrentApiKeyResults{ap1, err}
	return e.mock
}

// Times sets number of times Client.GetCurrentApiKey should be invoked
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Times(n uint64) *mClientMockGetCurrentApiKey {
	if n == 0 {
		mmGetCurrentApiKey.mock.t.Fatalf("Times of ClientMock.GetCurrentApiKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCurrentApiKey.expectedInvocations, n)
	return mmGetCurrentApiKey
}

func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) invocationsDone() bool {
	if len(mmGetCurrentApiKey.expectations) == 0 && mmGetCurrentApiKey.defaultExpectation == nil && mmGetCurrentApiKey.mock.funcGetCurrentApiKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCurrentApiKey.mock.afterGetCurrentApiKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCurrentApiKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCurrentApiKey implements Client
func (mmGetCurrentApiKey *ClientMock) GetCurrentApiKey(ctx context.Context) (ap1 *ApiKey, err error) {
	mm_atomic.AddUint64(&mmGetCurrentApiKey.beforeGetCurrentApiKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCurrentApiKey.afterGetCurrentApiKeyCounter, 1)

	if mmGetCurrentApiKey.inspectFuncGetCurrentApiKey != nil {
		mmGetCurrentApiKey.inspectFuncGetCurrentApiKey(ctx)
	}

	mm_params := ClientMockGetCurrentApiKeyParams{ctx}

	// Record call args
	mmGetCurrentApiKey.GetCurrentApiKeyMock.mutex.Lock()
	mmGetCurrentApiKey.GetCurrentApiKeyMock.callArgs = append(mmGetCurrentApiKey.GetCurrentApiKeyMock.callArgs, &mm_params)
	mmGetCurrentApiKey.GetCurrentApiKeyMock.mutex.Unlock()

	for _, e := range mmGetCurrentApiKey.GetCurrentApiKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetCurrentApiKey.GetCurrentApiKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCurrentApiKey.GetCurrentApiKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCurrentApiKey.GetCurrentApiKeyMock.defaultExpectation.params
		mm_want_ptrs := mmGetCurrentApiKey.GetCurrentApiKeyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetCurrentApiKeyParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCurrentApiKey.t.Errorf("ClientMock.GetCurrentApiKey got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCurrentApiKey.t.Errorf("ClientMock.GetCurrentApiKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCurrentApiKey.GetCurrentApiKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCurrentApiKey.t.Fatal("No results are set for the ClientMock.GetCurrentApiKey")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetCurrentApiKey.funcGetCurrentApiKey != nil {
		return mmGetCurrentApiKey.funcGetCurrentApiKey(ctx)
	}
	mmGetCurrentApiKey.t.Fatalf("Unexpected call to ClientMock.GetCurrentApiKey. %v", ctx)
	return
}

// GetCurrentApiKeyAfterCounter returns a count of finished ClientMock.GetCurrentApiKey invocations
func (mmGetCurrentApiKey *ClientMock) GetCurrentApiKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentApiKey.afterGetCurrentApiKeyCounter)
}

// GetCurrentApiKeyBeforeCounter returns a count of ClientMock.GetCurrentApiKey invocations
func (mmGetCurrentApiKey *ClientMock) GetCurrentApiKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentApiKey.beforeGetCurrentApiKeyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetCurrentApiKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCurrentApiKey *mClientMockGetCurrentApiKey) Calls() []*ClientMockGetCurrentApiKeyParams {
	mmGetCurrentApiKey.mutex.RLock()

	argCopy := make([]*ClientMockGetCurrentApiKeyParams, len(mmGetCurrentApiKey.callArgs))
	copy(argCopy, mmGetCurrentApiKey.callArgs)

	mmGetCurrentApiKey.mutex.RUnlock()

	return argCopy
}

// MinimockGetCurrentApiKeyDone returns true if the count of the GetCurrentApiKey invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetCurrentApiKeyDone() bool {
	if m.GetCurrentApiKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCurrentApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCurrentApiKeyMock.invocationsDone()
}

// MinimockGetCurrentApiKeyInspect logs each unmet expectation
func (m *ClientMock) MinimockGetCurrentApiKeyInspect() {
	for _, e := range m.GetCurrentApiKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetCurrentApiKey with params: %#v", *e.params)
		}
	}

	afterGetCurrentApiKeyCounter := mm_atomic.LoadUint64(&m.afterGetCurrentApiKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentApiKeyMock.defaultExpectation != nil && afterGetCurrentApiKeyCounter < 1 {
		if m.GetCurrentApiKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetCurrentApiKey")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetCurrentApiKey with params: %#v", *m.GetCurrentApiKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentApiKey != nil && afterGetCurrentApiKeyCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetCurrentApiKey")
	}

	if !m.GetCurrentApiKeyMock.invocationsDone() && afterGetCurrentApiKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetCurrentApiKey but found %d calls",
			mm_atomic.LoadUint64(&m.GetCurrentApiKeyMock.expectedInvocations), afterGetCurrentApiKeyCounter)
	}
}

type mClientMockGetDatabase struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetDatabaseExpectation
	expectations       []*ClientMockGetDatabaseExpectation

	callArgs []*ClientMockGetDatabaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetDatabaseExpectation specifies expectation struct of the Client.GetDatabase
type ClientMockGetDatabaseExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetDatabaseParams
	paramPtrs *ClientMockGetDatabaseParamPtrs
	results   *ClientMockGetDatabaseResults
	Counter   uint64
}

// ClientMockGetDatabaseParams contains parameters of the Client.GetDatabase
type ClientMockGetDatabaseParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockGetDatabaseParamPtrs contains pointers to parameters of the Client.GetDatabase
type ClientMockGetDatabaseParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockGetDatabaseResults contains results of the Client.GetDatabase
type ClientMockGetDatabaseResults struct {
	dp1 *Database
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDatabase *mClientMockGetDatabase) Optional() *mClientMockGetDatabase {
	mmGetDatabase.optional = true
	return mmGetDatabase
}

// Expect sets up expected params for Client.GetDatabase
func (mmGetDatabase *mClientMockGetDatabase) Expect(ctx context.Context, serviceID string, name string) *mClientMockGetDatabase {
	if mmGetDatabase.mock.funcGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Set")
	}

	if mmGetDatabase.defaultExpectation == nil {
		mmGetDatabase.defaultExpectation = &ClientMockGetDatabaseExpectation{}
	}

	if mmGetDatabase.defaultExpectation.paramPtrs != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by ExpectParams functions")
	}

	mmGetDatabase.defaultExpectation.params = &ClientMockGetDatabaseParams{ctx, serviceID, name}
	for _, e := range mmGetDatabase.expectations {
		if minimock.Equal(e.params, mmGetDatabase.defaultExpectation.params) {
			mmGetDatabase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDatabase.defaultExpectation.params)
		}
	}

	return mmGetDatabase
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetDatabase
func (mmGetDatabase *mClientMockGetDatabase) ExpectCtxParam1(ctx context.Context) *mClientMockGetDatabase {
	if mmGetDatabase.mock.funcGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Set")
	}

	if mmGetDatabase.defaultExpectation == nil {
		mmGetDatabase.defaultExpectation = &ClientMockGetDatabaseExpectation{}
	}

	if mmGetDatabase.defaultExpectation.params != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Expect")
	}

	if mmGetDatabase.defaultExpectation.paramPtrs == nil {
		mmGetDatabase.defaultExpectation.paramPtrs = &ClientMockGetDatabaseParamPtrs{}
	}
	mmGetDatabase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetDatabase
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetDatabase
func (mmGetDatabase *mClientMockGetDatabase) ExpectServiceIDParam2(serviceID string) *mClientMockGetDatabase {
	if mmGetDatabase.mock.funcGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Set")
	}

	if mmGetDatabase.defaultExpectation == nil {
		mmGetDatabase.defaultExpectation = &ClientMockGetDatabaseExpectation{}
	}

	if mmGetDatabase.defaultExpectation.params != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Expect")
	}

	if mmGetDatabase.defaultExpectation.paramPtrs == nil {
		mmGetDatabase.defaultExpectation.paramPtrs = &ClientMockGetDatabaseParamPtrs{}
	}
	mmGetDatabase.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetDatabase
}

// ExpectNameParam3 sets up expected param name for Client.GetDatabase
func (mmGetDatabase *mClientMockGetDatabase) ExpectNameParam3(name string) *mClientMockGetDatabase {
	if mmGetDatabase.mock.funcGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Set")
	}

	if mmGetDatabase.defaultExpectation == nil {
		mmGetDatabase.defaultExpectation = &ClientMockGetDatabaseExpectation{}
	}

	if mmGetDatabase.defaultExpectation.params != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Expect")
	}

	if mmGetDatabase.defaultExpectation.paramPtrs == nil {
		mmGetDatabase.defaultExpectation.paramPtrs = &ClientMockGetDatabaseParamPtrs{}
	}
	mmGetDatabase.defaultExpectation.paramPtrs.name = &name

	return mmGetDatabase
}

// Inspect accepts an inspector function that has same arguments as the Client.GetDatabase
func (mmGetDatabase *mClientMockGetDatabase) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockGetDatabase {
	if mmGetDatabase.mock.inspectFuncGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("Inspect function is already set for ClientMock.GetDatabase")
	}

	mmGetDatabase.mock.inspectFuncGetDatabase = f

	return mmGetDatabase
}

// Return sets up results that will be returned by Client.GetDatabase
func (mmGetDatabase *mClientMockGetDatabase) Return(dp1 *Database, err error) *ClientMock {
	if mmGetDatabase.mock.funcGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Set")
	}

	if mmGetDatabase.defaultExpectation == nil {
		mmGetDatabase.defaultExpectation = &ClientMockGetDatabaseExpectation{mock: mmGetDatabase.mock}
	}
	mmGetDatabase.defaultExpectation.results = &ClientMockGetDatabaseResults{dp1, err}
	return mmGetDatabase.mock
}

// Set uses given function f to mock the Client.GetDatabase method
func (mmGetDatabase *mClientMockGetDatabase) Set(f func(ctx context.Context, serviceID string, name string) (dp1 *Database, err error)) *ClientMock {
	if mmGetDatabase.defaultExpectation != nil {
		mmGetDatabase.mock.t.Fatalf("Default expectation is already set for the Client.GetDatabase method")
	}

	if len(mmGetDatabase.expectations) > 0 {
		mmGetDatabase.mock.t.Fatalf("Some expectations are already set for the Client.GetDatabase method")
	}

	mmGetDatabase.mock.funcGetDatabase = f
	return mmGetDatabase.mock
}

// When sets expectation for the Client.GetDatabase which will trigger the result defined by the following
// Then helper
func (mmGetDatabase *mClientMockGetDatabase) When(ctx context.Context, serviceID string, name string) *ClientMockGetDatabaseExpectation {
	if mmGetDatabase.mock.funcGetDatabase != nil {
		mmGetDatabase.mock.t.Fatalf("ClientMock.GetDatabase mock is already set by Set")
	}

	expectation := &ClientMockGetDatabaseExpectation{
		mock:   mmGetDatabase.mock,
		params: &ClientMockGetDatabaseParams{ctx, serviceID, name},
	}
	mmGetDatabase.expectations = append(mmGetDatabase.expectations, expectation)
	return expectation
}

// Then sets up Client.GetDatabase return parameters for the expectation previously defined by the When method
func (e *ClientMockGetDatabaseExpectation) Then(dp1 *Database, err error) *ClientMock {
	e.results = &ClientMockGetDatabaseResults{dp1, err}
	return e.mock
}

// Times sets number of times Client.GetDatabase should be invoked
func (mmGetDatabase *mClientMockGetDatabase) Times(n uint64) *mClientMockGetDatabase {
	if n == 0 {
		mmGetDatabase.mock.t.Fatalf("Times of ClientMock.GetDatabase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDatabase.expectedInvocations, n)
	return mmGetDatabase
}

func (mmGetDatabase *mClientMockGetDatabase) invocationsDone() bool {
	if len(mmGetDatabase.expectations) == 0 && mmGetDatabase.defaultExpectation == nil && mmGetDatabase.mock.funcGetDatabase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDatabase.mock.afterGetDatabaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDatabase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDatabase implements Client
func (mmGetDatabase *ClientMock) GetDatabase(ctx context.Context, serviceID string, name string) (dp1 *Database, err error) {
	mm_atomic.AddUint64(&mmGetDatabase.beforeGetDatabaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDatabase.afterGetDatabaseCounter, 1)

	if mmGetDatabase.inspectFuncGetDatabase != nil {
		mmGetDatabase.inspectFuncGetDatabase(ctx, serviceID, name)
	}

	mm_params := ClientMockGetDatabaseParams{ctx, serviceID, name}

	// Record call args
	mmGetDatabase.GetDatabaseMock.mutex.Lock()
	mmGetDatabase.GetDatabaseMock.callArgs = append(mmGetDatabase.GetDatabaseMock.callArgs, &mm_params)
	mmGetDatabase.GetDatabaseMock.mutex.Unlock()

	for _, e := range mmGetDatabase.GetDatabaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGetDatabase.GetDatabaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDatabase.GetDatabaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDatabase.GetDatabaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetDatabase.GetDatabaseMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetDatabaseParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDatabase.t.Errorf("ClientMock.GetDatabase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetDatabase.t.Errorf("ClientMock.GetDatabase got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetDatabase.t.Errorf("ClientMock.GetDatabase got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDatabase.t.Errorf("ClientMock.GetDatabase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDatabase.GetDatabaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDatabase.t.Fatal("No results are set for the ClientMock.GetDatabase")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGetDatabase.funcGetDatabase != nil {
		return mmGetDatabase.funcGetDatabase(ctx, serviceID, name)
	}
	mmGetDatabase.t.Fatalf("Unexpected call to ClientMock.GetDatabase. %v %v %v", ctx, serviceID, name)
	return
}

// GetDatabaseAfterCounter returns a count of finished ClientMock.GetDatabase invocations
func (mmGetDatabase *ClientMock) GetDatabaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDatabase.afterGetDatabaseCounter)
}

// GetDatabaseBeforeCounter returns a count of ClientMock.GetDatabase invocations
func (mmGetDatabase *ClientMock) GetDatabaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDatabase.beforeGetDatabaseCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetDatabase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDatabase *mClientMockGetDatabase) Calls() []*ClientMockGetDatabaseParams {
	mmGetDatabase.mutex.RLock()

	argCopy := make([]*ClientMockGetDatabaseParams, len(mmGetDatabase.callArgs))
	copy(argCopy, mmGetDatabase.callArgs)

	mmGetDatabase.mutex.RUnlock()

	return argCopy
}

// MinimockGetDatabaseDone returns true if the count of the GetDatabase invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDatabaseDone() bool {
	if m.GetDatabaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDatabaseMock.invocationsDone()
}

// MinimockGetDatabaseInspect logs each unmet expectation
func (m *ClientMock) MinimockGetDatabaseInspect() {
	for _, e := range m.GetDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetDatabase with params: %#v", *e.params)
		}
	}

	afterGetDatabaseCounter := mm_atomic.LoadUint64(&m.afterGetDatabaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDatabaseMock.defaultExpectation != nil && afterGetDatabaseCounter < 1 {
		if m.GetDatabaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetDatabase")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetDatabase with params: %#v", *m.GetDatabaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDatabase != nil && afterGetDatabaseCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetDatabase")
	}

	if !m.GetDatabaseMock.invocationsDone() && afterGetDatabaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetDatabase but found %d calls",
			mm_atomic.LoadUint64(&m.GetDatabaseMock.expectedInvocations), afterGetDatabaseCounter)
	}
}

type mClientMockGetGrantPrivilege struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetGrantPrivilegeExpectation
	expectations       []*ClientMockGetGrantPrivilegeExpectation

	callArgs []*ClientMockGetGrantPrivilegeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetGrantPrivilegeExpectation specifies expectation struct of the Client.GetGrantPrivilege
type ClientMockGetGrantPrivilegeExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetGrantPrivilegeParams
	paramPtrs *ClientMockGetGrantPrivilegeParamPtrs
	results   *ClientMockGetGrantPrivilegeResults
	Counter   uint64
}

// ClientMockGetGrantPrivilegeParams contains parameters of the Client.GetGrantPrivilege
type ClientMockGetGrantPrivilegeParams struct {
	ctx             context.Context
	serviceID       string
	accessType      string
	database        *string
	table           *string
	column          *string
	granteeUserName *string
	granteeRoleName *string
}

// ClientMockGetGrantPrivilegeParamPtrs contains pointers to parameters of the Client.GetGrantPrivilege
type ClientMockGetGrantPrivilegeParamPtrs struct {
	ctx             *context.Context
	serviceID       *string
	accessType      *string
	database        **string
	table           **string
	column          **string
	granteeUserName **string
	granteeRoleName **string
}

// ClientMockGetGrantPrivilegeResults contains results of the Client.GetGrantPrivilege
type ClientMockGetGrantPrivilegeResults struct {
	gp1 *GrantPrivilege
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Optional() *mClientMockGetGrantPrivilege {
	mmGetGrantPrivilege.optional = true
	return mmGetGrantPrivilege
}

// Expect sets up expected params for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Expect(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by ExpectParams functions")
	}

	mmGetGrantPrivilege.defaultExpectation.params = &ClientMockGetGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName}
	for _, e := range mmGetGrantPrivilege.expectations {
		if minimock.Equal(e.params, mmGetGrantPrivilege.defaultExpectation.params) {
			mmGetGrantPrivilege.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetGrantPrivilege.defaultExpectation.params)
		}
	}

	return mmGetGrantPrivilege
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectCtxParam1(ctx context.Context) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetGrantPrivilege
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectServiceIDParam2(serviceID string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetGrantPrivilege
}

// ExpectAccessTypeParam3 sets up expected param accessType for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectAccessTypeParam3(accessType string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.accessType = &accessType

	return mmGetGrantPrivilege
}

// ExpectDatabaseParam4 sets up expected param database for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectDatabaseParam4(database *string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.database = &database

	return mmGetGrantPrivilege
}

// ExpectTableParam5 sets up expected param table for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectTableParam5(table *string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.table = &table

	return mmGetGrantPrivilege
}

// ExpectColumnParam6 sets up expected param column for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectColumnParam6(column *string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.column = &column

	return mmGetGrantPrivilege
}

// ExpectGranteeUserNameParam7 sets up expected param granteeUserName for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectGranteeUserNameParam7(granteeUserName *string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.granteeUserName = &granteeUserName

	return mmGetGrantPrivilege
}

// ExpectGranteeRoleNameParam8 sets up expected param granteeRoleName for Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) ExpectGranteeRoleNameParam8(granteeRoleName *string) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{}
	}

	if mmGetGrantPrivilege.defaultExpectation.params != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Expect")
	}

	if mmGetGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGetGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGetGrantPrivilegeParamPtrs{}
	}
	mmGetGrantPrivilege.defaultExpectation.paramPtrs.granteeRoleName = &granteeRoleName

	return mmGetGrantPrivilege
}

// Inspect accepts an inspector function that has same arguments as the Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Inspect(f func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string)) *mClientMockGetGrantPrivilege {
	if mmGetGrantPrivilege.mock.inspectFuncGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("Inspect function is already set for ClientMock.GetGrantPrivilege")
	}

	mmGetGrantPrivilege.mock.inspectFuncGetGrantPrivilege = f

	return mmGetGrantPrivilege
}

// Return sets up results that will be returned by Client.GetGrantPrivilege
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Return(gp1 *GrantPrivilege, err error) *ClientMock {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	if mmGetGrantPrivilege.defaultExpectation == nil {
		mmGetGrantPrivilege.defaultExpectation = &ClientMockGetGrantPrivilegeExpectation{mock: mmGetGrantPrivilege.mock}
	}
	mmGetGrantPrivilege.defaultExpectation.results = &ClientMockGetGrantPrivilegeResults{gp1, err}
	return mmGetGrantPrivilege.mock
}

// Set uses given function f to mock the Client.GetGrantPrivilege method
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Set(f func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) (gp1 *GrantPrivilege, err error)) *ClientMock {
	if mmGetGrantPrivilege.defaultExpectation != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("Default expectation is already set for the Client.GetGrantPrivilege method")
	}

	if len(mmGetGrantPrivilege.expectations) > 0 {
		mmGetGrantPrivilege.mock.t.Fatalf("Some expectations are already set for the Client.GetGrantPrivilege method")
	}

	mmGetGrantPrivilege.mock.funcGetGrantPrivilege = f
	return mmGetGrantPrivilege.mock
}

// When sets expectation for the Client.GetGrantPrivilege which will trigger the result defined by the following
// Then helper
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) When(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) *ClientMockGetGrantPrivilegeExpectation {
	if mmGetGrantPrivilege.mock.funcGetGrantPrivilege != nil {
		mmGetGrantPrivilege.mock.t.Fatalf("ClientMock.GetGrantPrivilege mock is already set by Set")
	}

	expectation := &ClientMockGetGrantPrivilegeExpectation{
		mock:   mmGetGrantPrivilege.mock,
		params: &ClientMockGetGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName},
	}
	mmGetGrantPrivilege.expectations = append(mmGetGrantPrivilege.expectations, expectation)
	return expectation
}

// Then sets up Client.GetGrantPrivilege return parameters for the expectation previously defined by the When method
func (e *ClientMockGetGrantPrivilegeExpectation) Then(gp1 *GrantPrivilege, err error) *ClientMock {
	e.results = &ClientMockGetGrantPrivilegeResults{gp1, err}
	return e.mock
}

// Times sets number of times Client.GetGrantPrivilege should be invoked
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Times(n uint64) *mClientMockGetGrantPrivilege {
	if n == 0 {
		mmGetGrantPrivilege.mock.t.Fatalf("Times of ClientMock.GetGrantPrivilege mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetGrantPrivilege.expectedInvocations, n)
	return mmGetGrantPrivilege
}

func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) invocationsDone() bool {
	if len(mmGetGrantPrivilege.expectations) == 0 && mmGetGrantPrivilege.defaultExpectation == nil && mmGetGrantPrivilege.mock.funcGetGrantPrivilege == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetGrantPrivilege.mock.afterGetGrantPrivilegeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetGrantPrivilege.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetGrantPrivilege implements Client
func (mmGetGrantPrivilege *ClientMock) GetGrantPrivilege(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) (gp1 *GrantPrivilege, err error) {
	mm_atomic.AddUint64(&mmGetGrantPrivilege.beforeGetGrantPrivilegeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGrantPrivilege.afterGetGrantPrivilegeCounter, 1)

	if mmGetGrantPrivilege.inspectFuncGetGrantPrivilege != nil {
		mmGetGrantPrivilege.inspectFuncGetGrantPrivilege(ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName)
	}

	mm_params := ClientMockGetGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName}

	// Record call args
	mmGetGrantPrivilege.GetGrantPrivilegeMock.mutex.Lock()
	mmGetGrantPrivilege.GetGrantPrivilegeMock.callArgs = append(mmGetGrantPrivilege.GetGrantPrivilegeMock.callArgs, &mm_params)
	mmGetGrantPrivilege.GetGrantPrivilegeMock.mutex.Unlock()

	for _, e := range mmGetGrantPrivilege.GetGrantPrivilegeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetGrantPrivilege.GetGrantPrivilegeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGrantPrivilege.GetGrantPrivilegeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetGrantPrivilege.GetGrantPrivilegeMock.defaultExpectation.params
		mm_want_ptrs := mmGetGrantPrivilege.GetGrantPrivilegeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.accessType != nil && !minimock.Equal(*mm_want_ptrs.accessType, mm_got.accessType) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter accessType, want: %#v, got: %#v%s\n", *mm_want_ptrs.accessType, mm_got.accessType, minimock.Diff(*mm_want_ptrs.accessType, mm_got.accessType))
			}

			if mm_want_ptrs.database != nil && !minimock.Equal(*mm_want_ptrs.database, mm_got.database) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter database, want: %#v, got: %#v%s\n", *mm_want_ptrs.database, mm_got.database, minimock.Diff(*mm_want_ptrs.database, mm_got.database))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter table, want: %#v, got: %#v%s\n", *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

			if mm_want_ptrs.column != nil && !minimock.Equal(*mm_want_ptrs.column, mm_got.column) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter column, want: %#v, got: %#v%s\n", *mm_want_ptrs.column, mm_got.column, minimock.Diff(*mm_want_ptrs.column, mm_got.column))
			}

			if mm_want_ptrs.granteeUserName != nil && !minimock.Equal(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter granteeUserName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeUserName, mm_got.granteeUserName, minimock.Diff(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName))
			}

			if mm_want_ptrs.granteeRoleName != nil && !minimock.Equal(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName) {
				mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameter granteeRoleName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName, minimock.Diff(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetGrantPrivilege.t.Errorf("ClientMock.GetGrantPrivilege got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetGrantPrivilege.GetGrantPrivilegeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGrantPrivilege.t.Fatal("No results are set for the ClientMock.GetGrantPrivilege")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetGrantPrivilege.funcGetGrantPrivilege != nil {
		return mmGetGrantPrivilege.funcGetGrantPrivilege(ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName)
	}
	mmGetGrantPrivilege.t.Fatalf("Unexpected call to ClientMock.GetGrantPrivilege. %v %v %v %v %v %v %v %v", ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName)
	return
}

// GetGrantPrivilegeAfterCounter returns a count of finished ClientMock.GetGrantPrivilege invocations
func (mmGetGrantPrivilege *ClientMock) GetGrantPrivilegeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGrantPrivilege.afterGetGrantPrivilegeCounter)
}

// GetGrantPrivilegeBeforeCounter returns a count of ClientMock.GetGrantPrivilege invocations
func (mmGetGrantPrivilege *ClientMock) GetGrantPrivilegeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGrantPrivilege.beforeGetGrantPrivilegeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetGrantPrivilege.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetGrantPrivilege *mClientMockGetGrantPrivilege) Calls() []*ClientMockGetGrantPrivilegeParams {
	mmGetGrantPrivilege.mutex.RLock()

	argCopy := make([]*ClientMockGetGrantPrivilegeParams, len(mmGetGrantPrivilege.callArgs))
	copy(argCopy, mmGetGrantPrivilege.callArgs)

	mmGetGrantPrivilege.mutex.RUnlock()

	return argCopy
}

// MinimockGetGrantPrivilegeDone returns true if the count of the GetGrantPrivilege invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetGrantPrivilegeDone() bool {
	if m.GetGrantPrivilegeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetGrantPrivilegeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetGrantPrivilegeMock.invocationsDone()
}

// MinimockGetGrantPrivilegeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetGrantPrivilegeInspect() {
	for _, e := range m.GetGrantPrivilegeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetGrantPrivilege with params: %#v", *e.params)
		}
	}

	afterGetGrantPrivilegeCounter := mm_atomic.LoadUint64(&m.afterGetGrantPrivilegeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetGrantPrivilegeMock.defaultExpectation != nil && afterGetGrantPrivilegeCounter < 1 {
		if m.GetGrantPrivilegeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetGrantPrivilege")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetGrantPrivilege with params: %#v", *m.GetGrantPrivilegeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGrantPrivilege != nil && afterGetGrantPrivilegeCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetGrantPrivilege")
	}

	if !m.GetGrantPrivilegeMock.invocationsDone() && afterGetGrantPrivilegeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetGrantPrivilege but found %d calls",
			mm_atomic.LoadUint64(&m.GetGrantPrivilegeMock.expectedInvocations), afterGetGrantPrivilegeCounter)
	}
}

type mClientMockGetGrantRole struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetGrantRoleExpectation
	expectations       []*ClientMockGetGrantRoleExpectation

	callArgs []*ClientMockGetGrantRoleParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetGrantRoleExpectation specifies expectation struct of the Client.GetGrantRole
type ClientMockGetGrantRoleExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetGrantRoleParams
	paramPtrs *ClientMockGetGrantRoleParamPtrs
	results   *ClientMockGetGrantRoleResults
	Counter   uint64
}

// ClientMockGetGrantRoleParams contains parameters of the Client.GetGrantRole
type ClientMockGetGrantRoleParams struct {
	ctx             context.Context
	serviceID       string
	grantedRoleName string
	granteeUserName *string
	granteeRoleName *string
}

// ClientMockGetGrantRoleParamPtrs contains pointers to parameters of the Client.GetGrantRole
type ClientMockGetGrantRoleParamPtrs struct {
	ctx             *context.Context
	serviceID       *string
	grantedRoleName *string
	granteeUserName **string
	granteeRoleName **string
}

// ClientMockGetGrantRoleResults contains results of the Client.GetGrantRole
type ClientMockGetGrantRoleResults struct {
	gp1 *GrantRole
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetGrantRole *mClientMockGetGrantRole) Optional() *mClientMockGetGrantRole {
	mmGetGrantRole.optional = true
	return mmGetGrantRole
}

// Expect sets up expected params for Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) Expect(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{}
	}

	if mmGetGrantRole.defaultExpectation.paramPtrs != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by ExpectParams functions")
	}

	mmGetGrantRole.defaultExpectation.params = &ClientMockGetGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName}
	for _, e := range mmGetGrantRole.expectations {
		if minimock.Equal(e.params, mmGetGrantRole.defaultExpectation.params) {
			mmGetGrantRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetGrantRole.defaultExpectation.params)
		}
	}

	return mmGetGrantRole
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) ExpectCtxParam1(ctx context.Context) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{}
	}

	if mmGetGrantRole.defaultExpectation.params != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Expect")
	}

	if mmGetGrantRole.defaultExpectation.paramPtrs == nil {
		mmGetGrantRole.defaultExpectation.paramPtrs = &ClientMockGetGrantRoleParamPtrs{}
	}
	mmGetGrantRole.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetGrantRole
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) ExpectServiceIDParam2(serviceID string) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{}
	}

	if mmGetGrantRole.defaultExpectation.params != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Expect")
	}

	if mmGetGrantRole.defaultExpectation.paramPtrs == nil {
		mmGetGrantRole.defaultExpectation.paramPtrs = &ClientMockGetGrantRoleParamPtrs{}
	}
	mmGetGrantRole.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetGrantRole
}

// ExpectGrantedRoleNameParam3 sets up expected param grantedRoleName for Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) ExpectGrantedRoleNameParam3(grantedRoleName string) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{}
	}

	if mmGetGrantRole.defaultExpectation.params != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Expect")
	}

	if mmGetGrantRole.defaultExpectation.paramPtrs == nil {
		mmGetGrantRole.defaultExpectation.paramPtrs = &ClientMockGetGrantRoleParamPtrs{}
	}
	mmGetGrantRole.defaultExpectation.paramPtrs.grantedRoleName = &grantedRoleName

	return mmGetGrantRole
}

// ExpectGranteeUserNameParam4 sets up expected param granteeUserName for Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) ExpectGranteeUserNameParam4(granteeUserName *string) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{}
	}

	if mmGetGrantRole.defaultExpectation.params != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Expect")
	}

	if mmGetGrantRole.defaultExpectation.paramPtrs == nil {
		mmGetGrantRole.defaultExpectation.paramPtrs = &ClientMockGetGrantRoleParamPtrs{}
	}
	mmGetGrantRole.defaultExpectation.paramPtrs.granteeUserName = &granteeUserName

	return mmGetGrantRole
}

// ExpectGranteeRoleNameParam5 sets up expected param granteeRoleName for Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) ExpectGranteeRoleNameParam5(granteeRoleName *string) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{}
	}

	if mmGetGrantRole.defaultExpectation.params != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Expect")
	}

	if mmGetGrantRole.defaultExpectation.paramPtrs == nil {
		mmGetGrantRole.defaultExpectation.paramPtrs = &ClientMockGetGrantRoleParamPtrs{}
	}
	mmGetGrantRole.defaultExpectation.paramPtrs.granteeRoleName = &granteeRoleName

	return mmGetGrantRole
}

// Inspect accepts an inspector function that has same arguments as the Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) Inspect(f func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string)) *mClientMockGetGrantRole {
	if mmGetGrantRole.mock.inspectFuncGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("Inspect function is already set for ClientMock.GetGrantRole")
	}

	mmGetGrantRole.mock.inspectFuncGetGrantRole = f

	return mmGetGrantRole
}

// Return sets up results that will be returned by Client.GetGrantRole
func (mmGetGrantRole *mClientMockGetGrantRole) Return(gp1 *GrantRole, err error) *ClientMock {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	if mmGetGrantRole.defaultExpectation == nil {
		mmGetGrantRole.defaultExpectation = &ClientMockGetGrantRoleExpectation{mock: mmGetGrantRole.mock}
	}
	mmGetGrantRole.defaultExpectation.results = &ClientMockGetGrantRoleResults{gp1, err}
	return mmGetGrantRole.mock
}

// Set uses given function f to mock the Client.GetGrantRole method
func (mmGetGrantRole *mClientMockGetGrantRole) Set(f func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) (gp1 *GrantRole, err error)) *ClientMock {
	if mmGetGrantRole.defaultExpectation != nil {
		mmGetGrantRole.mock.t.Fatalf("Default expectation is already set for the Client.GetGrantRole method")
	}

	if len(mmGetGrantRole.expectations) > 0 {
		mmGetGrantRole.mock.t.Fatalf("Some expectations are already set for the Client.GetGrantRole method")
	}

	mmGetGrantRole.mock.funcGetGrantRole = f
	return mmGetGrantRole.mock
}

// When sets expectation for the Client.GetGrantRole which will trigger the result defined by the following
// Then helper
func (mmGetGrantRole *mClientMockGetGrantRole) When(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) *ClientMockGetGrantRoleExpectation {
	if mmGetGrantRole.mock.funcGetGrantRole != nil {
		mmGetGrantRole.mock.t.Fatalf("ClientMock.GetGrantRole mock is already set by Set")
	}

	expectation := &ClientMockGetGrantRoleExpectation{
		mock:   mmGetGrantRole.mock,
		params: &ClientMockGetGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName},
	}
	mmGetGrantRole.expectations = append(mmGetGrantRole.expectations, expectation)
	return expectation
}

// Then sets up Client.GetGrantRole return parameters for the expectation previously defined by the When method
func (e *ClientMockGetGrantRoleExpectation) Then(gp1 *GrantRole, err error) *ClientMock {
	e.results = &ClientMockGetGrantRoleResults{gp1, err}
	return e.mock
}

// Times sets number of times Client.GetGrantRole should be invoked
func (mmGetGrantRole *mClientMockGetGrantRole) Times(n uint64) *mClientMockGetGrantRole {
	if n == 0 {
		mmGetGrantRole.mock.t.Fatalf("Times of ClientMock.GetGrantRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetGrantRole.expectedInvocations, n)
	return mmGetGrantRole
}

func (mmGetGrantRole *mClientMockGetGrantRole) invocationsDone() bool {
	if len(mmGetGrantRole.expectations) == 0 && mmGetGrantRole.defaultExpectation == nil && mmGetGrantRole.mock.funcGetGrantRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetGrantRole.mock.afterGetGrantRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetGrantRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetGrantRole implements Client
func (mmGetGrantRole *ClientMock) GetGrantRole(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) (gp1 *GrantRole, err error) {
	mm_atomic.AddUint64(&mmGetGrantRole.beforeGetGrantRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGrantRole.afterGetGrantRoleCounter, 1)

	if mmGetGrantRole.inspectFuncGetGrantRole != nil {
		mmGetGrantRole.inspectFuncGetGrantRole(ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName)
	}

	mm_params := ClientMockGetGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName}

	// Record call args
	mmGetGrantRole.GetGrantRoleMock.mutex.Lock()
	mmGetGrantRole.GetGrantRoleMock.callArgs = append(mmGetGrantRole.GetGrantRoleMock.callArgs, &mm_params)
	mmGetGrantRole.GetGrantRoleMock.mutex.Unlock()

	for _, e := range mmGetGrantRole.GetGrantRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetGrantRole.GetGrantRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGrantRole.GetGrantRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmGetGrantRole.GetGrantRoleMock.defaultExpectation.params
		mm_want_ptrs := mmGetGrantRole.GetGrantRoleMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetGrantRole.t.Errorf("ClientMock.GetGrantRole got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetGrantRole.t.Errorf("ClientMock.GetGrantRole got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.grantedRoleName != nil && !minimock.Equal(*mm_want_ptrs.grantedRoleName, mm_got.grantedRoleName) {
				mmGetGrantRole.t.Errorf("ClientMock.GetGrantRole got unexpected parameter grantedRoleName, want: %#v, got: %#v%s\n", *mm_want_ptrs.grantedRoleName, mm_got.grantedRoleName, minimock.Diff(*mm_want_ptrs.grantedRoleName, mm_got.grantedRoleName))
			}

			if mm_want_ptrs.granteeUserName != nil && !minimock.Equal(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName) {
				mmGetGrantRole.t.Errorf("ClientMock.GetGrantRole got unexpected parameter granteeUserName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeUserName, mm_got.granteeUserName, minimock.Diff(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName))
			}

			if mm_want_ptrs.granteeRoleName != nil && !minimock.Equal(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName) {
				mmGetGrantRole.t.Errorf("ClientMock.GetGrantRole got unexpected parameter granteeRoleName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName, minimock.Diff(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetGrantRole.t.Errorf("ClientMock.GetGrantRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetGrantRole.GetGrantRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGrantRole.t.Fatal("No results are set for the ClientMock.GetGrantRole")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetGrantRole.funcGetGrantRole != nil {
		return mmGetGrantRole.funcGetGrantRole(ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName)
	}
	mmGetGrantRole.t.Fatalf("Unexpected call to ClientMock.GetGrantRole. %v %v %v %v %v", ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName)
	return
}

// GetGrantRoleAfterCounter returns a count of finished ClientMock.GetGrantRole invocations
func (mmGetGrantRole *ClientMock) GetGrantRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGrantRole.afterGetGrantRoleCounter)
}

// GetGrantRoleBeforeCounter returns a count of ClientMock.GetGrantRole invocations
func (mmGetGrantRole *ClientMock) GetGrantRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGrantRole.beforeGetGrantRoleCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetGrantRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetGrantRole *mClientMockGetGrantRole) Calls() []*ClientMockGetGrantRoleParams {
	mmGetGrantRole.mutex.RLock()

	argCopy := make([]*ClientMockGetGrantRoleParams, len(mmGetGrantRole.callArgs))
	copy(argCopy, mmGetGrantRole.callArgs)

	mmGetGrantRole.mutex.RUnlock()

	return argCopy
}

// MinimockGetGrantRoleDone returns true if the count of the GetGrantRole invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetGrantRoleDone() bool {
	if m.GetGrantRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetGrantRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetGrantRoleMock.invocationsDone()
}

// MinimockGetGrantRoleInspect logs each unmet expectation
func (m *ClientMock) MinimockGetGrantRoleInspect() {
	for _, e := range m.GetGrantRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetGrantRole with params: %#v", *e.params)
		}
	}

	afterGetGrantRoleCounter := mm_atomic.LoadUint64(&m.afterGetGrantRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetGrantRoleMock.defaultExpectation != nil && afterGetGrantRoleCounter < 1 {
		if m.GetGrantRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetGrantRole")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetGrantRole with params: %#v", *m.GetGrantRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGrantRole != nil && afterGetGrantRoleCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetGrantRole")
	}

	if !m.GetGrantRoleMock.invocationsDone() && afterGetGrantRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetGrantRole but found %d calls",
			mm_atomic.LoadUint64(&m.GetGrantRoleMock.expectedInvocations), afterGetGrantRoleCounter)
	}
}

type mClientMockGetOrgPrivateEndpointConfig struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrgPrivateEndpointConfigExpectation
	expectations       []*ClientMockGetOrgPrivateEndpointConfigExpectation

	callArgs []*ClientMockGetOrgPrivateEndpointConfigParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetOrgPrivateEndpointConfigExpectation specifies expectation struct of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetOrgPrivateEndpointConfigParams
	paramPtrs *ClientMockGetOrgPrivateEndpointConfigParamPtrs
	results   *ClientMockGetOrgPrivateEndpointConfigResults
	Counter   uint64
}

// ClientMockGetOrgPrivateEndpointConfigParams contains parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParams struct {
	ctx           context.Context
	cloudProvider string
	region        string
}

// ClientMockGetOrgPrivateEndpointConfigParamPtrs contains pointers to parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParamPtrs struct {
	ctx           *context.Context
	cloudProvider *string
	region        *string
}

// ClientMockGetOrgPrivateEndpointConfigResults contains results of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigResults struct {
	op1 *OrgPrivateEndpointConfig
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Optional() *mClientMockGetOrgPrivateEndpointConfig {
	mmGetOrgPrivateEndpointConfig.optional = true
	return mmGetOrgPrivateEndpointConfig
}

// Expect sets up expected params for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Expect(ctx context.Context, cloudProvider string, region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by ExpectParams functions")
	}

	mmGetOrgPrivateEndpointConfig.defaultExpectation.params = &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}
	for _, e := range mmGetOrgPrivateEndpointConfig.expectations {
		if minimock.Equal(e.params, mmGetOrgPrivateEndpointConfig.defaultExpectation.params) {
			mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrgPrivateEndpointConfig.defaultExpectation.params)
		}
	}

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCloudProviderParam2 sets up expected param cloudProvider for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCloudProviderParam2(cloudProvider string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.cloudProvider = &cloudProvider

	return mmGetOrgPrivateEndpointConfig
}

// ExpectRegionParam3 sets up expected param region for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectRegionParam3(region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.region = &region

	return mmGetOrgPrivateEndpointConfig
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Inspect(f func(ctx context.Context, cloudProvider string, region string)) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrgPrivateEndpointConfig")
	}

	mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig = f

	return mmGetOrgPrivateEndpointConfig
}

// Return sets up results that will be returned by Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Return(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{mock: mmGetOrgPrivateEndpointConfig.mock}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return mmGetOrgPrivateEndpointConfig.mock
}

// Set uses given function f to mock the Client.GetOrgPrivateEndpointConfig method
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Set(f func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.defaultExpectation != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Default expectation is already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	if len(mmGetOrgPrivateEndpointConfig.expectations) > 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Some expectations are already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig = f
	return mmGetOrgPrivateEndpointConfig.mock
}

// When sets expectation for the Client.GetOrgPrivateEndpointConfig which will trigger the result defined by the following
// Then helper
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) When(ctx context.Context, cloudProvider string, region string) *ClientMockGetOrgPrivateEndpointConfigExpectation {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	expectation := &ClientMockGetOrgPrivateEndpointConfigExpectation{
		mock:   mmGetOrgPrivateEndpointConfig.mock,
		params: &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region},
	}
	mmGetOrgPrivateEndpointConfig.expectations = append(mmGetOrgPrivateEndpointConfig.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrgPrivateEndpointConfig return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrgPrivateEndpointConfigExpectation) Then(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	e.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return e.mock
}

// Times sets number of times Client.GetOrgPrivateEndpointConfig should be invoked
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Times(n uint64) *mClientMockGetOrgPrivateEndpointConfig {
	if n == 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Times of ClientMock.GetOrgPrivateEndpointConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations, n)
	return mmGetOrgPrivateEndpointConfig
}

func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) invocationsDone() bool {
	if len(mmGetOrgPrivateEndpointConfig.expectations) == 0 && mmGetOrgPrivateEndpointConfig.defaultExpectation == nil && mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.mock.afterGetOrgPrivateEndpointConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrgPrivateEndpointConfig implements Client
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfig(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error) {
	mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter, 1)

	if mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}

	mm_params := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

	// Record call args
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Lock()
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs = append(mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs, &mm_params)
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Unlock()

	for _, e := range mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cloudProvider != nil && !minimock.Equal(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter cloudProvider, want: %#v, got: %#v%s\n", *mm_want_ptrs.cloudProvider, mm_got.cloudProvider, minimock.Diff(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider))
			}

			if mm_want_ptrs.region != nil && !minimock.Equal(*mm_want_ptrs.region, mm_got.region) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter region, want: %#v, got: %#v%s\n", *mm_want_ptrs.region, mm_got.region, minimock.Diff(*mm_want_ptrs.region, mm_got.region))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrgPrivateEndpointConfig.t.Fatal("No results are set for the ClientMock.GetOrgPrivateEndpointConfig")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig != nil {
		return mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}
	mmGetOrgPrivateEndpointConfig.t.Fatalf("Unexpected call to ClientMock.GetOrgPrivateEndpointConfig. %v %v %v", ctx, cloudProvider, region)
	return
}

// GetOrgPrivateEndpointConfigAfterCounter returns a count of finished ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter)
}

// GetOrgPrivateEndpointConfigBeforeCounter returns a count of ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrgPrivateEndpointConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Calls() []*ClientMockGetOrgPrivateEndpointConfigParams {
	mmGetOrgPrivateEndpointConfig.mutex.RLock()

	argCopy := make([]*ClientMockGetOrgPrivateEndpointConfigParams, len(mmGetOrgPrivateEndpointConfig.callArgs))
	copy(argCopy, mmGetOrgPrivateEndpointConfig.callArgs)

	mmGetOrgPrivateEndpointConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrgPrivateEndpointConfigDone returns true if the count of the GetOrgPrivateEndpointConfig invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigDone() bool {
	if m.GetOrgPrivateEndpointConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrgPrivateEndpointConfigMock.invocationsDone()
}

// MinimockGetOrgPrivateEndpointConfigInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigInspect() {
	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig with params: %#v", *e.params)
		}
	}

	afterGetOrgPrivateEndpointConfigCounter := mm_atomic.LoadUint64(&m.afterGetOrgPrivateEndpointConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		if m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetOrgPrivateEndpointConfig")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig with params: %#v", *m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrgPrivateEndpointConfig != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetOrgPrivateEndpointConfig")
	}

	if !m.GetOrgPrivateEndpointConfigMock.invocationsDone() && afterGetOrgPrivateEndpointConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrgPrivateEndpointConfig but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrgPrivateEndpointConfigMock.expectedInvocations), afterGetOrgPrivateEndpointConfigCounter)
	}
}

type mClientMockGetOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockGetOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockGetOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetOrganizationPrivateEndpointsParams
	paramPtrs *ClientMockGetOrganizationPrivateEndpointsParamPtrs
	results   *ClientMockGetOrganizationPrivateEndpointsResults
	Counter   uint64
}

// ClientMockGetOrganizationPrivateEndpointsParams contains parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParams struct {
	ctx context.Context
}

// ClientMockGetOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParamPtrs struct {
	ctx *context.Context
}

// ClientMockGetOrganizationPrivateEndpointsResults contains results of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Optional() *mClientMockGetOrganizationPrivateEndpoints {
	mmGetOrganizationPrivateEndpoints.optional = true
	return mmGetOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Expect(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmGetOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockGetOrganizationPrivateEndpointsParams{ctx}
	for _, e := range mmGetOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmGetOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmGetOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockGetOrganizationPrivateEndpointsParamPtrs{}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context)) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrganizationPrivateEndpoints")
	}

	mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints = f

	return mmGetOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{mock: mmGetOrganizationPrivateEndpoints.mock}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return mmGetOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.GetOrganizationPrivateEndpoints method
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Set(f func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	if len(mmGetOrganizationPrivateEndpoints.expectations) > 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints = f
	return mmGetOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.GetOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) When(ctx context.Context) *ClientMockGetOrganizationPrivateEndpointsExpectation {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockGetOrganizationPrivateEndpointsExpectation{
		mock:   mmGetOrganizationPrivateEndpoints.mock,
		params: &ClientMockGetOrganizationPrivateEndpointsParams{ctx},
	}
	mmGetOrganizationPrivateEndpoints.expectations = append(mmGetOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.GetOrganizationPrivateEndpoints should be invoked
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Times(n uint64) *mClientMockGetOrganizationPrivateEndpoints {
	if n == 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.GetOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations, n)
	return mmGetOrganizationPrivateEndpoints
}

func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmGetOrganizationPrivateEndpoints.expectations) == 0 && mmGetOrganizationPrivateEndpoints.defaultExpectation == nil && mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.mock.afterGetOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationPrivateEndpoints implements Client
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpoints(ctx context.Context) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter, 1)

	if mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints(ctx)
	}

	mm_params := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

	// Record call args
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Lock()
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs = append(mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.GetOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints != nil {
		return mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints(ctx)
	}
	mmGetOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.GetOrganizationPrivateEndpoints. %v", ctx)
	return
}

// GetOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter)
}

// GetOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Calls() []*ClientMockGetOrganizationPrivateEndpointsParams {
	mmGetOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockGetOrganizationPrivateEndpointsParams, len(mmGetOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmGetOrganizationPrivateEndpoints.callArgs)

	mmGetOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationPrivateEndpointsDone returns true if the count of the GetOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsDone() bool {
	if m.GetOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockGetOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsInspect() {
	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterGetOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		if m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetOrganizationPrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints with params: %#v", *m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationPrivateEndpoints != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetOrganizationPrivateEndpoints")
	}

	if !m.GetOrganizationPrivateEndpointsMock.invocationsDone() && afterGetOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrganizationPrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationPrivateEndpointsMock.expectedInvocations), afterGetOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockGetQueryEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetQueryEndpointExpectation
	expectations       []*ClientMockGetQueryEndpointExpectation

	callArgs []*ClientMockGetQueryEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetQueryEndpointExpectation specifies expectation struct of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetQueryEndpointParams
	paramPtrs *ClientMockGetQueryEndpointParamPtrs
	results   *ClientMockGetQueryEndpointResults
	Counter   uint64
}

// ClientMockGetQueryEndpointParams contains parameters of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointParams struct {
	ctx       context.Context
	serviceID string
}

// ClientMockGetQueryEndpointParamPtrs contains pointers to parameters of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointParamPtrs struct {
	ctx       *context.Context
	serviceID *string
}

// ClientMockGetQueryEndpointResults contains results of the Client.GetQueryEndpoint
type ClientMockGetQueryEndpointResults struct {
	sp1 *ServiceQueryEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Optional() *mClientMockGetQueryEndpoint {
	mmGetQueryEndpoint.optional = true
	return mmGetQueryEndpoint
}

// Expect sets up expected params for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Expect(ctx context.Context, serviceID string) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by ExpectParams functions")
	}

	mmGetQueryEndpoint.defaultExpectation.params = &ClientMockGetQueryEndpointParams{ctx, serviceID}
	for _, e := range mmGetQueryEndpoint.expectations {
		if minimock.Equal(e.params, mmGetQueryEndpoint.defaultExpectation.params) {
			mmGetQueryEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetQueryEndpoint.defaultExpectation.params)
		}
	}

	return mmGetQueryEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.params != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Expect")
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockGetQueryEndpointParamPtrs{}
	}
	mmGetQueryEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetQueryEndpoint
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) ExpectServiceIDParam2(serviceID string) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{}
	}

	if mmGetQueryEndpoint.defaultExpectation.params != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Expect")
	}

	if mmGetQueryEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetQueryEndpoint.defaultExpectation.paramPtrs = &ClientMockGetQueryEndpointParamPtrs{}
	}
	mmGetQueryEndpoint.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetQueryEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Inspect(f func(ctx context.Context, serviceID string)) *mClientMockGetQueryEndpoint {
	if mmGetQueryEndpoint.mock.inspectFuncGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.GetQueryEndpoint")
	}

	mmGetQueryEndpoint.mock.inspectFuncGetQueryEndpoint = f

	return mmGetQueryEndpoint
}

// Return sets up results that will be returned by Client.GetQueryEndpoint
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Return(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	if mmGetQueryEndpoint.defaultExpectation == nil {
		mmGetQueryEndpoint.defaultExpectation = &ClientMockGetQueryEndpointExpectation{mock: mmGetQueryEndpoint.mock}
	}
	mmGetQueryEndpoint.defaultExpectation.results = &ClientMockGetQueryEndpointResults{sp1, err}
	return mmGetQueryEndpoint.mock
}

// Set uses given function f to mock the Client.GetQueryEndpoint method
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Set(f func(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error)) *ClientMock {
	if mmGetQueryEndpoint.defaultExpectation != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.GetQueryEndpoint method")
	}

	if len(mmGetQueryEndpoint.expectations) > 0 {
		mmGetQueryEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.GetQueryEndpoint method")
	}

	mmGetQueryEndpoint.mock.funcGetQueryEndpoint = f
	return mmGetQueryEndpoint.mock
}

// When sets expectation for the Client.GetQueryEndpoint which will trigger the result defined by the following
// Then helper
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) When(ctx context.Context, serviceID string) *ClientMockGetQueryEndpointExpectation {
	if mmGetQueryEndpoint.mock.funcGetQueryEndpoint != nil {
		mmGetQueryEndpoint.mock.t.Fatalf("ClientMock.GetQueryEndpoint mock is already set by Set")
	}

	expectation := &ClientMockGetQueryEndpointExpectation{
		mock:   mmGetQueryEndpoint.mock,
		params: &ClientMockGetQueryEndpointParams{ctx, serviceID},
	}
	mmGetQueryEndpoint.expectations = append(mmGetQueryEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.GetQueryEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockGetQueryEndpointExpectation) Then(sp1 *ServiceQueryEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetQueryEndpointResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetQueryEndpoint should be invoked
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Times(n uint64) *mClientMockGetQueryEndpoint {
	if n == 0 {
		mmGetQueryEndpoint.mock.t.Fatalf("Times of ClientMock.GetQueryEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetQueryEndpoint.expectedInvocations, n)
	return mmGetQueryEndpoint
}

func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) invocationsDone() bool {
	if len(mmGetQueryEndpoint.expectations) == 0 && mmGetQueryEndpoint.defaultExpectation == nil && mmGetQueryEndpoint.mock.funcGetQueryEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetQueryEndpoint.mock.afterGetQueryEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetQueryEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetQueryEndpoint implements Client
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpoint(ctx context.Context, serviceID string) (sp1 *ServiceQueryEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetQueryEndpoint.beforeGetQueryEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmGetQueryEndpoint.afterGetQueryEndpointCounter, 1)

	if mmGetQueryEndpoint.inspectFuncGetQueryEndpoint != nil {
		mmGetQueryEndpoint.inspectFuncGetQueryEndpoint(ctx, serviceID)
	}

	mm_params := ClientMockGetQueryEndpointParams{ctx, serviceID}

	// Record call args
	mmGetQueryEndpoint.GetQueryEndpointMock.mutex.Lock()
	mmGetQueryEndpoint.GetQueryEndpointMock.callArgs = append(mmGetQueryEndpoint.GetQueryEndpointMock.callArgs, &mm_params)
	mmGetQueryEndpoint.GetQueryEndpointMock.mutex.Unlock()

	for _, e := range mmGetQueryEndpoint.GetQueryEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetQueryEndpointParams{ctx, serviceID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetQueryEndpoint.t.Errorf("ClientMock.GetQueryEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetQueryEndpoint.GetQueryEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmGetQueryEndpoint.t.Fatal("No results are set for the ClientMock.GetQueryEndpoint")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetQueryEndpoint.funcGetQueryEndpoint != nil {
		return mmGetQueryEndpoint.funcGetQueryEndpoint(ctx, serviceID)
	}
	mmGetQueryEndpoint.t.Fatalf("Unexpected call to ClientMock.GetQueryEndpoint. %v %v", ctx, serviceID)
	return
}

// GetQueryEndpointAfterCounter returns a count of finished ClientMock.GetQueryEndpoint invocations
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQueryEndpoint.afterGetQueryEndpointCounter)
}

// GetQueryEndpointBeforeCounter returns a count of ClientMock.GetQueryEndpoint invocations
func (mmGetQueryEndpoint *ClientMock) GetQueryEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQueryEndpoint.beforeGetQueryEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetQueryEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetQueryEndpoint *mClientMockGetQueryEndpoint) Calls() []*ClientMockGetQueryEndpointParams {
	mmGetQueryEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockGetQueryEndpointParams, len(mmGetQueryEndpoint.callArgs))
	copy(argCopy, mmGetQueryEndpoint.callArgs)

	mmGetQueryEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockGetQueryEndpointDone returns true if the count of the GetQueryEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetQueryEndpointDone() bool {
	if m.GetQueryEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetQueryEndpointMock.invocationsDone()
}

// MinimockGetQueryEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockGetQueryEndpointInspect() {
	for _, e := range m.GetQueryEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint with params: %#v", *e.params)
		}
	}

	afterGetQueryEndpointCounter := mm_atomic.LoadUint64(&m.afterGetQueryEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetQueryEndpointMock.defaultExpectation != nil && afterGetQueryEndpointCounter < 1 {
		if m.GetQueryEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetQueryEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetQueryEndpoint with params: %#v", *m.GetQueryEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQueryEndpoint != nil && afterGetQueryEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetQueryEndpoint")
	}

	if !m.GetQueryEndpointMock.invocationsDone() && afterGetQueryEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetQueryEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.GetQueryEndpointMock.expectedInvocations), afterGetQueryEndpointCounter)
	}
}

type mClientMockGetReversePrivateEndpoint struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetReversePrivateEndpointExpectation
	expectations       []*ClientMockGetReversePrivateEndpointExpectation

	callArgs []*ClientMockGetReversePrivateEndpointParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetReversePrivateEndpointExpectation specifies expectation struct of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetReversePrivateEndpointParams
	paramPtrs *ClientMockGetReversePrivateEndpointParamPtrs
	results   *ClientMockGetReversePrivateEndpointResults
	Counter   uint64
}

// ClientMockGetReversePrivateEndpointParams contains parameters of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointParams struct {
	ctx                      context.Context
	serviceId                string
	reversePrivateEndpointId string
}

// ClientMockGetReversePrivateEndpointParamPtrs contains pointers to parameters of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointParamPtrs struct {
	ctx                      *context.Context
	serviceId                *string
	reversePrivateEndpointId *string
}

// ClientMockGetReversePrivateEndpointResults contains results of the Client.GetReversePrivateEndpoint
type ClientMockGetReversePrivateEndpointResults struct {
	rp1 *ReversePrivateEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Optional() *mClientMockGetReversePrivateEndpoint {
	mmGetReversePrivateEndpoint.optional = true
	return mmGetReversePrivateEndpoint
}

// Expect sets up expected params for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Expect(ctx context.Context, serviceId string, reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by ExpectParams functions")
	}

	mmGetReversePrivateEndpoint.defaultExpectation.params = &ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}
	for _, e := range mmGetReversePrivateEndpoint.expectations {
		if minimock.Equal(e.params, mmGetReversePrivateEndpoint.defaultExpectation.params) {
			mmGetReversePrivateEndpoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReversePrivateEndpoint.defaultExpectation.params)
		}
	}

	return mmGetReversePrivateEndpoint
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) ExpectCtxParam1(ctx context.Context) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.params != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Expect")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointParamPtrs{}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetReversePrivateEndpoint
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) ExpectServiceIdParam2(serviceId string) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.params != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Expect")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointParamPtrs{}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetReversePrivateEndpoint
}

// ExpectReversePrivateEndpointIdParam3 sets up expected param reversePrivateEndpointId for Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) ExpectReversePrivateEndpointIdParam3(reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{}
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.params != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Expect")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointParamPtrs{}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId

	return mmGetReversePrivateEndpoint
}

// Inspect accepts an inspector function that has same arguments as the Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Inspect(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string)) *mClientMockGetReversePrivateEndpoint {
	if mmGetReversePrivateEndpoint.mock.inspectFuncGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Inspect function is already set for ClientMock.GetReversePrivateEndpoint")
	}

	mmGetReversePrivateEndpoint.mock.inspectFuncGetReversePrivateEndpoint = f

	return mmGetReversePrivateEndpoint
}

// Return sets up results that will be returned by Client.GetReversePrivateEndpoint
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Return(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	if mmGetReversePrivateEndpoint.defaultExpectation == nil {
		mmGetReversePrivateEndpoint.defaultExpectation = &ClientMockGetReversePrivateEndpointExpectation{mock: mmGetReversePrivateEndpoint.mock}
	}
	mmGetReversePrivateEndpoint.defaultExpectation.results = &ClientMockGetReversePrivateEndpointResults{rp1, err}
	return mmGetReversePrivateEndpoint.mock
}

// Set uses given function f to mock the Client.GetReversePrivateEndpoint method
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Set(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string) (rp1 *ReversePrivateEndpoint, err error)) *ClientMock {
	if mmGetReversePrivateEndpoint.defaultExpectation != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Default expectation is already set for the Client.GetReversePrivateEndpoint method")
	}

	if len(mmGetReversePrivateEndpoint.expectations) > 0 {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Some expectations are already set for the Client.GetReversePrivateEndpoint method")
	}

	mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint = f
	return mmGetReversePrivateEndpoint.mock
}

// When sets expectation for the Client.GetReversePrivateEndpoint which will trigger the result defined by the following
// Then helper
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) When(ctx context.Context, serviceId string, reversePrivateEndpointId string) *ClientMockGetReversePrivateEndpointExpectation {
	if mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("ClientMock.GetReversePrivateEndpoint mock is already set by Set")
	}

	expectation := &ClientMockGetReversePrivateEndpointExpectation{
		mock:   mmGetReversePrivateEndpoint.mock,
		params: &ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId},
	}
	mmGetReversePrivateEndpoint.expectations = append(mmGetReversePrivateEndpoint.expectations, expectation)
	return expectation
}

// Then sets up Client.GetReversePrivateEndpoint return parameters for the expectation previously defined by the When method
func (e *ClientMockGetReversePrivateEndpointExpectation) Then(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetReversePrivateEndpointResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.GetReversePrivateEndpoint should be invoked
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Times(n uint64) *mClientMockGetReversePrivateEndpoint {
	if n == 0 {
		mmGetReversePrivateEndpoint.mock.t.Fatalf("Times of ClientMock.GetReversePrivateEndpoint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReversePrivateEndpoint.expectedInvocations, n)
	return mmGetReversePrivateEndpoint
}

func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) invocationsDone() bool {
	if len(mmGetReversePrivateEndpoint.expectations) == 0 && mmGetReversePrivateEndpoint.defaultExpectation == nil && mmGetReversePrivateEndpoint.mock.funcGetReversePrivateEndpoint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.mock.afterGetReversePrivateEndpointCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReversePrivateEndpoint implements Client
func (mmGetReversePrivateEndpoint *ClientMock) GetReversePrivateEndpoint(ctx context.Context, serviceId string, reversePrivateEndpointId string) (rp1 *ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetReversePrivateEndpoint.beforeGetReversePrivateEndpointCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReversePrivateEndpoint.afterGetReversePrivateEndpointCounter, 1)

	if mmGetReversePrivateEndpoint.inspectFuncGetReversePrivateEndpoint != nil {
		mmGetReversePrivateEndpoint.inspectFuncGetReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}

	mm_params := ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

	// Record call args
	mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.mutex.Lock()
	mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.callArgs = append(mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.callArgs, &mm_params)
	mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.mutex.Unlock()

	for _, e := range mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.params
		mm_want_ptrs := mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetReversePrivateEndpointParams{ctx, serviceId, reversePrivateEndpointId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameter reversePrivateEndpointId, want: %#v, got: %#v%s\n", *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReversePrivateEndpoint.t.Errorf("ClientMock.GetReversePrivateEndpoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReversePrivateEndpoint.GetReversePrivateEndpointMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReversePrivateEndpoint.t.Fatal("No results are set for the ClientMock.GetReversePrivateEndpoint")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetReversePrivateEndpoint.funcGetReversePrivateEndpoint != nil {
		return mmGetReversePrivateEndpoint.funcGetReversePrivateEndpoint(ctx, serviceId, reversePrivateEndpointId)
	}
	mmGetReversePrivateEndpoint.t.Fatalf("Unexpected call to ClientMock.GetReversePrivateEndpoint. %v %v %v", ctx, serviceId, reversePrivateEndpointId)
	return
}

// GetReversePrivateEndpointAfterCounter returns a count of finished ClientMock.GetReversePrivateEndpoint invocations
func (mmGetReversePrivateEndpoint *ClientMock) GetReversePrivateEndpointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.afterGetReversePrivateEndpointCounter)
}

// GetReversePrivateEndpointBeforeCounter returns a count of ClientMock.GetReversePrivateEndpoint invocations
func (mmGetReversePrivateEndpoint *ClientMock) GetReversePrivateEndpointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpoint.beforeGetReversePrivateEndpointCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetReversePrivateEndpoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReversePrivateEndpoint *mClientMockGetReversePrivateEndpoint) Calls() []*ClientMockGetReversePrivateEndpointParams {
	mmGetReversePrivateEndpoint.mutex.RLock()

	argCopy := make([]*ClientMockGetReversePrivateEndpointParams, len(mmGetReversePrivateEndpoint.callArgs))
	copy(argCopy, mmGetReversePrivateEndpoint.callArgs)

	mmGetReversePrivateEndpoint.mutex.RUnlock()

	return argCopy
}

// MinimockGetReversePrivateEndpointDone returns true if the count of the GetReversePrivateEndpoint invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetReversePrivateEndpointDone() bool {
	if m.GetReversePrivateEndpointMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReversePrivateEndpointMock.invocationsDone()
}

// MinimockGetReversePrivateEndpointInspect logs each unmet expectation
func (m *ClientMock) MinimockGetReversePrivateEndpointInspect() {
	for _, e := range m.GetReversePrivateEndpointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpoint with params: %#v", *e.params)
		}
	}

	afterGetReversePrivateEndpointCounter := mm_atomic.LoadUint64(&m.afterGetReversePrivateEndpointCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReversePrivateEndpointMock.defaultExpectation != nil && afterGetReversePrivateEndpointCounter < 1 {
		if m.GetReversePrivateEndpointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetReversePrivateEndpoint")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpoint with params: %#v", *m.GetReversePrivateEndpointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReversePrivateEndpoint != nil && afterGetReversePrivateEndpointCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetReversePrivateEndpoint")
	}

	if !m.GetReversePrivateEndpointMock.invocationsDone() && afterGetReversePrivateEndpointCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetReversePrivateEndpoint but found %d calls",
			mm_atomic.LoadUint64(&m.GetReversePrivateEndpointMock.expectedInvocations), afterGetReversePrivateEndpointCounter)
	}
}

type mClientMockGetReversePrivateEndpointPath struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetReversePrivateEndpointPathExpectation
	expectations       []*ClientMockGetReversePrivateEndpointPathExpectation

	callArgs []*ClientMockGetReversePrivateEndpointPathParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetReversePrivateEndpointPathExpectation specifies expectation struct of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetReversePrivateEndpointPathParams
	paramPtrs *ClientMockGetReversePrivateEndpointPathParamPtrs
	results   *ClientMockGetReversePrivateEndpointPathResults
	Counter   uint64
}

// ClientMockGetReversePrivateEndpointPathParams contains parameters of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathParams struct {
	serviceId                string
	reversePrivateEndpointId string
}

// ClientMockGetReversePrivateEndpointPathParamPtrs contains pointers to parameters of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathParamPtrs struct {
	serviceId                *string
	reversePrivateEndpointId *string
}

// ClientMockGetReversePrivateEndpointPathResults contains results of the Client.GetReversePrivateEndpointPath
type ClientMockGetReversePrivateEndpointPathResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Optional() *mClientMockGetReversePrivateEndpointPath {
	mmGetReversePrivateEndpointPath.optional = true
	return mmGetReversePrivateEndpointPath
}

// Expect sets up expected params for Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Expect(serviceId string, reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{}
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by ExpectParams functions")
	}

	mmGetReversePrivateEndpointPath.defaultExpectation.params = &ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId}
	for _, e := range mmGetReversePrivateEndpointPath.expectations {
		if minimock.Equal(e.params, mmGetReversePrivateEndpointPath.defaultExpectation.params) {
			mmGetReversePrivateEndpointPath.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReversePrivateEndpointPath.defaultExpectation.params)
		}
	}

	return mmGetReversePrivateEndpointPath
}

// ExpectServiceIdParam1 sets up expected param serviceId for Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) ExpectServiceIdParam1(serviceId string) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{}
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.params != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Expect")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointPathParamPtrs{}
	}
	mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetReversePrivateEndpointPath
}

// ExpectReversePrivateEndpointIdParam2 sets up expected param reversePrivateEndpointId for Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) ExpectReversePrivateEndpointIdParam2(reversePrivateEndpointId string) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{}
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.params != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Expect")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs = &ClientMockGetReversePrivateEndpointPathParamPtrs{}
	}
	mmGetReversePrivateEndpointPath.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId

	return mmGetReversePrivateEndpointPath
}

// Inspect accepts an inspector function that has same arguments as the Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Inspect(f func(serviceId string, reversePrivateEndpointId string)) *mClientMockGetReversePrivateEndpointPath {
	if mmGetReversePrivateEndpointPath.mock.inspectFuncGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Inspect function is already set for ClientMock.GetReversePrivateEndpointPath")
	}

	mmGetReversePrivateEndpointPath.mock.inspectFuncGetReversePrivateEndpointPath = f

	return mmGetReversePrivateEndpointPath
}

// Return sets up results that will be returned by Client.GetReversePrivateEndpointPath
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Return(s1 string) *ClientMock {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	if mmGetReversePrivateEndpointPath.defaultExpectation == nil {
		mmGetReversePrivateEndpointPath.defaultExpectation = &ClientMockGetReversePrivateEndpointPathExpectation{mock: mmGetReversePrivateEndpointPath.mock}
	}
	mmGetReversePrivateEndpointPath.defaultExpectation.results = &ClientMockGetReversePrivateEndpointPathResults{s1}
	return mmGetReversePrivateEndpointPath.mock
}

// Set uses given function f to mock the Client.GetReversePrivateEndpointPath method
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Set(f func(serviceId string, reversePrivateEndpointId string) (s1 string)) *ClientMock {
	if mmGetReversePrivateEndpointPath.defaultExpectation != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Default expectation is already set for the Client.GetReversePrivateEndpointPath method")
	}

	if len(mmGetReversePrivateEndpointPath.expectations) > 0 {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Some expectations are already set for the Client.GetReversePrivateEndpointPath method")
	}

	mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath = f
	return mmGetReversePrivateEndpointPath.mock
}

// When sets expectation for the Client.GetReversePrivateEndpointPath which will trigger the result defined by the following
// Then helper
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) When(serviceId string, reversePrivateEndpointId string) *ClientMockGetReversePrivateEndpointPathExpectation {
	if mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("ClientMock.GetReversePrivateEndpointPath mock is already set by Set")
	}

	expectation := &ClientMockGetReversePrivateEndpointPathExpectation{
		mock:   mmGetReversePrivateEndpointPath.mock,
		params: &ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId},
	}
	mmGetReversePrivateEndpointPath.expectations = append(mmGetReversePrivateEndpointPath.expectations, expectation)
	return expectation
}

// Then sets up Client.GetReversePrivateEndpointPath return parameters for the expectation previously defined by the When method
func (e *ClientMockGetReversePrivateEndpointPathExpectation) Then(s1 string) *ClientMock {
	e.results = &ClientMockGetReversePrivateEndpointPathResults{s1}
	return e.mock
}

// Times sets number of times Client.GetReversePrivateEndpointPath should be invoked
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Times(n uint64) *mClientMockGetReversePrivateEndpointPath {
	if n == 0 {
		mmGetReversePrivateEndpointPath.mock.t.Fatalf("Times of ClientMock.GetReversePrivateEndpointPath mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReversePrivateEndpointPath.expectedInvocations, n)
	return mmGetReversePrivateEndpointPath
}

func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) invocationsDone() bool {
	if len(mmGetReversePrivateEndpointPath.expectations) == 0 && mmGetReversePrivateEndpointPath.defaultExpectation == nil && mmGetReversePrivateEndpointPath.mock.funcGetReversePrivateEndpointPath == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.mock.afterGetReversePrivateEndpointPathCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReversePrivateEndpointPath implements Client
func (mmGetReversePrivateEndpointPath *ClientMock) GetReversePrivateEndpointPath(serviceId string, reversePrivateEndpointId string) (s1 string) {
	mm_atomic.AddUint64(&mmGetReversePrivateEndpointPath.beforeGetReversePrivateEndpointPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReversePrivateEndpointPath.afterGetReversePrivateEndpointPathCounter, 1)

	if mmGetReversePrivateEndpointPath.inspectFuncGetReversePrivateEndpointPath != nil {
		mmGetReversePrivateEndpointPath.inspectFuncGetReversePrivateEndpointPath(serviceId, reversePrivateEndpointId)
	}

	mm_params := ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId}

	// Record call args
	mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.mutex.Lock()
	mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.callArgs = append(mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.callArgs, &mm_params)
	mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.mutex.Unlock()

	for _, e := range mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.params
		mm_want_ptrs := mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetReversePrivateEndpointPathParams{serviceId, reversePrivateEndpointId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetReversePrivateEndpointPath.t.Errorf("ClientMock.GetReversePrivateEndpointPath got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmGetReversePrivateEndpointPath.t.Errorf("ClientMock.GetReversePrivateEndpointPath got unexpected parameter reversePrivateEndpointId, want: %#v, got: %#v%s\n", *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReversePrivateEndpointPath.t.Errorf("ClientMock.GetReversePrivateEndpointPath got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReversePrivateEndpointPath.GetReversePrivateEndpointPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReversePrivateEndpointPath.t.Fatal("No results are set for the ClientMock.GetReversePrivateEndpointPath")
		}
		return (*mm_results).s1
	}
	if mmGetReversePrivateEndpointPath.funcGetReversePrivateEndpointPath != nil {
		return mmGetReversePrivateEndpointPath.funcGetReversePrivateEndpointPath(serviceId, reversePrivateEndpointId)
	}
	mmGetReversePrivateEndpointPath.t.Fatalf("Unexpected call to ClientMock.GetReversePrivateEndpointPath. %v %v", serviceId, reversePrivateEndpointId)
	return
}

// GetReversePrivateEndpointPathAfterCounter returns a count of finished ClientMock.GetReversePrivateEndpointPath invocations
func (mmGetReversePrivateEndpointPath *ClientMock) GetReversePrivateEndpointPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.afterGetReversePrivateEndpointPathCounter)
}

// GetReversePrivateEndpointPathBeforeCounter returns a count of ClientMock.GetReversePrivateEndpointPath invocations
func (mmGetReversePrivateEndpointPath *ClientMock) GetReversePrivateEndpointPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReversePrivateEndpointPath.beforeGetReversePrivateEndpointPathCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetReversePrivateEndpointPath.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReversePrivateEndpointPath *mClientMockGetReversePrivateEndpointPath) Calls() []*ClientMockGetReversePrivateEndpointPathParams {
	mmGetReversePrivateEndpointPath.mutex.RLock()

	argCopy := make([]*ClientMockGetReversePrivateEndpointPathParams, len(mmGetReversePrivateEndpointPath.callArgs))
	copy(argCopy, mmGetReversePrivateEndpointPath.callArgs)

	mmGetReversePrivateEndpointPath.mutex.RUnlock()

	return argCopy
}

// MinimockGetReversePrivateEndpointPathDone returns true if the count of the GetReversePrivateEndpointPath invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetReversePrivateEndpointPathDone() bool {
	if m.GetReversePrivateEndpointPathMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReversePrivateEndpointPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReversePrivateEndpointPathMock.invocationsDone()
}

// MinimockGetReversePrivateEndpointPathInspect logs each unmet expectation
func (m *ClientMock) MinimockGetReversePrivateEndpointPathInspect() {
	for _, e := range m.GetReversePrivateEndpointPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpointPath with params: %#v", *e.params)
		}
	}

	afterGetReversePrivateEndpointPathCounter := mm_atomic.LoadUint64(&m.afterGetReversePrivateEndpointPathCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReversePrivateEndpointPathMock.defaultExpectation != nil && afterGetReversePrivateEndpointPathCounter < 1 {
		if m.GetReversePrivateEndpointPathMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetReversePrivateEndpointPath")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetReversePrivateEndpointPath with params: %#v", *m.GetReversePrivateEndpointPathMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReversePrivateEndpointPath != nil && afterGetReversePrivateEndpointPathCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetReversePrivateEndpointPath")
	}

	if !m.GetReversePrivateEndpointPathMock.invocationsDone() && afterGetReversePrivateEndpointPathCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetReversePrivateEndpointPath but found %d calls",
			mm_atomic.LoadUint64(&m.GetReversePrivateEndpointPathMock.expectedInvocations), afterGetReversePrivateEndpointPathCounter)
	}
}

type mClientMockGetRole struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetRoleExpectation
	expectations       []*ClientMockGetRoleExpectation

	callArgs []*ClientMockGetRoleParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetRoleExpectation specifies expectation struct of the Client.GetRole
type ClientMockGetRoleExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetRoleParams
	paramPtrs *ClientMockGetRoleParamPtrs
	results   *ClientMockGetRoleResults
	Counter   uint64
}

// ClientMockGetRoleParams contains parameters of the Client.GetRole
type ClientMockGetRoleParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockGetRoleParamPtrs contains pointers to parameters of the Client.GetRole
type ClientMockGetRoleParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockGetRoleResults contains results of the Client.GetRole
type ClientMockGetRoleResults struct {
	rp1 *Role
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRole *mClientMockGetRole) Optional() *mClientMockGetRole {
	mmGetRole.optional = true
	return mmGetRole
}

// Expect sets up expected params for Client.GetRole
func (mmGetRole *mClientMockGetRole) Expect(ctx context.Context, serviceID string, name string) *mClientMockGetRole {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &ClientMockGetRoleExpectation{}
	}

	if mmGetRole.defaultExpectation.paramPtrs != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by ExpectParams functions")
	}

	mmGetRole.defaultExpectation.params = &ClientMockGetRoleParams{ctx, serviceID, name}
	for _, e := range mmGetRole.expectations {
		if minimock.Equal(e.params, mmGetRole.defaultExpectation.params) {
			mmGetRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRole.defaultExpectation.params)
		}
	}

	return mmGetRole
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetRole
func (mmGetRole *mClientMockGetRole) ExpectCtxParam1(ctx context.Context) *mClientMockGetRole {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &ClientMockGetRoleExpectation{}
	}

	if mmGetRole.defaultExpectation.params != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Expect")
	}

	if mmGetRole.defaultExpectation.paramPtrs == nil {
		mmGetRole.defaultExpectation.paramPtrs = &ClientMockGetRoleParamPtrs{}
	}
	mmGetRole.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRole
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetRole
func (mmGetRole *mClientMockGetRole) ExpectServiceIDParam2(serviceID string) *mClientMockGetRole {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &ClientMockGetRoleExpectation{}
	}

	if mmGetRole.defaultExpectation.params != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Expect")
	}

	if mmGetRole.defaultExpectation.paramPtrs == nil {
		mmGetRole.defaultExpectation.paramPtrs = &ClientMockGetRoleParamPtrs{}
	}
	mmGetRole.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetRole
}

// ExpectNameParam3 sets up expected param name for Client.GetRole
func (mmGetRole *mClientMockGetRole) ExpectNameParam3(name string) *mClientMockGetRole {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &ClientMockGetRoleExpectation{}
	}

	if mmGetRole.defaultExpectation.params != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Expect")
	}

	if mmGetRole.defaultExpectation.paramPtrs == nil {
		mmGetRole.defaultExpectation.paramPtrs = &ClientMockGetRoleParamPtrs{}
	}
	mmGetRole.defaultExpectation.paramPtrs.name = &name

	return mmGetRole
}

// Inspect accepts an inspector function that has same arguments as the Client.GetRole
func (mmGetRole *mClientMockGetRole) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockGetRole {
	if mmGetRole.mock.inspectFuncGetRole != nil {
		mmGetRole.mock.t.Fatalf("Inspect function is already set for ClientMock.GetRole")
	}

	mmGetRole.mock.inspectFuncGetRole = f

	return mmGetRole
}

// Return sets up results that will be returned by Client.GetRole
func (mmGetRole *mClientMockGetRole) Return(rp1 *Role, err error) *ClientMock {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &ClientMockGetRoleExpectation{mock: mmGetRole.mock}
	}
	mmGetRole.defaultExpectation.results = &ClientMockGetRoleResults{rp1, err}
	return mmGetRole.mock
}

// Set uses given function f to mock the Client.GetRole method
func (mmGetRole *mClientMockGetRole) Set(f func(ctx context.Context, serviceID string, name string) (rp1 *Role, err error)) *ClientMock {
	if mmGetRole.defaultExpectation != nil {
		mmGetRole.mock.t.Fatalf("Default expectation is already set for the Client.GetRole method")
	}

	if len(mmGetRole.expectations) > 0 {
		mmGetRole.mock.t.Fatalf("Some expectations are already set for the Client.GetRole method")
	}

	mmGetRole.mock.funcGetRole = f
	return mmGetRole.mock
}

// When sets expectation for the Client.GetRole which will trigger the result defined by the following
// Then helper
func (mmGetRole *mClientMockGetRole) When(ctx context.Context, serviceID string, name string) *ClientMockGetRoleExpectation {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("ClientMock.GetRole mock is already set by Set")
	}

	expectation := &ClientMockGetRoleExpectation{
		mock:   mmGetRole.mock,
		params: &ClientMockGetRoleParams{ctx, serviceID, name},
	}
	mmGetRole.expectations = append(mmGetRole.expectations, expectation)
	return expectation
}

// Then sets up Client.GetRole return parameters for the expectation previously defined by the When method
func (e *ClientMockGetRoleExpectation) Then(rp1 *Role, err error) *ClientMock {
	e.results = &ClientMockGetRoleResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.GetRole should be invoked
func (mmGetRole *mClientMockGetRole) Times(n uint64) *mClientMockGetRole {
	if n == 0 {
		mmGetRole.mock.t.Fatalf("Times of ClientMock.GetRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRole.expectedInvocations, n)
	return mmGetRole
}

func (mmGetRole *mClientMockGetRole) invocationsDone() bool {
	if len(mmGetRole.expectations) == 0 && mmGetRole.defaultExpectation == nil && mmGetRole.mock.funcGetRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRole.mock.afterGetRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRole implements Client
func (mmGetRole *ClientMock) GetRole(ctx context.Context, serviceID string, name string) (rp1 *Role, err error) {
	mm_atomic.AddUint64(&mmGetRole.beforeGetRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRole.afterGetRoleCounter, 1)

	if mmGetRole.inspectFuncGetRole != nil {
		mmGetRole.inspectFuncGetRole(ctx, serviceID, name)
	}

	mm_params := ClientMockGetRoleParams{ctx, serviceID, name}

	// Record call args
	mmGetRole.GetRoleMock.mutex.Lock()
	mmGetRole.GetRoleMock.callArgs = append(mmGetRole.GetRoleMock.callArgs, &mm_params)
	mmGetRole.GetRoleMock.mutex.Unlock()

	for _, e := range mmGetRole.GetRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRole.GetRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRole.GetRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRole.GetRoleMock.defaultExpectation.params
		mm_want_ptrs := mmGetRole.GetRoleMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetRoleParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRole.t.Errorf("ClientMock.GetRole got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetRole.t.Errorf("ClientMock.GetRole got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetRole.t.Errorf("ClientMock.GetRole got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRole.t.Errorf("ClientMock.GetRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRole.GetRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRole.t.Fatal("No results are set for the ClientMock.GetRole")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRole.funcGetRole != nil {
		return mmGetRole.funcGetRole(ctx, serviceID, name)
	}
	mmGetRole.t.Fatalf("Unexpected call to ClientMock.GetRole. %v %v %v", ctx, serviceID, name)
	return
}

// GetRoleAfterCounter returns a count of finished ClientMock.GetRole invocations
func (mmGetRole *ClientMock) GetRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRole.afterGetRoleCounter)
}

// GetRoleBeforeCounter returns a count of ClientMock.GetRole invocations
func (mmGetRole *ClientMock) GetRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRole.beforeGetRoleCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRole *mClientMockGetRole) Calls() []*ClientMockGetRoleParams {
	mmGetRole.mutex.RLock()

	argCopy := make([]*ClientMockGetRoleParams, len(mmGetRole.callArgs))
	copy(argCopy, mmGetRole.callArgs)

	mmGetRole.mutex.RUnlock()

	return argCopy
}

// MinimockGetRoleDone returns true if the count of the GetRole invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetRoleDone() bool {
	if m.GetRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRoleMock.invocationsDone()
}

// MinimockGetRoleInspect logs each unmet expectation
func (m *ClientMock) MinimockGetRoleInspect() {
	for _, e := range m.GetRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetRole with params: %#v", *e.params)
		}
	}

	afterGetRoleCounter := mm_atomic.LoadUint64(&m.afterGetRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMock.defaultExpectation != nil && afterGetRoleCounter < 1 {
		if m.GetRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetRole")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetRole with params: %#v", *m.GetRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRole != nil && afterGetRoleCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetRole")
	}

	if !m.GetRoleMock.invocationsDone() && afterGetRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetRole but found %d calls",
			mm_atomic.LoadUint64(&m.GetRoleMock.expectedInvocations), afterGetRoleCounter)
	}
}

type mClientMockGetService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetServiceExpectation
	expectations       []*ClientMockGetServiceExpectation

	callArgs []*ClientMockGetServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetServiceExpectation specifies expectation struct of the Client.GetService
type ClientMockGetServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetServiceParams
	paramPtrs *ClientMockGetServiceParamPtrs
	results   *ClientMockGetServiceResults
	Counter   uint64
}

// ClientMockGetServiceParams contains parameters of the Client.GetService
type ClientMockGetServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetServiceParamPtrs contains pointers to parameters of the Client.GetService
type ClientMockGetServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetServiceResults contains results of the Client.GetService
type ClientMockGetServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetService *mClientMockGetService) Optional() *mClientMockGetService {
	mmGetService.optional = true
	return mmGetService
}

// Expect sets up expected params for Client.GetService
func (mmGetService *mClientMockGetService) Expect(ctx context.Context, serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.paramPtrs != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by ExpectParams functions")
	}

	mmGetService.defaultExpectation.params = &ClientMockGetServiceParams{ctx, serviceId}
	for _, e := range mmGetService.expectations {
		if minimock.Equal(e.params, mmGetService.defaultExpectation.params) {
			mmGetService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetService.defaultExpectation.params)
		}
	}

	return mmGetService
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetService
func (mmGetService *mClientMockGetService) ExpectCtxParam1(ctx context.Context) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetService
func (mmGetService *mClientMockGetService) ExpectServiceIdParam2(serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetService
}

// Inspect accepts an inspector function that has same arguments as the Client.GetService
func (mmGetService *mClientMockGetService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetService {
	if mmGetService.mock.inspectFuncGetService != nil {
		mmGetService.mock.t.Fatalf("Inspect function is already set for ClientMock.GetService")
	}

	mmGetService.mock.inspectFuncGetService = f

	return mmGetService
}

// Return sets up results that will be returned by Client.GetService
func (mmGetService *mClientMockGetService) Return(sp1 *Service, err error) *ClientMock {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{mock: mmGetService.mock}
	}
	mmGetService.defaultExpectation.results = &ClientMockGetServiceResults{sp1, err}
	return mmGetService.mock
}

// Set uses given function f to mock the Client.GetService method
func (mmGetService *mClientMockGetService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmGetService.defaultExpectation != nil {
		mmGetService.mock.t.Fatalf("Default expectation is already set for the Client.GetService method")
	}

	if len(mmGetService.expectations) > 0 {
		mmGetService.mock.t.Fatalf("Some expectations are already set for the Client.GetService method")
	}

	mmGetService.mock.funcGetService = f
	return mmGetService.mock
}

// When sets expectation for the Client.GetService which will trigger the result defined by the following
// Then helper
func (mmGetService *mClientMockGetService) When(ctx context.Context, serviceId string) *ClientMockGetServiceExpectation {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	expectation := &ClientMockGetServiceExpectation{
		mock:   mmGetService.mock,
		params: &ClientMockGetServiceParams{ctx, serviceId},
	}
	mmGetService.expectations = append(mmGetService.expectations, expectation)
	return expectation
}

// Then sets up Client.GetService return parameters for the expectation previously defined by the When method
func (e *ClientMockGetServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockGetServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetService should be invoked
func (mmGetService *mClientMockGetService) Times(n uint64) *mClientMockGetService {
	if n == 0 {
		mmGetService.mock.t.Fatalf("Times of ClientMock.GetService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetService.expectedInvocations, n)
	return mmGetService
}

func (mmGetService *mClientMockGetService) invocationsDone() bool {
	if len(mmGetService.expectations) == 0 && mmGetService.defaultExpectation == nil && mmGetService.mock.funcGetService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetService.mock.afterGetServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetService implements Client
func (mmGetService *ClientMock) GetService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmGetService.beforeGetServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetService.afterGetServiceCounter, 1)

	if mmGetService.inspectFuncGetService != nil {
		mmGetService.inspectFuncGetService(ctx, serviceId)
	}

	mm_params := ClientMockGetServiceParams{ctx, serviceId}

	// Record call args
	mmGetService.GetServiceMock.mutex.Lock()
	mmGetService.GetServiceMock.callArgs = append(mmGetService.GetServiceMock.callArgs, &mm_params)
	mmGetService.GetServiceMock.mutex.Unlock()

	for _, e := range mmGetService.GetServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetService.GetServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetService.GetServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetService.GetServiceMock.defaultExpectation.params
		mm_want_ptrs := mmGetService.GetServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetService.t.Errorf("ClientMock.GetService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetService.GetServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetService.t.Fatal("No results are set for the ClientMock.GetService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetService.funcGetService != nil {
		return mmGetService.funcGetService(ctx, serviceId)
	}
	mmGetService.t.Fatalf("Unexpected call to ClientMock.GetService. %v %v", ctx, serviceId)
	return
}

// GetServiceAfterCounter returns a count of finished ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.afterGetServiceCounter)
}

// GetServiceBeforeCounter returns a count of ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.beforeGetServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetService *mClientMockGetService) Calls() []*ClientMockGetServiceParams {
	mmGetService.mutex.RLock()

	argCopy := make([]*ClientMockGetServiceParams, len(mmGetService.callArgs))
	copy(argCopy, mmGetService.callArgs)

	mmGetService.mutex.RUnlock()

	return argCopy
}

// MinimockGetServiceDone returns true if the count of the GetService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetServiceDone() bool {
	if m.GetServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetServiceMock.invocationsDone()
}

// MinimockGetServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockGetServiceInspect() {
	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetService with params: %#v", *e.params)
		}
	}

	afterGetServiceCounter := mm_atomic.LoadUint64(&m.afterGetServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetServiceMock.defaultExpectation != nil && afterGetServiceCounter < 1 {
		if m.GetServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetService")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetService with params: %#v", *m.GetServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetService != nil && afterGetServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetService")
	}

	if !m.GetServiceMock.invocationsDone() && afterGetServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetService but found %d calls",
			mm_atomic.LoadUint64(&m.GetServiceMock.expectedInvocations), afterGetServiceCounter)
	}
}

type mClientMockGetUser struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetUserExpectation
	expectations       []*ClientMockGetUserExpectation

	callArgs []*ClientMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetUserExpectation specifies expectation struct of the Client.GetUser
type ClientMockGetUserExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetUserParams
	paramPtrs *ClientMockGetUserParamPtrs
	results   *ClientMockGetUserResults
	Counter   uint64
}

// ClientMockGetUserParams contains parameters of the Client.GetUser
type ClientMockGetUserParams struct {
	ctx       context.Context
	serviceID string
	name      string
}

// ClientMockGetUserParamPtrs contains pointers to parameters of the Client.GetUser
type ClientMockGetUserParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	name      *string
}

// ClientMockGetUserResults contains results of the Client.GetUser
type ClientMockGetUserResults struct {
	up1 *User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mClientMockGetUser) Optional() *mClientMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Client.GetUser
func (mmGetUser *mClientMockGetUser) Expect(ctx context.Context, serviceID string, name string) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &ClientMockGetUserParams{ctx, serviceID, name}
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetUser
func (mmGetUser *mClientMockGetUser) ExpectCtxParam1(ctx context.Context) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ClientMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetUser
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.GetUser
func (mmGetUser *mClientMockGetUser) ExpectServiceIDParam2(serviceID string) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ClientMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmGetUser
}

// ExpectNameParam3 sets up expected param name for Client.GetUser
func (mmGetUser *mClientMockGetUser) ExpectNameParam3(name string) *mClientMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ClientMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.name = &name

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Client.GetUser
func (mmGetUser *mClientMockGetUser) Inspect(f func(ctx context.Context, serviceID string, name string)) *mClientMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for ClientMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Client.GetUser
func (mmGetUser *mClientMockGetUser) Return(up1 *User, err error) *ClientMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ClientMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &ClientMockGetUserResults{up1, err}
	return mmGetUser.mock
}

// Set uses given function f to mock the Client.GetUser method
func (mmGetUser *mClientMockGetUser) Set(f func(ctx context.Context, serviceID string, name string) (up1 *User, err error)) *ClientMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Client.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Client.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// When sets expectation for the Client.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mClientMockGetUser) When(ctx context.Context, serviceID string, name string) *ClientMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ClientMock.GetUser mock is already set by Set")
	}

	expectation := &ClientMockGetUserExpectation{
		mock:   mmGetUser.mock,
		params: &ClientMockGetUserParams{ctx, serviceID, name},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Client.GetUser return parameters for the expectation previously defined by the When method
func (e *ClientMockGetUserExpectation) Then(up1 *User, err error) *ClientMock {
	e.results = &ClientMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times Client.GetUser should be invoked
func (mmGetUser *mClientMockGetUser) Times(n uint64) *mClientMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of ClientMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	return mmGetUser
}

func (mmGetUser *mClientMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements Client
func (mmGetUser *ClientMock) GetUser(ctx context.Context, serviceID string, name string) (up1 *User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, serviceID, name)
	}

	mm_params := ClientMockGetUserParams{ctx, serviceID, name}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetUserParams{ctx, serviceID, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("ClientMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the ClientMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, serviceID, name)
	}
	mmGetUser.t.Fatalf("Unexpected call to ClientMock.GetUser. %v %v %v", ctx, serviceID, name)
	return
}

// GetUserAfterCounter returns a count of finished ClientMock.GetUser invocations
func (mmGetUser *ClientMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of ClientMock.GetUser invocations
func (mmGetUser *ClientMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mClientMockGetUser) Calls() []*ClientMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*ClientMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *ClientMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetUser with params: %#v", *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetUser")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetUser")
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetUser but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), afterGetUserCounter)
	}
}

type mClientMockGrantPrivilege struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGrantPrivilegeExpectation
	expectations       []*ClientMockGrantPrivilegeExpectation

	callArgs []*ClientMockGrantPrivilegeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGrantPrivilegeExpectation specifies expectation struct of the Client.GrantPrivilege
type ClientMockGrantPrivilegeExpectation struct {
	mock      *ClientMock
	params    *ClientMockGrantPrivilegeParams
	paramPtrs *ClientMockGrantPrivilegeParamPtrs
	results   *ClientMockGrantPrivilegeResults
	Counter   uint64
}

// ClientMockGrantPrivilegeParams contains parameters of the Client.GrantPrivilege
type ClientMockGrantPrivilegeParams struct {
	ctx            context.Context
	serviceId      string
	grantPrivilege GrantPrivilege
}

// ClientMockGrantPrivilegeParamPtrs contains pointers to parameters of the Client.GrantPrivilege
type ClientMockGrantPrivilegeParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	grantPrivilege *GrantPrivilege
}

// ClientMockGrantPrivilegeResults contains results of the Client.GrantPrivilege
type ClientMockGrantPrivilegeResults struct {
	gp1 *GrantPrivilege
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrantPrivilege *mClientMockGrantPrivilege) Optional() *mClientMockGrantPrivilege {
	mmGrantPrivilege.optional = true
	return mmGrantPrivilege
}

// Expect sets up expected params for Client.GrantPrivilege
func (mmGrantPrivilege *mClientMockGrantPrivilege) Expect(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege) *mClientMockGrantPrivilege {
	if mmGrantPrivilege.mock.funcGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Set")
	}

	if mmGrantPrivilege.defaultExpectation == nil {
		mmGrantPrivilege.defaultExpectation = &ClientMockGrantPrivilegeExpectation{}
	}

	if mmGrantPrivilege.defaultExpectation.paramPtrs != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by ExpectParams functions")
	}

	mmGrantPrivilege.defaultExpectation.params = &ClientMockGrantPrivilegeParams{ctx, serviceId, grantPrivilege}
	for _, e := range mmGrantPrivilege.expectations {
		if minimock.Equal(e.params, mmGrantPrivilege.defaultExpectation.params) {
			mmGrantPrivilege.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGrantPrivilege.defaultExpectation.params)
		}
	}

	return mmGrantPrivilege
}

// ExpectCtxParam1 sets up expected param ctx for Client.GrantPrivilege
func (mmGrantPrivilege *mClientMockGrantPrivilege) ExpectCtxParam1(ctx context.Context) *mClientMockGrantPrivilege {
	if mmGrantPrivilege.mock.funcGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Set")
	}

	if mmGrantPrivilege.defaultExpectation == nil {
		mmGrantPrivilege.defaultExpectation = &ClientMockGrantPrivilegeExpectation{}
	}

	if mmGrantPrivilege.defaultExpectation.params != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Expect")
	}

	if mmGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGrantPrivilegeParamPtrs{}
	}
	mmGrantPrivilege.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGrantPrivilege
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GrantPrivilege
func (mmGrantPrivilege *mClientMockGrantPrivilege) ExpectServiceIdParam2(serviceId string) *mClientMockGrantPrivilege {
	if mmGrantPrivilege.mock.funcGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Set")
	}

	if mmGrantPrivilege.defaultExpectation == nil {
		mmGrantPrivilege.defaultExpectation = &ClientMockGrantPrivilegeExpectation{}
	}

	if mmGrantPrivilege.defaultExpectation.params != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Expect")
	}

	if mmGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGrantPrivilegeParamPtrs{}
	}
	mmGrantPrivilege.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGrantPrivilege
}

// ExpectGrantPrivilegeParam3 sets up expected param grantPrivilege for Client.GrantPrivilege
func (mmGrantPrivilege *mClientMockGrantPrivilege) ExpectGrantPrivilegeParam3(grantPrivilege GrantPrivilege) *mClientMockGrantPrivilege {
	if mmGrantPrivilege.mock.funcGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Set")
	}

	if mmGrantPrivilege.defaultExpectation == nil {
		mmGrantPrivilege.defaultExpectation = &ClientMockGrantPrivilegeExpectation{}
	}

	if mmGrantPrivilege.defaultExpectation.params != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Expect")
	}

	if mmGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockGrantPrivilegeParamPtrs{}
	}
	mmGrantPrivilege.defaultExpectation.paramPtrs.grantPrivilege = &grantPrivilege

	return mmGrantPrivilege
}

// Inspect accepts an inspector function that has same arguments as the Client.GrantPrivilege
func (mmGrantPrivilege *mClientMockGrantPrivilege) Inspect(f func(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege)) *mClientMockGrantPrivilege {
	if mmGrantPrivilege.mock.inspectFuncGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("Inspect function is already set for ClientMock.GrantPrivilege")
	}

	mmGrantPrivilege.mock.inspectFuncGrantPrivilege = f

	return mmGrantPrivilege
}

// Return sets up results that will be returned by Client.GrantPrivilege
func (mmGrantPrivilege *mClientMockGrantPrivilege) Return(gp1 *GrantPrivilege, err error) *ClientMock {
	if mmGrantPrivilege.mock.funcGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Set")
	}

	if mmGrantPrivilege.defaultExpectation == nil {
		mmGrantPrivilege.defaultExpectation = &ClientMockGrantPrivilegeExpectation{mock: mmGrantPrivilege.mock}
	}
	mmGrantPrivilege.defaultExpectation.results = &ClientMockGrantPrivilegeResults{gp1, err}
	return mmGrantPrivilege.mock
}

// Set uses given function f to mock the Client.GrantPrivilege method
func (mmGrantPrivilege *mClientMockGrantPrivilege) Set(f func(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege) (gp1 *GrantPrivilege, err error)) *ClientMock {
	if mmGrantPrivilege.defaultExpectation != nil {
		mmGrantPrivilege.mock.t.Fatalf("Default expectation is already set for the Client.GrantPrivilege method")
	}

	if len(mmGrantPrivilege.expectations) > 0 {
		mmGrantPrivilege.mock.t.Fatalf("Some expectations are already set for the Client.GrantPrivilege method")
	}

	mmGrantPrivilege.mock.funcGrantPrivilege = f
	return mmGrantPrivilege.mock
}

// When sets expectation for the Client.GrantPrivilege which will trigger the result defined by the following
// Then helper
func (mmGrantPrivilege *mClientMockGrantPrivilege) When(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege) *ClientMockGrantPrivilegeExpectation {
	if mmGrantPrivilege.mock.funcGrantPrivilege != nil {
		mmGrantPrivilege.mock.t.Fatalf("ClientMock.GrantPrivilege mock is already set by Set")
	}

	expectation := &ClientMockGrantPrivilegeExpectation{
		mock:   mmGrantPrivilege.mock,
		params: &ClientMockGrantPrivilegeParams{ctx, serviceId, grantPrivilege},
	}
	mmGrantPrivilege.expectations = append(mmGrantPrivilege.expectations, expectation)
	return expectation
}

// Then sets up Client.GrantPrivilege return parameters for the expectation previously defined by the When method
func (e *ClientMockGrantPrivilegeExpectation) Then(gp1 *GrantPrivilege, err error) *ClientMock {
	e.results = &ClientMockGrantPrivilegeResults{gp1, err}
	return e.mock
}

// Times sets number of times Client.GrantPrivilege should be invoked
func (mmGrantPrivilege *mClientMockGrantPrivilege) Times(n uint64) *mClientMockGrantPrivilege {
	if n == 0 {
		mmGrantPrivilege.mock.t.Fatalf("Times of ClientMock.GrantPrivilege mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrantPrivilege.expectedInvocations, n)
	return mmGrantPrivilege
}

func (mmGrantPrivilege *mClientMockGrantPrivilege) invocationsDone() bool {
	if len(mmGrantPrivilege.expectations) == 0 && mmGrantPrivilege.defaultExpectation == nil && mmGrantPrivilege.mock.funcGrantPrivilege == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrantPrivilege.mock.afterGrantPrivilegeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrantPrivilege.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GrantPrivilege implements Client
func (mmGrantPrivilege *ClientMock) GrantPrivilege(ctx context.Context, serviceId string, grantPrivilege GrantPrivilege) (gp1 *GrantPrivilege, err error) {
	mm_atomic.AddUint64(&mmGrantPrivilege.beforeGrantPrivilegeCounter, 1)
	defer mm_atomic.AddUint64(&mmGrantPrivilege.afterGrantPrivilegeCounter, 1)

	if mmGrantPrivilege.inspectFuncGrantPrivilege != nil {
		mmGrantPrivilege.inspectFuncGrantPrivilege(ctx, serviceId, grantPrivilege)
	}

	mm_params := ClientMockGrantPrivilegeParams{ctx, serviceId, grantPrivilege}

	// Record call args
	mmGrantPrivilege.GrantPrivilegeMock.mutex.Lock()
	mmGrantPrivilege.GrantPrivilegeMock.callArgs = append(mmGrantPrivilege.GrantPrivilegeMock.callArgs, &mm_params)
	mmGrantPrivilege.GrantPrivilegeMock.mutex.Unlock()

	for _, e := range mmGrantPrivilege.GrantPrivilegeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGrantPrivilege.GrantPrivilegeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrantPrivilege.GrantPrivilegeMock.defaultExpectation.Counter, 1)
		mm_want := mmGrantPrivilege.GrantPrivilegeMock.defaultExpectation.params
		mm_want_ptrs := mmGrantPrivilege.GrantPrivilegeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGrantPrivilegeParams{ctx, serviceId, grantPrivilege}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGrantPrivilege.t.Errorf("ClientMock.GrantPrivilege got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGrantPrivilege.t.Errorf("ClientMock.GrantPrivilege got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.grantPrivilege != nil && !minimock.Equal(*mm_want_ptrs.grantPrivilege, mm_got.grantPrivilege) {
				mmGrantPrivilege.t.Errorf("ClientMock.GrantPrivilege got unexpected parameter grantPrivilege, want: %#v, got: %#v%s\n", *mm_want_ptrs.grantPrivilege, mm_got.grantPrivilege, minimock.Diff(*mm_want_ptrs.grantPrivilege, mm_got.grantPrivilege))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGrantPrivilege.t.Errorf("ClientMock.GrantPrivilege got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGrantPrivilege.GrantPrivilegeMock.defaultExpectation.results
		if mm_results == nil {
			mmGrantPrivilege.t.Fatal("No results are set for the ClientMock.GrantPrivilege")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGrantPrivilege.funcGrantPrivilege != nil {
		return mmGrantPrivilege.funcGrantPrivilege(ctx, serviceId, grantPrivilege)
	}
	mmGrantPrivilege.t.Fatalf("Unexpected call to ClientMock.GrantPrivilege. %v %v %v", ctx, serviceId, grantPrivilege)
	return
}

// GrantPrivilegeAfterCounter returns a count of finished ClientMock.GrantPrivilege invocations
func (mmGrantPrivilege *ClientMock) GrantPrivilegeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrantPrivilege.afterGrantPrivilegeCounter)
}

// GrantPrivilegeBeforeCounter returns a count of ClientMock.GrantPrivilege invocations
func (mmGrantPrivilege *ClientMock) GrantPrivilegeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrantPrivilege.beforeGrantPrivilegeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GrantPrivilege.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGrantPrivilege *mClientMockGrantPrivilege) Calls() []*ClientMockGrantPrivilegeParams {
	mmGrantPrivilege.mutex.RLock()

	argCopy := make([]*ClientMockGrantPrivilegeParams, len(mmGrantPrivilege.callArgs))
	copy(argCopy, mmGrantPrivilege.callArgs)

	mmGrantPrivilege.mutex.RUnlock()

	return argCopy
}

// MinimockGrantPrivilegeDone returns true if the count of the GrantPrivilege invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGrantPrivilegeDone() bool {
	if m.GrantPrivilegeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GrantPrivilegeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GrantPrivilegeMock.invocationsDone()
}

// MinimockGrantPrivilegeInspect logs each unmet expectation
func (m *ClientMock) MinimockGrantPrivilegeInspect() {
	for _, e := range m.GrantPrivilegeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GrantPrivilege with params: %#v", *e.params)
		}
	}

	afterGrantPrivilegeCounter := mm_atomic.LoadUint64(&m.afterGrantPrivilegeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GrantPrivilegeMock.defaultExpectation != nil && afterGrantPrivilegeCounter < 1 {
		if m.GrantPrivilegeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GrantPrivilege")
		} else {
			m.t.Errorf("Expected call to ClientMock.GrantPrivilege with params: %#v", *m.GrantPrivilegeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrantPrivilege != nil && afterGrantPrivilegeCounter < 1 {
		m.t.Error("Expected call to ClientMock.GrantPrivilege")
	}

	if !m.GrantPrivilegeMock.invocationsDone() && afterGrantPrivilegeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GrantPrivilege but found %d calls",
			mm_atomic.LoadUint64(&m.GrantPrivilegeMock.expectedInvocations), afterGrantPrivilegeCounter)
	}
}

type mClientMockGrantRole struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGrantRoleExpectation
	expectations       []*ClientMockGrantRoleExpectation

	callArgs []*ClientMockGrantRoleParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGrantRoleExpectation specifies expectation struct of the Client.GrantRole
type ClientMockGrantRoleExpectation struct {
	mock      *ClientMock
	params    *ClientMockGrantRoleParams
	paramPtrs *ClientMockGrantRoleParamPtrs
	results   *ClientMockGrantRoleResults
	Counter   uint64
}

// ClientMockGrantRoleParams contains parameters of the Client.GrantRole
type ClientMockGrantRoleParams struct {
	ctx       context.Context
	serviceId string
	grantRole GrantRole
}

// ClientMockGrantRoleParamPtrs contains pointers to parameters of the Client.GrantRole
type ClientMockGrantRoleParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	grantRole *GrantRole
}

// ClientMockGrantRoleResults contains results of the Client.GrantRole
type ClientMockGrantRoleResults struct {
	gp1 *GrantRole
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrantRole *mClientMockGrantRole) Optional() *mClientMockGrantRole {
	mmGrantRole.optional = true
	return mmGrantRole
}

// Expect sets up expected params for Client.GrantRole
func (mmGrantRole *mClientMockGrantRole) Expect(ctx context.Context, serviceId string, grantRole GrantRole) *mClientMockGrantRole {
	if mmGrantRole.mock.funcGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Set")
	}

	if mmGrantRole.defaultExpectation == nil {
		mmGrantRole.defaultExpectation = &ClientMockGrantRoleExpectation{}
	}

	if mmGrantRole.defaultExpectation.paramPtrs != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by ExpectParams functions")
	}

	mmGrantRole.defaultExpectation.params = &ClientMockGrantRoleParams{ctx, serviceId, grantRole}
	for _, e := range mmGrantRole.expectations {
		if minimock.Equal(e.params, mmGrantRole.defaultExpectation.params) {
			mmGrantRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGrantRole.defaultExpectation.params)
		}
	}

	return mmGrantRole
}

// ExpectCtxParam1 sets up expected param ctx for Client.GrantRole
func (mmGrantRole *mClientMockGrantRole) ExpectCtxParam1(ctx context.Context) *mClientMockGrantRole {
	if mmGrantRole.mock.funcGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Set")
	}

	if mmGrantRole.defaultExpectation == nil {
		mmGrantRole.defaultExpectation = &ClientMockGrantRoleExpectation{}
	}

	if mmGrantRole.defaultExpectation.params != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Expect")
	}

	if mmGrantRole.defaultExpectation.paramPtrs == nil {
		mmGrantRole.defaultExpectation.paramPtrs = &ClientMockGrantRoleParamPtrs{}
	}
	mmGrantRole.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGrantRole
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GrantRole
func (mmGrantRole *mClientMockGrantRole) ExpectServiceIdParam2(serviceId string) *mClientMockGrantRole {
	if mmGrantRole.mock.funcGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Set")
	}

	if mmGrantRole.defaultExpectation == nil {
		mmGrantRole.defaultExpectation = &ClientMockGrantRoleExpectation{}
	}

	if mmGrantRole.defaultExpectation.params != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Expect")
	}

	if mmGrantRole.defaultExpectation.paramPtrs == nil {
		mmGrantRole.defaultExpectation.paramPtrs = &ClientMockGrantRoleParamPtrs{}
	}
	mmGrantRole.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGrantRole
}

// ExpectGrantRoleParam3 sets up expected param grantRole for Client.GrantRole
func (mmGrantRole *mClientMockGrantRole) ExpectGrantRoleParam3(grantRole GrantRole) *mClientMockGrantRole {
	if mmGrantRole.mock.funcGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Set")
	}

	if mmGrantRole.defaultExpectation == nil {
		mmGrantRole.defaultExpectation = &ClientMockGrantRoleExpectation{}
	}

	if mmGrantRole.defaultExpectation.params != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Expect")
	}

	if mmGrantRole.defaultExpectation.paramPtrs == nil {
		mmGrantRole.defaultExpectation.paramPtrs = &ClientMockGrantRoleParamPtrs{}
	}
	mmGrantRole.defaultExpectation.paramPtrs.grantRole = &grantRole

	return mmGrantRole
}

// Inspect accepts an inspector function that has same arguments as the Client.GrantRole
func (mmGrantRole *mClientMockGrantRole) Inspect(f func(ctx context.Context, serviceId string, grantRole GrantRole)) *mClientMockGrantRole {
	if mmGrantRole.mock.inspectFuncGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("Inspect function is already set for ClientMock.GrantRole")
	}

	mmGrantRole.mock.inspectFuncGrantRole = f

	return mmGrantRole
}

// Return sets up results that will be returned by Client.GrantRole
func (mmGrantRole *mClientMockGrantRole) Return(gp1 *GrantRole, err error) *ClientMock {
	if mmGrantRole.mock.funcGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Set")
	}

	if mmGrantRole.defaultExpectation == nil {
		mmGrantRole.defaultExpectation = &ClientMockGrantRoleExpectation{mock: mmGrantRole.mock}
	}
	mmGrantRole.defaultExpectation.results = &ClientMockGrantRoleResults{gp1, err}
	return mmGrantRole.mock
}

// Set uses given function f to mock the Client.GrantRole method
func (mmGrantRole *mClientMockGrantRole) Set(f func(ctx context.Context, serviceId string, grantRole GrantRole) (gp1 *GrantRole, err error)) *ClientMock {
	if mmGrantRole.defaultExpectation != nil {
		mmGrantRole.mock.t.Fatalf("Default expectation is already set for the Client.GrantRole method")
	}

	if len(mmGrantRole.expectations) > 0 {
		mmGrantRole.mock.t.Fatalf("Some expectations are already set for the Client.GrantRole method")
	}

	mmGrantRole.mock.funcGrantRole = f
	return mmGrantRole.mock
}

// When sets expectation for the Client.GrantRole which will trigger the result defined by the following
// Then helper
func (mmGrantRole *mClientMockGrantRole) When(ctx context.Context, serviceId string, grantRole GrantRole) *ClientMockGrantRoleExpectation {
	if mmGrantRole.mock.funcGrantRole != nil {
		mmGrantRole.mock.t.Fatalf("ClientMock.GrantRole mock is already set by Set")
	}

	expectation := &ClientMockGrantRoleExpectation{
		mock:   mmGrantRole.mock,
		params: &ClientMockGrantRoleParams{ctx, serviceId, grantRole},
	}
	mmGrantRole.expectations = append(mmGrantRole.expectations, expectation)
	return expectation
}

// Then sets up Client.GrantRole return parameters for the expectation previously defined by the When method
func (e *ClientMockGrantRoleExpectation) Then(gp1 *GrantRole, err error) *ClientMock {
	e.results = &ClientMockGrantRoleResults{gp1, err}
	return e.mock
}

// Times sets number of times Client.GrantRole should be invoked
func (mmGrantRole *mClientMockGrantRole) Times(n uint64) *mClientMockGrantRole {
	if n == 0 {
		mmGrantRole.mock.t.Fatalf("Times of ClientMock.GrantRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrantRole.expectedInvocations, n)
	return mmGrantRole
}

func (mmGrantRole *mClientMockGrantRole) invocationsDone() bool {
	if len(mmGrantRole.expectations) == 0 && mmGrantRole.defaultExpectation == nil && mmGrantRole.mock.funcGrantRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrantRole.mock.afterGrantRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrantRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GrantRole implements Client
func (mmGrantRole *ClientMock) GrantRole(ctx context.Context, serviceId string, grantRole GrantRole) (gp1 *GrantRole, err error) {
	mm_atomic.AddUint64(&mmGrantRole.beforeGrantRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmGrantRole.afterGrantRoleCounter, 1)

	if mmGrantRole.inspectFuncGrantRole != nil {
		mmGrantRole.inspectFuncGrantRole(ctx, serviceId, grantRole)
	}

	mm_params := ClientMockGrantRoleParams{ctx, serviceId, grantRole}

	// Record call args
	mmGrantRole.GrantRoleMock.mutex.Lock()
	mmGrantRole.GrantRoleMock.callArgs = append(mmGrantRole.GrantRoleMock.callArgs, &mm_params)
	mmGrantRole.GrantRoleMock.mutex.Unlock()

	for _, e := range mmGrantRole.GrantRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGrantRole.GrantRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrantRole.GrantRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmGrantRole.GrantRoleMock.defaultExpectation.params
		mm_want_ptrs := mmGrantRole.GrantRoleMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGrantRoleParams{ctx, serviceId, grantRole}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGrantRole.t.Errorf("ClientMock.GrantRole got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGrantRole.t.Errorf("ClientMock.GrantRole got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.grantRole != nil && !minimock.Equal(*mm_want_ptrs.grantRole, mm_got.grantRole) {
				mmGrantRole.t.Errorf("ClientMock.GrantRole got unexpected parameter grantRole, want: %#v, got: %#v%s\n", *mm_want_ptrs.grantRole, mm_got.grantRole, minimock.Diff(*mm_want_ptrs.grantRole, mm_got.grantRole))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGrantRole.t.Errorf("ClientMock.GrantRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGrantRole.GrantRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmGrantRole.t.Fatal("No results are set for the ClientMock.GrantRole")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGrantRole.funcGrantRole != nil {
		return mmGrantRole.funcGrantRole(ctx, serviceId, grantRole)
	}
	mmGrantRole.t.Fatalf("Unexpected call to ClientMock.GrantRole. %v %v %v", ctx, serviceId, grantRole)
	return
}

// GrantRoleAfterCounter returns a count of finished ClientMock.GrantRole invocations
func (mmGrantRole *ClientMock) GrantRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrantRole.afterGrantRoleCounter)
}

// GrantRoleBeforeCounter returns a count of ClientMock.GrantRole invocations
func (mmGrantRole *ClientMock) GrantRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrantRole.beforeGrantRoleCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GrantRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGrantRole *mClientMockGrantRole) Calls() []*ClientMockGrantRoleParams {
	mmGrantRole.mutex.RLock()

	argCopy := make([]*ClientMockGrantRoleParams, len(mmGrantRole.callArgs))
	copy(argCopy, mmGrantRole.callArgs)

	mmGrantRole.mutex.RUnlock()

	return argCopy
}

// MinimockGrantRoleDone returns true if the count of the GrantRole invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGrantRoleDone() bool {
	if m.GrantRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GrantRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GrantRoleMock.invocationsDone()
}

// MinimockGrantRoleInspect logs each unmet expectation
func (m *ClientMock) MinimockGrantRoleInspect() {
	for _, e := range m.GrantRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GrantRole with params: %#v", *e.params)
		}
	}

	afterGrantRoleCounter := mm_atomic.LoadUint64(&m.afterGrantRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GrantRoleMock.defaultExpectation != nil && afterGrantRoleCounter < 1 {
		if m.GrantRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GrantRole")
		} else {
			m.t.Errorf("Expected call to ClientMock.GrantRole with params: %#v", *m.GrantRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrantRole != nil && afterGrantRoleCounter < 1 {
		m.t.Error("Expected call to ClientMock.GrantRole")
	}

	if !m.GrantRoleMock.invocationsDone() && afterGrantRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GrantRole but found %d calls",
			mm_atomic.LoadUint64(&m.GrantRoleMock.expectedInvocations), afterGrantRoleCounter)
	}
}

type mClientMockListReversePrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListReversePrivateEndpointsExpectation
	expectations       []*ClientMockListReversePrivateEndpointsExpectation

	callArgs []*ClientMockListReversePrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockListReversePrivateEndpointsExpectation specifies expectation struct of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockListReversePrivateEndpointsParams
	paramPtrs *ClientMockListReversePrivateEndpointsParamPtrs
	results   *ClientMockListReversePrivateEndpointsResults
	Counter   uint64
}

// ClientMockListReversePrivateEndpointsParams contains parameters of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockListReversePrivateEndpointsParamPtrs contains pointers to parameters of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockListReversePrivateEndpointsResults contains results of the Client.ListReversePrivateEndpoints
type ClientMockListReversePrivateEndpointsResults struct {
	rpa1 []*ReversePrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Optional() *mClientMockListReversePrivateEndpoints {
	mmListReversePrivateEndpoints.optional = true
	return mmListReversePrivateEndpoints
}

// Expect sets up expected params for Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Expect(ctx context.Context, serviceId string) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{}
	}

	if mmListReversePrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmListReversePrivateEndpoints.defaultExpectation.params = &ClientMockListReversePrivateEndpointsParams{ctx, serviceId}
	for _, e := range mmListReversePrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmListReversePrivateEndpoints.defaultExpectation.params) {
			mmListReversePrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReversePrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmListReversePrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{}
	}

	if mmListReversePrivateEndpoints.defaultExpectation.params != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Expect")
	}

	if mmListReversePrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmListReversePrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockListReversePrivateEndpointsParamPtrs{}
	}
	mmListReversePrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListReversePrivateEndpoints
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) ExpectServiceIdParam2(serviceId string) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{}
	}

	if mmListReversePrivateEndpoints.defaultExpectation.params != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Expect")
	}

	if mmListReversePrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmListReversePrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockListReversePrivateEndpointsParamPtrs{}
	}
	mmListReversePrivateEndpoints.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmListReversePrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockListReversePrivateEndpoints {
	if mmListReversePrivateEndpoints.mock.inspectFuncListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.ListReversePrivateEndpoints")
	}

	mmListReversePrivateEndpoints.mock.inspectFuncListReversePrivateEndpoints = f

	return mmListReversePrivateEndpoints
}

// Return sets up results that will be returned by Client.ListReversePrivateEndpoints
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Return(rpa1 []*ReversePrivateEndpoint, err error) *ClientMock {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	if mmListReversePrivateEndpoints.defaultExpectation == nil {
		mmListReversePrivateEndpoints.defaultExpectation = &ClientMockListReversePrivateEndpointsExpectation{mock: mmListReversePrivateEndpoints.mock}
	}
	mmListReversePrivateEndpoints.defaultExpectation.results = &ClientMockListReversePrivateEndpointsResults{rpa1, err}
	return mmListReversePrivateEndpoints.mock
}

// Set uses given function f to mock the Client.ListReversePrivateEndpoints method
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Set(f func(ctx context.Context, serviceId string) (rpa1 []*ReversePrivateEndpoint, err error)) *ClientMock {
	if mmListReversePrivateEndpoints.defaultExpectation != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.ListReversePrivateEndpoints method")
	}

	if len(mmListReversePrivateEndpoints.expectations) > 0 {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.ListReversePrivateEndpoints method")
	}

	mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints = f
	return mmListReversePrivateEndpoints.mock
}

// When sets expectation for the Client.ListReversePrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) When(ctx context.Context, serviceId string) *ClientMockListReversePrivateEndpointsExpectation {
	if mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.mock.t.Fatalf("ClientMock.ListReversePrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockListReversePrivateEndpointsExpectation{
		mock:   mmListReversePrivateEndpoints.mock,
		params: &ClientMockListReversePrivateEndpointsParams{ctx, serviceId},
	}
	mmListReversePrivateEndpoints.expectations = append(mmListReversePrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.ListReversePrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockListReversePrivateEndpointsExpectation) Then(rpa1 []*ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockListReversePrivateEndpointsResults{rpa1, err}
	return e.mock
}

// Times sets number of times Client.ListReversePrivateEndpoints should be invoked
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Times(n uint64) *mClientMockListReversePrivateEndpoints {
	if n == 0 {
		mmListReversePrivateEndpoints.mock.t.Fatalf("Times of ClientMock.ListReversePrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReversePrivateEndpoints.expectedInvocations, n)
	return mmListReversePrivateEndpoints
}

func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) invocationsDone() bool {
	if len(mmListReversePrivateEndpoints.expectations) == 0 && mmListReversePrivateEndpoints.defaultExpectation == nil && mmListReversePrivateEndpoints.mock.funcListReversePrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.mock.afterListReversePrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReversePrivateEndpoints implements Client
func (mmListReversePrivateEndpoints *ClientMock) ListReversePrivateEndpoints(ctx context.Context, serviceId string) (rpa1 []*ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmListReversePrivateEndpoints.beforeListReversePrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReversePrivateEndpoints.afterListReversePrivateEndpointsCounter, 1)

	if mmListReversePrivateEndpoints.inspectFuncListReversePrivateEndpoints != nil {
		mmListReversePrivateEndpoints.inspectFuncListReversePrivateEndpoints(ctx, serviceId)
	}

	mm_params := ClientMockListReversePrivateEndpointsParams{ctx, serviceId}

	// Record call args
	mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.mutex.Lock()
	mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.callArgs = append(mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.callArgs, &mm_params)
	mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockListReversePrivateEndpointsParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReversePrivateEndpoints.t.Errorf("ClientMock.ListReversePrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmListReversePrivateEndpoints.t.Errorf("ClientMock.ListReversePrivateEndpoints got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReversePrivateEndpoints.t.Errorf("ClientMock.ListReversePrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReversePrivateEndpoints.ListReversePrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReversePrivateEndpoints.t.Fatal("No results are set for the ClientMock.ListReversePrivateEndpoints")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmListReversePrivateEndpoints.funcListReversePrivateEndpoints != nil {
		return mmListReversePrivateEndpoints.funcListReversePrivateEndpoints(ctx, serviceId)
	}
	mmListReversePrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.ListReversePrivateEndpoints. %v %v", ctx, serviceId)
	return
}

// ListReversePrivateEndpointsAfterCounter returns a count of finished ClientMock.ListReversePrivateEndpoints invocations
func (mmListReversePrivateEndpoints *ClientMock) ListReversePrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.afterListReversePrivateEndpointsCounter)
}

// ListReversePrivateEndpointsBeforeCounter returns a count of ClientMock.ListReversePrivateEndpoints invocations
func (mmListReversePrivateEndpoints *ClientMock) ListReversePrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReversePrivateEndpoints.beforeListReversePrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListReversePrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReversePrivateEndpoints *mClientMockListReversePrivateEndpoints) Calls() []*ClientMockListReversePrivateEndpointsParams {
	mmListReversePrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockListReversePrivateEndpointsParams, len(mmListReversePrivateEndpoints.callArgs))
	copy(argCopy, mmListReversePrivateEndpoints.callArgs)

	mmListReversePrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockListReversePrivateEndpointsDone returns true if the count of the ListReversePrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListReversePrivateEndpointsDone() bool {
	if m.ListReversePrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReversePrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReversePrivateEndpointsMock.invocationsDone()
}

// MinimockListReversePrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockListReversePrivateEndpointsInspect() {
	for _, e := range m.ListReversePrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListReversePrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterListReversePrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterListReversePrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReversePrivateEndpointsMock.defaultExpectation != nil && afterListReversePrivateEndpointsCounter < 1 {
		if m.ListReversePrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ListReversePrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.ListReversePrivateEndpoints with params: %#v", *m.ListReversePrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReversePrivateEndpoints != nil && afterListReversePrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.ListReversePrivateEndpoints")
	}

	if !m.ListReversePrivateEndpointsMock.invocationsDone() && afterListReversePrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListReversePrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.ListReversePrivateEndpointsMock.expectedInvocations), afterListReversePrivateEndpointsCounter)
	}
}

type mClientMockRevokeGrantPrivilege struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockRevokeGrantPrivilegeExpectation
	expectations       []*ClientMockRevokeGrantPrivilegeExpectation

	callArgs []*ClientMockRevokeGrantPrivilegeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockRevokeGrantPrivilegeExpectation specifies expectation struct of the Client.RevokeGrantPrivilege
type ClientMockRevokeGrantPrivilegeExpectation struct {
	mock      *ClientMock
	params    *ClientMockRevokeGrantPrivilegeParams
	paramPtrs *ClientMockRevokeGrantPrivilegeParamPtrs
	results   *ClientMockRevokeGrantPrivilegeResults
	Counter   uint64
}

// ClientMockRevokeGrantPrivilegeParams contains parameters of the Client.RevokeGrantPrivilege
type ClientMockRevokeGrantPrivilegeParams struct {
	ctx             context.Context
	serviceID       string
	accessType      string
	database        *string
	table           *string
	column          *string
	granteeUserName *string
	granteeRoleName *string
}

// ClientMockRevokeGrantPrivilegeParamPtrs contains pointers to parameters of the Client.RevokeGrantPrivilege
type ClientMockRevokeGrantPrivilegeParamPtrs struct {
	ctx             *context.Context
	serviceID       *string
	accessType      *string
	database        **string
	table           **string
	column          **string
	granteeUserName **string
	granteeRoleName **string
}

// ClientMockRevokeGrantPrivilegeResults contains results of the Client.RevokeGrantPrivilege
type ClientMockRevokeGrantPrivilegeResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Optional() *mClientMockRevokeGrantPrivilege {
	mmRevokeGrantPrivilege.optional = true
	return mmRevokeGrantPrivilege
}

// Expect sets up expected params for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Expect(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by ExpectParams functions")
	}

	mmRevokeGrantPrivilege.defaultExpectation.params = &ClientMockRevokeGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName}
	for _, e := range mmRevokeGrantPrivilege.expectations {
		if minimock.Equal(e.params, mmRevokeGrantPrivilege.defaultExpectation.params) {
			mmRevokeGrantPrivilege.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeGrantPrivilege.defaultExpectation.params)
		}
	}

	return mmRevokeGrantPrivilege
}

// ExpectCtxParam1 sets up expected param ctx for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectCtxParam1(ctx context.Context) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRevokeGrantPrivilege
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectServiceIDParam2(serviceID string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmRevokeGrantPrivilege
}

// ExpectAccessTypeParam3 sets up expected param accessType for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectAccessTypeParam3(accessType string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.accessType = &accessType

	return mmRevokeGrantPrivilege
}

// ExpectDatabaseParam4 sets up expected param database for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectDatabaseParam4(database *string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.database = &database

	return mmRevokeGrantPrivilege
}

// ExpectTableParam5 sets up expected param table for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectTableParam5(table *string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.table = &table

	return mmRevokeGrantPrivilege
}

// ExpectColumnParam6 sets up expected param column for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectColumnParam6(column *string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.column = &column

	return mmRevokeGrantPrivilege
}

// ExpectGranteeUserNameParam7 sets up expected param granteeUserName for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectGranteeUserNameParam7(granteeUserName *string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.granteeUserName = &granteeUserName

	return mmRevokeGrantPrivilege
}

// ExpectGranteeRoleNameParam8 sets up expected param granteeRoleName for Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) ExpectGranteeRoleNameParam8(granteeRoleName *string) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{}
	}

	if mmRevokeGrantPrivilege.defaultExpectation.params != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Expect")
	}

	if mmRevokeGrantPrivilege.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantPrivilege.defaultExpectation.paramPtrs = &ClientMockRevokeGrantPrivilegeParamPtrs{}
	}
	mmRevokeGrantPrivilege.defaultExpectation.paramPtrs.granteeRoleName = &granteeRoleName

	return mmRevokeGrantPrivilege
}

// Inspect accepts an inspector function that has same arguments as the Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Inspect(f func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string)) *mClientMockRevokeGrantPrivilege {
	if mmRevokeGrantPrivilege.mock.inspectFuncRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("Inspect function is already set for ClientMock.RevokeGrantPrivilege")
	}

	mmRevokeGrantPrivilege.mock.inspectFuncRevokeGrantPrivilege = f

	return mmRevokeGrantPrivilege
}

// Return sets up results that will be returned by Client.RevokeGrantPrivilege
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Return(err error) *ClientMock {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	if mmRevokeGrantPrivilege.defaultExpectation == nil {
		mmRevokeGrantPrivilege.defaultExpectation = &ClientMockRevokeGrantPrivilegeExpectation{mock: mmRevokeGrantPrivilege.mock}
	}
	mmRevokeGrantPrivilege.defaultExpectation.results = &ClientMockRevokeGrantPrivilegeResults{err}
	return mmRevokeGrantPrivilege.mock
}

// Set uses given function f to mock the Client.RevokeGrantPrivilege method
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Set(f func(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) (err error)) *ClientMock {
	if mmRevokeGrantPrivilege.defaultExpectation != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("Default expectation is already set for the Client.RevokeGrantPrivilege method")
	}

	if len(mmRevokeGrantPrivilege.expectations) > 0 {
		mmRevokeGrantPrivilege.mock.t.Fatalf("Some expectations are already set for the Client.RevokeGrantPrivilege method")
	}

	mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege = f
	return mmRevokeGrantPrivilege.mock
}

// When sets expectation for the Client.RevokeGrantPrivilege which will trigger the result defined by the following
// Then helper
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) When(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) *ClientMockRevokeGrantPrivilegeExpectation {
	if mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.mock.t.Fatalf("ClientMock.RevokeGrantPrivilege mock is already set by Set")
	}

	expectation := &ClientMockRevokeGrantPrivilegeExpectation{
		mock:   mmRevokeGrantPrivilege.mock,
		params: &ClientMockRevokeGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName},
	}
	mmRevokeGrantPrivilege.expectations = append(mmRevokeGrantPrivilege.expectations, expectation)
	return expectation
}

// Then sets up Client.RevokeGrantPrivilege return parameters for the expectation previously defined by the When method
func (e *ClientMockRevokeGrantPrivilegeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRevokeGrantPrivilegeResults{err}
	return e.mock
}

// Times sets number of times Client.RevokeGrantPrivilege should be invoked
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Times(n uint64) *mClientMockRevokeGrantPrivilege {
	if n == 0 {
		mmRevokeGrantPrivilege.mock.t.Fatalf("Times of ClientMock.RevokeGrantPrivilege mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRevokeGrantPrivilege.expectedInvocations, n)
	return mmRevokeGrantPrivilege
}

func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) invocationsDone() bool {
	if len(mmRevokeGrantPrivilege.expectations) == 0 && mmRevokeGrantPrivilege.defaultExpectation == nil && mmRevokeGrantPrivilege.mock.funcRevokeGrantPrivilege == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRevokeGrantPrivilege.mock.afterRevokeGrantPrivilegeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRevokeGrantPrivilege.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RevokeGrantPrivilege implements Client
func (mmRevokeGrantPrivilege *ClientMock) RevokeGrantPrivilege(ctx context.Context, serviceID string, accessType string, database *string, table *string, column *string, granteeUserName *string, granteeRoleName *string) (err error) {
	mm_atomic.AddUint64(&mmRevokeGrantPrivilege.beforeRevokeGrantPrivilegeCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeGrantPrivilege.afterRevokeGrantPrivilegeCounter, 1)

	if mmRevokeGrantPrivilege.inspectFuncRevokeGrantPrivilege != nil {
		mmRevokeGrantPrivilege.inspectFuncRevokeGrantPrivilege(ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName)
	}

	mm_params := ClientMockRevokeGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName}

	// Record call args
	mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.mutex.Lock()
	mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.callArgs = append(mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.callArgs, &mm_params)
	mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.mutex.Unlock()

	for _, e := range mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.defaultExpectation.params
		mm_want_ptrs := mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockRevokeGrantPrivilegeParams{ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.accessType != nil && !minimock.Equal(*mm_want_ptrs.accessType, mm_got.accessType) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter accessType, want: %#v, got: %#v%s\n", *mm_want_ptrs.accessType, mm_got.accessType, minimock.Diff(*mm_want_ptrs.accessType, mm_got.accessType))
			}

			if mm_want_ptrs.database != nil && !minimock.Equal(*mm_want_ptrs.database, mm_got.database) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter database, want: %#v, got: %#v%s\n", *mm_want_ptrs.database, mm_got.database, minimock.Diff(*mm_want_ptrs.database, mm_got.database))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter table, want: %#v, got: %#v%s\n", *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

			if mm_want_ptrs.column != nil && !minimock.Equal(*mm_want_ptrs.column, mm_got.column) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter column, want: %#v, got: %#v%s\n", *mm_want_ptrs.column, mm_got.column, minimock.Diff(*mm_want_ptrs.column, mm_got.column))
			}

			if mm_want_ptrs.granteeUserName != nil && !minimock.Equal(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter granteeUserName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeUserName, mm_got.granteeUserName, minimock.Diff(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName))
			}

			if mm_want_ptrs.granteeRoleName != nil && !minimock.Equal(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName) {
				mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameter granteeRoleName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName, minimock.Diff(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeGrantPrivilege.t.Errorf("ClientMock.RevokeGrantPrivilege got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeGrantPrivilege.RevokeGrantPrivilegeMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeGrantPrivilege.t.Fatal("No results are set for the ClientMock.RevokeGrantPrivilege")
		}
		return (*mm_results).err
	}
	if mmRevokeGrantPrivilege.funcRevokeGrantPrivilege != nil {
		return mmRevokeGrantPrivilege.funcRevokeGrantPrivilege(ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName)
	}
	mmRevokeGrantPrivilege.t.Fatalf("Unexpected call to ClientMock.RevokeGrantPrivilege. %v %v %v %v %v %v %v %v", ctx, serviceID, accessType, database, table, column, granteeUserName, granteeRoleName)
	return
}

// RevokeGrantPrivilegeAfterCounter returns a count of finished ClientMock.RevokeGrantPrivilege invocations
func (mmRevokeGrantPrivilege *ClientMock) RevokeGrantPrivilegeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeGrantPrivilege.afterRevokeGrantPrivilegeCounter)
}

// RevokeGrantPrivilegeBeforeCounter returns a count of ClientMock.RevokeGrantPrivilege invocations
func (mmRevokeGrantPrivilege *ClientMock) RevokeGrantPrivilegeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeGrantPrivilege.beforeRevokeGrantPrivilegeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RevokeGrantPrivilege.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeGrantPrivilege *mClientMockRevokeGrantPrivilege) Calls() []*ClientMockRevokeGrantPrivilegeParams {
	mmRevokeGrantPrivilege.mutex.RLock()

	argCopy := make([]*ClientMockRevokeGrantPrivilegeParams, len(mmRevokeGrantPrivilege.callArgs))
	copy(argCopy, mmRevokeGrantPrivilege.callArgs)

	mmRevokeGrantPrivilege.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeGrantPrivilegeDone returns true if the count of the RevokeGrantPrivilege invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRevokeGrantPrivilegeDone() bool {
	if m.RevokeGrantPrivilegeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RevokeGrantPrivilegeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RevokeGrantPrivilegeMock.invocationsDone()
}

// MinimockRevokeGrantPrivilegeInspect logs each unmet expectation
func (m *ClientMock) MinimockRevokeGrantPrivilegeInspect() {
	for _, e := range m.RevokeGrantPrivilegeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RevokeGrantPrivilege with params: %#v", *e.params)
		}
	}

	afterRevokeGrantPrivilegeCounter := mm_atomic.LoadUint64(&m.afterRevokeGrantPrivilegeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeGrantPrivilegeMock.defaultExpectation != nil && afterRevokeGrantPrivilegeCounter < 1 {
		if m.RevokeGrantPrivilegeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RevokeGrantPrivilege")
		} else {
			m.t.Errorf("Expected call to ClientMock.RevokeGrantPrivilege with params: %#v", *m.RevokeGrantPrivilegeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeGrantPrivilege != nil && afterRevokeGrantPrivilegeCounter < 1 {
		m.t.Error("Expected call to ClientMock.RevokeGrantPrivilege")
	}

	if !m.RevokeGrantPrivilegeMock.invocationsDone() && afterRevokeGrantPrivilegeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.RevokeGrantPrivilege but found %d calls",
			mm_atomic.LoadUint64(&m.RevokeGrantPrivilegeMock.expectedInvocations), afterRevokeGrantPrivilegeCounter)
	}
}

type mClientMockRevokeGrantRole struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockRevokeGrantRoleExpectation
	expectations       []*ClientMockRevokeGrantRoleExpectation

	callArgs []*ClientMockRevokeGrantRoleParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockRevokeGrantRoleExpectation specifies expectation struct of the Client.RevokeGrantRole
type ClientMockRevokeGrantRoleExpectation struct {
	mock      *ClientMock
	params    *ClientMockRevokeGrantRoleParams
	paramPtrs *ClientMockRevokeGrantRoleParamPtrs
	results   *ClientMockRevokeGrantRoleResults
	Counter   uint64
}

// ClientMockRevokeGrantRoleParams contains parameters of the Client.RevokeGrantRole
type ClientMockRevokeGrantRoleParams struct {
	ctx             context.Context
	serviceID       string
	grantedRoleName string
	granteeUserName *string
	granteeRoleName *string
}

// ClientMockRevokeGrantRoleParamPtrs contains pointers to parameters of the Client.RevokeGrantRole
type ClientMockRevokeGrantRoleParamPtrs struct {
	ctx             *context.Context
	serviceID       *string
	grantedRoleName *string
	granteeUserName **string
	granteeRoleName **string
}

// ClientMockRevokeGrantRoleResults contains results of the Client.RevokeGrantRole
type ClientMockRevokeGrantRoleResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Optional() *mClientMockRevokeGrantRole {
	mmRevokeGrantRole.optional = true
	return mmRevokeGrantRole
}

// Expect sets up expected params for Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Expect(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{}
	}

	if mmRevokeGrantRole.defaultExpectation.paramPtrs != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by ExpectParams functions")
	}

	mmRevokeGrantRole.defaultExpectation.params = &ClientMockRevokeGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName}
	for _, e := range mmRevokeGrantRole.expectations {
		if minimock.Equal(e.params, mmRevokeGrantRole.defaultExpectation.params) {
			mmRevokeGrantRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeGrantRole.defaultExpectation.params)
		}
	}

	return mmRevokeGrantRole
}

// ExpectCtxParam1 sets up expected param ctx for Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) ExpectCtxParam1(ctx context.Context) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{}
	}

	if mmRevokeGrantRole.defaultExpectation.params != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Expect")
	}

	if mmRevokeGrantRole.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantRole.defaultExpectation.paramPtrs = &ClientMockRevokeGrantRoleParamPtrs{}
	}
	mmRevokeGrantRole.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRevokeGrantRole
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) ExpectServiceIDParam2(serviceID string) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{}
	}

	if mmRevokeGrantRole.defaultExpectation.params != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Expect")
	}

	if mmRevokeGrantRole.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantRole.defaultExpectation.paramPtrs = &ClientMockRevokeGrantRoleParamPtrs{}
	}
	mmRevokeGrantRole.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmRevokeGrantRole
}

// ExpectGrantedRoleNameParam3 sets up expected param grantedRoleName for Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) ExpectGrantedRoleNameParam3(grantedRoleName string) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{}
	}

	if mmRevokeGrantRole.defaultExpectation.params != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Expect")
	}

	if mmRevokeGrantRole.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantRole.defaultExpectation.paramPtrs = &ClientMockRevokeGrantRoleParamPtrs{}
	}
	mmRevokeGrantRole.defaultExpectation.paramPtrs.grantedRoleName = &grantedRoleName

	return mmRevokeGrantRole
}

// ExpectGranteeUserNameParam4 sets up expected param granteeUserName for Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) ExpectGranteeUserNameParam4(granteeUserName *string) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{}
	}

	if mmRevokeGrantRole.defaultExpectation.params != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Expect")
	}

	if mmRevokeGrantRole.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantRole.defaultExpectation.paramPtrs = &ClientMockRevokeGrantRoleParamPtrs{}
	}
	mmRevokeGrantRole.defaultExpectation.paramPtrs.granteeUserName = &granteeUserName

	return mmRevokeGrantRole
}

// ExpectGranteeRoleNameParam5 sets up expected param granteeRoleName for Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) ExpectGranteeRoleNameParam5(granteeRoleName *string) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{}
	}

	if mmRevokeGrantRole.defaultExpectation.params != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Expect")
	}

	if mmRevokeGrantRole.defaultExpectation.paramPtrs == nil {
		mmRevokeGrantRole.defaultExpectation.paramPtrs = &ClientMockRevokeGrantRoleParamPtrs{}
	}
	mmRevokeGrantRole.defaultExpectation.paramPtrs.granteeRoleName = &granteeRoleName

	return mmRevokeGrantRole
}

// Inspect accepts an inspector function that has same arguments as the Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Inspect(f func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string)) *mClientMockRevokeGrantRole {
	if mmRevokeGrantRole.mock.inspectFuncRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("Inspect function is already set for ClientMock.RevokeGrantRole")
	}

	mmRevokeGrantRole.mock.inspectFuncRevokeGrantRole = f

	return mmRevokeGrantRole
}

// Return sets up results that will be returned by Client.RevokeGrantRole
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Return(err error) *ClientMock {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	if mmRevokeGrantRole.defaultExpectation == nil {
		mmRevokeGrantRole.defaultExpectation = &ClientMockRevokeGrantRoleExpectation{mock: mmRevokeGrantRole.mock}
	}
	mmRevokeGrantRole.defaultExpectation.results = &ClientMockRevokeGrantRoleResults{err}
	return mmRevokeGrantRole.mock
}

// Set uses given function f to mock the Client.RevokeGrantRole method
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Set(f func(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) (err error)) *ClientMock {
	if mmRevokeGrantRole.defaultExpectation != nil {
		mmRevokeGrantRole.mock.t.Fatalf("Default expectation is already set for the Client.RevokeGrantRole method")
	}

	if len(mmRevokeGrantRole.expectations) > 0 {
		mmRevokeGrantRole.mock.t.Fatalf("Some expectations are already set for the Client.RevokeGrantRole method")
	}

	mmRevokeGrantRole.mock.funcRevokeGrantRole = f
	return mmRevokeGrantRole.mock
}

// When sets expectation for the Client.RevokeGrantRole which will trigger the result defined by the following
// Then helper
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) When(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) *ClientMockRevokeGrantRoleExpectation {
	if mmRevokeGrantRole.mock.funcRevokeGrantRole != nil {
		mmRevokeGrantRole.mock.t.Fatalf("ClientMock.RevokeGrantRole mock is already set by Set")
	}

	expectation := &ClientMockRevokeGrantRoleExpectation{
		mock:   mmRevokeGrantRole.mock,
		params: &ClientMockRevokeGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName},
	}
	mmRevokeGrantRole.expectations = append(mmRevokeGrantRole.expectations, expectation)
	return expectation
}

// Then sets up Client.RevokeGrantRole return parameters for the expectation previously defined by the When method
func (e *ClientMockRevokeGrantRoleExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRevokeGrantRoleResults{err}
	return e.mock
}

// Times sets number of times Client.RevokeGrantRole should be invoked
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Times(n uint64) *mClientMockRevokeGrantRole {
	if n == 0 {
		mmRevokeGrantRole.mock.t.Fatalf("Times of ClientMock.RevokeGrantRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRevokeGrantRole.expectedInvocations, n)
	return mmRevokeGrantRole
}

func (mmRevokeGrantRole *mClientMockRevokeGrantRole) invocationsDone() bool {
	if len(mmRevokeGrantRole.expectations) == 0 && mmRevokeGrantRole.defaultExpectation == nil && mmRevokeGrantRole.mock.funcRevokeGrantRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRevokeGrantRole.mock.afterRevokeGrantRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRevokeGrantRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RevokeGrantRole implements Client
func (mmRevokeGrantRole *ClientMock) RevokeGrantRole(ctx context.Context, serviceID string, grantedRoleName string, granteeUserName *string, granteeRoleName *string) (err error) {
	mm_atomic.AddUint64(&mmRevokeGrantRole.beforeRevokeGrantRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeGrantRole.afterRevokeGrantRoleCounter, 1)

	if mmRevokeGrantRole.inspectFuncRevokeGrantRole != nil {
		mmRevokeGrantRole.inspectFuncRevokeGrantRole(ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName)
	}

	mm_params := ClientMockRevokeGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName}

	// Record call args
	mmRevokeGrantRole.RevokeGrantRoleMock.mutex.Lock()
	mmRevokeGrantRole.RevokeGrantRoleMock.callArgs = append(mmRevokeGrantRole.RevokeGrantRoleMock.callArgs, &mm_params)
	mmRevokeGrantRole.RevokeGrantRoleMock.mutex.Unlock()

	for _, e := range mmRevokeGrantRole.RevokeGrantRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeGrantRole.RevokeGrantRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeGrantRole.RevokeGrantRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeGrantRole.RevokeGrantRoleMock.defaultExpectation.params
		mm_want_ptrs := mmRevokeGrantRole.RevokeGrantRoleMock.defaultExpectation.paramPtrs

		mm_got := ClientMockRevokeGrantRoleParams{ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRevokeGrantRole.t.Errorf("ClientMock.RevokeGrantRole got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmRevokeGrantRole.t.Errorf("ClientMock.RevokeGrantRole got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.grantedRoleName != nil && !minimock.Equal(*mm_want_ptrs.grantedRoleName, mm_got.grantedRoleName) {
				mmRevokeGrantRole.t.Errorf("ClientMock.RevokeGrantRole got unexpected parameter grantedRoleName, want: %#v, got: %#v%s\n", *mm_want_ptrs.grantedRoleName, mm_got.grantedRoleName, minimock.Diff(*mm_want_ptrs.grantedRoleName, mm_got.grantedRoleName))
			}

			if mm_want_ptrs.granteeUserName != nil && !minimock.Equal(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName) {
				mmRevokeGrantRole.t.Errorf("ClientMock.RevokeGrantRole got unexpected parameter granteeUserName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeUserName, mm_got.granteeUserName, minimock.Diff(*mm_want_ptrs.granteeUserName, mm_got.granteeUserName))
			}

			if mm_want_ptrs.granteeRoleName != nil && !minimock.Equal(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName) {
				mmRevokeGrantRole.t.Errorf("ClientMock.RevokeGrantRole got unexpected parameter granteeRoleName, want: %#v, got: %#v%s\n", *mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName, minimock.Diff(*mm_want_ptrs.granteeRoleName, mm_got.granteeRoleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeGrantRole.t.Errorf("ClientMock.RevokeGrantRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeGrantRole.RevokeGrantRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeGrantRole.t.Fatal("No results are set for the ClientMock.RevokeGrantRole")
		}
		return (*mm_results).err
	}
	if mmRevokeGrantRole.funcRevokeGrantRole != nil {
		return mmRevokeGrantRole.funcRevokeGrantRole(ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName)
	}
	mmRevokeGrantRole.t.Fatalf("Unexpected call to ClientMock.RevokeGrantRole. %v %v %v %v %v", ctx, serviceID, grantedRoleName, granteeUserName, granteeRoleName)
	return
}

// RevokeGrantRoleAfterCounter returns a count of finished ClientMock.RevokeGrantRole invocations
func (mmRevokeGrantRole *ClientMock) RevokeGrantRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeGrantRole.afterRevokeGrantRoleCounter)
}

// RevokeGrantRoleBeforeCounter returns a count of ClientMock.RevokeGrantRole invocations
func (mmRevokeGrantRole *ClientMock) RevokeGrantRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeGrantRole.beforeRevokeGrantRoleCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RevokeGrantRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeGrantRole *mClientMockRevokeGrantRole) Calls() []*ClientMockRevokeGrantRoleParams {
	mmRevokeGrantRole.mutex.RLock()

	argCopy := make([]*ClientMockRevokeGrantRoleParams, len(mmRevokeGrantRole.callArgs))
	copy(argCopy, mmRevokeGrantRole.callArgs)

	mmRevokeGrantRole.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeGrantRoleDone returns true if the count of the RevokeGrantRole invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRevokeGrantRoleDone() bool {
	if m.RevokeGrantRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RevokeGrantRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RevokeGrantRoleMock.invocationsDone()
}

// MinimockRevokeGrantRoleInspect logs each unmet expectation
func (m *ClientMock) MinimockRevokeGrantRoleInspect() {
	for _, e := range m.RevokeGrantRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RevokeGrantRole with params: %#v", *e.params)
		}
	}

	afterRevokeGrantRoleCounter := mm_atomic.LoadUint64(&m.afterRevokeGrantRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeGrantRoleMock.defaultExpectation != nil && afterRevokeGrantRoleCounter < 1 {
		if m.RevokeGrantRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RevokeGrantRole")
		} else {
			m.t.Errorf("Expected call to ClientMock.RevokeGrantRole with params: %#v", *m.RevokeGrantRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeGrantRole != nil && afterRevokeGrantRoleCounter < 1 {
		m.t.Error("Expected call to ClientMock.RevokeGrantRole")
	}

	if !m.RevokeGrantRoleMock.invocationsDone() && afterRevokeGrantRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.RevokeGrantRole but found %d calls",
			mm_atomic.LoadUint64(&m.RevokeGrantRoleMock.expectedInvocations), afterRevokeGrantRoleCounter)
	}
}

type mClientMockRotateTDEKey struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockRotateTDEKeyExpectation
	expectations       []*ClientMockRotateTDEKeyExpectation

	callArgs []*ClientMockRotateTDEKeyParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockRotateTDEKeyExpectation specifies expectation struct of the Client.RotateTDEKey
type ClientMockRotateTDEKeyExpectation struct {
	mock      *ClientMock
	params    *ClientMockRotateTDEKeyParams
	paramPtrs *ClientMockRotateTDEKeyParamPtrs
	results   *ClientMockRotateTDEKeyResults
	Counter   uint64
}

// ClientMockRotateTDEKeyParams contains parameters of the Client.RotateTDEKey
type ClientMockRotateTDEKeyParams struct {
	ctx       context.Context
	serviceId string
	keyId     string
}

// ClientMockRotateTDEKeyParamPtrs contains pointers to parameters of the Client.RotateTDEKey
type ClientMockRotateTDEKeyParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	keyId     *string
}

// ClientMockRotateTDEKeyResults contains results of the Client.RotateTDEKey
type ClientMockRotateTDEKeyResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRotateTDEKey *mClientMockRotateTDEKey) Optional() *mClientMockRotateTDEKey {
	mmRotateTDEKey.optional = true
	return mmRotateTDEKey
}

// Expect sets up expected params for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) Expect(ctx context.Context, serviceId string, keyId string) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by ExpectParams functions")
	}

	mmRotateTDEKey.defaultExpectation.params = &ClientMockRotateTDEKeyParams{ctx, serviceId, keyId}
	for _, e := range mmRotateTDEKey.expectations {
		if minimock.Equal(e.params, mmRotateTDEKey.defaultExpectation.params) {
			mmRotateTDEKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRotateTDEKey.defaultExpectation.params)
		}
	}

	return mmRotateTDEKey
}

// ExpectCtxParam1 sets up expected param ctx for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) ExpectCtxParam1(ctx context.Context) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.params != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Expect")
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs == nil {
		mmRotateTDEKey.defaultExpectation.paramPtrs = &ClientMockRotateTDEKeyParamPtrs{}
	}
	mmRotateTDEKey.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRotateTDEKey
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) ExpectServiceIdParam2(serviceId string) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.params != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Expect")
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs == nil {
		mmRotateTDEKey.defaultExpectation.paramPtrs = &ClientMockRotateTDEKeyParamPtrs{}
	}
	mmRotateTDEKey.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmRotateTDEKey
}

// ExpectKeyIdParam3 sets up expected param keyId for Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) ExpectKeyIdParam3(keyId string) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{}
	}

	if mmRotateTDEKey.defaultExpectation.params != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Expect")
	}

	if mmRotateTDEKey.defaultExpectation.paramPtrs == nil {
		mmRotateTDEKey.defaultExpectation.paramPtrs = &ClientMockRotateTDEKeyParamPtrs{}
	}
	mmRotateTDEKey.defaultExpectation.paramPtrs.keyId = &keyId

	return mmRotateTDEKey
}

// Inspect accepts an inspector function that has same arguments as the Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) Inspect(f func(ctx context.Context, serviceId string, keyId string)) *mClientMockRotateTDEKey {
	if mmRotateTDEKey.mock.inspectFuncRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("Inspect function is already set for ClientMock.RotateTDEKey")
	}

	mmRotateTDEKey.mock.inspectFuncRotateTDEKey = f

	return mmRotateTDEKey
}

// Return sets up results that will be returned by Client.RotateTDEKey
func (mmRotateTDEKey *mClientMockRotateTDEKey) Return(err error) *ClientMock {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	if mmRotateTDEKey.defaultExpectation == nil {
		mmRotateTDEKey.defaultExpectation = &ClientMockRotateTDEKeyExpectation{mock: mmRotateTDEKey.mock}
	}
	mmRotateTDEKey.defaultExpectation.results = &ClientMockRotateTDEKeyResults{err}
	return mmRotateTDEKey.mock
}

// Set uses given function f to mock the Client.RotateTDEKey method
func (mmRotateTDEKey *mClientMockRotateTDEKey) Set(f func(ctx context.Context, serviceId string, keyId string) (err error)) *ClientMock {
	if mmRotateTDEKey.defaultExpectation != nil {
		mmRotateTDEKey.mock.t.Fatalf("Default expectation is already set for the Client.RotateTDEKey method")
	}

	if len(mmRotateTDEKey.expectations) > 0 {
		mmRotateTDEKey.mock.t.Fatalf("Some expectations are already set for the Client.RotateTDEKey method")
	}

	mmRotateTDEKey.mock.funcRotateTDEKey = f
	return mmRotateTDEKey.mock
}

// When sets expectation for the Client.RotateTDEKey which will trigger the result defined by the following
// Then helper
func (mmRotateTDEKey *mClientMockRotateTDEKey) When(ctx context.Context, serviceId string, keyId string) *ClientMockRotateTDEKeyExpectation {
	if mmRotateTDEKey.mock.funcRotateTDEKey != nil {
		mmRotateTDEKey.mock.t.Fatalf("ClientMock.RotateTDEKey mock is already set by Set")
	}

	expectation := &ClientMockRotateTDEKeyExpectation{
		mock:   mmRotateTDEKey.mock,
		params: &ClientMockRotateTDEKeyParams{ctx, serviceId, keyId},
	}
	mmRotateTDEKey.expectations = append(mmRotateTDEKey.expectations, expectation)
	return expectation
}

// Then sets up Client.RotateTDEKey return parameters for the expectation previously defined by the When method
func (e *ClientMockRotateTDEKeyExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRotateTDEKeyResults{err}
	return e.mock
}

// Times sets number of times Client.RotateTDEKey should be invoked
func (mmRotateTDEKey *mClientMockRotateTDEKey) Times(n uint64) *mClientMockRotateTDEKey {
	if n == 0 {
		mmRotateTDEKey.mock.t.Fatalf("Times of ClientMock.RotateTDEKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRotateTDEKey.expectedInvocations, n)
	return mmRotateTDEKey
}

func (mmRotateTDEKey *mClientMockRotateTDEKey) invocationsDone() bool {
	if len(mmRotateTDEKey.expectations) == 0 && mmRotateTDEKey.defaultExpectation == nil && mmRotateTDEKey.mock.funcRotateTDEKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRotateTDEKey.mock.afterRotateTDEKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRotateTDEKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RotateTDEKey implements Client
func (mmRotateTDEKey *ClientMock) RotateTDEKey(ctx context.Context, serviceId string, keyId string) (err error) {
	mm_atomic.AddUint64(&mmRotateTDEKey.beforeRotateTDEKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRotateTDEKey.afterRotateTDEKeyCounter, 1)

	if mmRotateTDEKey.inspectFuncRotateTDEKey != nil {
		mmRotateTDEKey.inspectFuncRotateTDEKey(ctx, serviceId, keyId)
	}

	mm_params := ClientMockRotateTDEKeyParams{ctx, serviceId, keyId}

	// Record call args
	mmRotateTDEKey.RotateTDEKeyMock.mutex.Lock()
	mmRotateTDEKey.RotateTDEKeyMock.callArgs = append(mmRotateTDEKey.RotateTDEKeyMock.callArgs, &mm_params)
	mmRotateTDEKey.RotateTDEKeyMock.mutex.Unlock()

	for _, e := range mmRotateTDEKey.RotateTDEKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.params
		mm_want_ptrs := mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockRotateTDEKeyParams{ctx, serviceId, keyId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.keyId != nil && !minimock.Equal(*mm_want_ptrs.keyId, mm_got.keyId) {
				mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameter keyId, want: %#v, got: %#v%s\n", *mm_want_ptrs.keyId, mm_got.keyId, minimock.Diff(*mm_want_ptrs.keyId, mm_got.keyId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRotateTDEKey.t.Errorf("ClientMock.RotateTDEKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRotateTDEKey.RotateTDEKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRotateTDEKey.t.Fatal("No results are set for the ClientMock.RotateTDEKey")
		}
		return (*mm_results).err
	}
	if mmRotateTDEKey.funcRotateTDEKey != nil {
		return mmRotateTDEKey.funcRotateTDEKey(ctx, serviceId, keyId)
	}
	mmRotateTDEKey.t.Fatalf("Unexpected call to ClientMock.RotateTDEKey. %v %v %v", ctx, serviceId, keyId)
	return
}

// RotateTDEKeyAfterCounter returns a count of finished ClientMock.RotateTDEKey invocations
func (mmRotateTDEKey *ClientMock) RotateTDEKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRotateTDEKey.afterRotateTDEKeyCounter)
}

// RotateTDEKeyBeforeCounter returns a count of ClientMock.RotateTDEKey invocations
func (mmRotateTDEKey *ClientMock) RotateTDEKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRotateTDEKey.beforeRotateTDEKeyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RotateTDEKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRotateTDEKey *mClientMockRotateTDEKey) Calls() []*ClientMockRotateTDEKeyParams {
	mmRotateTDEKey.mutex.RLock()

	argCopy := make([]*ClientMockRotateTDEKeyParams, len(mmRotateTDEKey.callArgs))
	copy(argCopy, mmRotateTDEKey.callArgs)

	mmRotateTDEKey.mutex.RUnlock()

	return argCopy
}

// MinimockRotateTDEKeyDone returns true if the count of the RotateTDEKey invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRotateTDEKeyDone() bool {
	if m.RotateTDEKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RotateTDEKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RotateTDEKeyMock.invocationsDone()
}

// MinimockRotateTDEKeyInspect logs each unmet expectation
func (m *ClientMock) MinimockRotateTDEKeyInspect() {
	for _, e := range m.RotateTDEKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RotateTDEKey with params: %#v", *e.params)
		}
	}

	afterRotateTDEKeyCounter := mm_atomic.LoadUint64(&m.afterRotateTDEKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RotateTDEKeyMock.defaultExpectation != nil && afterRotateTDEKeyCounter < 1 {
		if m.RotateTDEKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RotateTDEKey")
		} else {
			m.t.Errorf("Expected call to ClientMock.RotateTDEKey with params: %#v", *m.RotateTDEKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRotateTDEKey != nil && afterRotateTDEKeyCounter < 1 {
		m.t.Error("Expected call to ClientMock.RotateTDEKey")
	}

	if !m.RotateTDEKeyMock.invocationsDone() && afterRotateTDEKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.RotateTDEKey but found %d calls",
			mm_atomic.LoadUint64(&m.RotateTDEKeyMock.expectedInvocations), afterRotateTDEKeyCounter)
	}
}

type mClientMockScalingClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockScalingClickPipeExpectation
	expectations       []*ClientMockScalingClickPipeExpectation

	callArgs []*ClientMockScalingClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockScalingClickPipeExpectation specifies expectation struct of the Client.ScalingClickPipe
type ClientMockScalingClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockScalingClickPipeParams
	paramPtrs *ClientMockScalingClickPipeParamPtrs
	results   *ClientMockScalingClickPipeResults
	Counter   uint64
}

// ClientMockScalingClickPipeParams contains parameters of the Client.ScalingClickPipe
type ClientMockScalingClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	request     ClickPipeScaling
}

// ClientMockScalingClickPipeParamPtrs contains pointers to parameters of the Client.ScalingClickPipe
type ClientMockScalingClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	request     *ClickPipeScaling
}

// ClientMockScalingClickPipeResults contains results of the Client.ScalingClickPipe
type ClientMockScalingClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScalingClickPipe *mClientMockScalingClickPipe) Optional() *mClientMockScalingClickPipe {
	mmScalingClickPipe.optional = true
	return mmScalingClickPipe
}

// Expect sets up expected params for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by ExpectParams functions")
	}

	mmScalingClickPipe.defaultExpectation.params = &ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}
	for _, e := range mmScalingClickPipe.expectations {
		if minimock.Equal(e.params, mmScalingClickPipe.defaultExpectation.params) {
			mmScalingClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScalingClickPipe.defaultExpectation.params)
		}
	}

	return mmScalingClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmScalingClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmScalingClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmScalingClickPipe
}

// ExpectRequestParam4 sets up expected param request for Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) ExpectRequestParam4(request ClickPipeScaling) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{}
	}

	if mmScalingClickPipe.defaultExpectation.params != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Expect")
	}

	if mmScalingClickPipe.defaultExpectation.paramPtrs == nil {
		mmScalingClickPipe.defaultExpectation.paramPtrs = &ClientMockScalingClickPipeParamPtrs{}
	}
	mmScalingClickPipe.defaultExpectation.paramPtrs.request = &request

	return mmScalingClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling)) *mClientMockScalingClickPipe {
	if mmScalingClickPipe.mock.inspectFuncScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.ScalingClickPipe")
	}

	mmScalingClickPipe.mock.inspectFuncScalingClickPipe = f

	return mmScalingClickPipe
}

// Return sets up results that will be returned by Client.ScalingClickPipe
func (mmScalingClickPipe *mClientMockScalingClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	if mmScalingClickPipe.defaultExpectation == nil {
		mmScalingClickPipe.defaultExpectation = &ClientMockScalingClickPipeExpectation{mock: mmScalingClickPipe.mock}
	}
	mmScalingClickPipe.defaultExpectation.results = &ClientMockScalingClickPipeResults{cp1, err}
	return mmScalingClickPipe.mock
}

// Set uses given function f to mock the Client.ScalingClickPipe method
func (mmScalingClickPipe *mClientMockScalingClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmScalingClickPipe.defaultExpectation != nil {
		mmScalingClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.ScalingClickPipe method")
	}

	if len(mmScalingClickPipe.expectations) > 0 {
		mmScalingClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.ScalingClickPipe method")
	}

	mmScalingClickPipe.mock.funcScalingClickPipe = f
	return mmScalingClickPipe.mock
}

// When sets expectation for the Client.ScalingClickPipe which will trigger the result defined by the following
// Then helper
func (mmScalingClickPipe *mClientMockScalingClickPipe) When(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) *ClientMockScalingClickPipeExpectation {
	if mmScalingClickPipe.mock.funcScalingClickPipe != nil {
		mmScalingClickPipe.mock.t.Fatalf("ClientMock.ScalingClickPipe mock is already set by Set")
	}

	expectation := &ClientMockScalingClickPipeExpectation{
		mock:   mmScalingClickPipe.mock,
		params: &ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request},
	}
	mmScalingClickPipe.expectations = append(mmScalingClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.ScalingClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockScalingClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockScalingClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ScalingClickPipe should be invoked
func (mmScalingClickPipe *mClientMockScalingClickPipe) Times(n uint64) *mClientMockScalingClickPipe {
	if n == 0 {
		mmScalingClickPipe.mock.t.Fatalf("Times of ClientMock.ScalingClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScalingClickPipe.expectedInvocations, n)
	return mmScalingClickPipe
}

func (mmScalingClickPipe *mClientMockScalingClickPipe) invocationsDone() bool {
	if len(mmScalingClickPipe.expectations) == 0 && mmScalingClickPipe.defaultExpectation == nil && mmScalingClickPipe.mock.funcScalingClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScalingClickPipe.mock.afterScalingClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScalingClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScalingClickPipe implements Client
func (mmScalingClickPipe *ClientMock) ScalingClickPipe(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeScaling) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmScalingClickPipe.beforeScalingClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmScalingClickPipe.afterScalingClickPipeCounter, 1)

	if mmScalingClickPipe.inspectFuncScalingClickPipe != nil {
		mmScalingClickPipe.inspectFuncScalingClickPipe(ctx, serviceId, clickPipeId, request)
	}

	mm_params := ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}

	// Record call args
	mmScalingClickPipe.ScalingClickPipeMock.mutex.Lock()
	mmScalingClickPipe.ScalingClickPipeMock.callArgs = append(mmScalingClickPipe.ScalingClickPipeMock.callArgs, &mm_params)
	mmScalingClickPipe.ScalingClickPipeMock.mutex.Unlock()

	for _, e := range mmScalingClickPipe.ScalingClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockScalingClickPipeParams{ctx, serviceId, clickPipeId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameter request, want: %#v, got: %#v%s\n", *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScalingClickPipe.t.Errorf("ClientMock.ScalingClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScalingClickPipe.ScalingClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmScalingClickPipe.t.Fatal("No results are set for the ClientMock.ScalingClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmScalingClickPipe.funcScalingClickPipe != nil {
		return mmScalingClickPipe.funcScalingClickPipe(ctx, serviceId, clickPipeId, request)
	}
	mmScalingClickPipe.t.Fatalf("Unexpected call to ClientMock.ScalingClickPipe. %v %v %v %v", ctx, serviceId, clickPipeId, request)
	return
}

// ScalingClickPipeAfterCounter returns a count of finished ClientMock.ScalingClickPipe invocations
func (mmScalingClickPipe *ClientMock) ScalingClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScalingClickPipe.afterScalingClickPipeCounter)
}

// ScalingClickPipeBeforeCounter returns a count of ClientMock.ScalingClickPipe invocations
func (mmScalingClickPipe *ClientMock) ScalingClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScalingClickPipe.beforeScalingClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ScalingClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScalingClickPipe *mClientMockScalingClickPipe) Calls() []*ClientMockScalingClickPipeParams {
	mmScalingClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockScalingClickPipeParams, len(mmScalingClickPipe.callArgs))
	copy(argCopy, mmScalingClickPipe.callArgs)

	mmScalingClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockScalingClickPipeDone returns true if the count of the ScalingClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockScalingClickPipeDone() bool {
	if m.ScalingClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScalingClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScalingClickPipeMock.invocationsDone()
}

// MinimockScalingClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockScalingClickPipeInspect() {
	for _, e := range m.ScalingClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe with params: %#v", *e.params)
		}
	}

	afterScalingClickPipeCounter := mm_atomic.LoadUint64(&m.afterScalingClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScalingClickPipeMock.defaultExpectation != nil && afterScalingClickPipeCounter < 1 {
		if m.ScalingClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ScalingClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.ScalingClickPipe with params: %#v", *m.ScalingClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScalingClickPipe != nil && afterScalingClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.ScalingClickPipe")
	}

	if !m.ScalingClickPipeMock.invocationsDone() && afterScalingClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ScalingClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.ScalingClickPipeMock.expectedInvocations), afterScalingClickPipeCounter)
	}
}

type mClientMockSyncDatabase struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockSyncDatabaseExpectation
	expectations       []*ClientMockSyncDatabaseExpectation

	callArgs []*ClientMockSyncDatabaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockSyncDatabaseExpectation specifies expectation struct of the Client.SyncDatabase
type ClientMockSyncDatabaseExpectation struct {
	mock      *ClientMock
	params    *ClientMockSyncDatabaseParams
	paramPtrs *ClientMockSyncDatabaseParamPtrs
	results   *ClientMockSyncDatabaseResults
	Counter   uint64
}

// ClientMockSyncDatabaseParams contains parameters of the Client.SyncDatabase
type ClientMockSyncDatabaseParams struct {
	ctx       context.Context
	serviceID string
	db        Database
}

// ClientMockSyncDatabaseParamPtrs contains pointers to parameters of the Client.SyncDatabase
type ClientMockSyncDatabaseParamPtrs struct {
	ctx       *context.Context
	serviceID *string
	db        *Database
}

// ClientMockSyncDatabaseResults contains results of the Client.SyncDatabase
type ClientMockSyncDatabaseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSyncDatabase *mClientMockSyncDatabase) Optional() *mClientMockSyncDatabase {
	mmSyncDatabase.optional = true
	return mmSyncDatabase
}

// Expect sets up expected params for Client.SyncDatabase
func (mmSyncDatabase *mClientMockSyncDatabase) Expect(ctx context.Context, serviceID string, db Database) *mClientMockSyncDatabase {
	if mmSyncDatabase.mock.funcSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Set")
	}

	if mmSyncDatabase.defaultExpectation == nil {
		mmSyncDatabase.defaultExpectation = &ClientMockSyncDatabaseExpectation{}
	}

	if mmSyncDatabase.defaultExpectation.paramPtrs != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by ExpectParams functions")
	}

	mmSyncDatabase.defaultExpectation.params = &ClientMockSyncDatabaseParams{ctx, serviceID, db}
	for _, e := range mmSyncDatabase.expectations {
		if minimock.Equal(e.params, mmSyncDatabase.defaultExpectation.params) {
			mmSyncDatabase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSyncDatabase.defaultExpectation.params)
		}
	}

	return mmSyncDatabase
}

// ExpectCtxParam1 sets up expected param ctx for Client.SyncDatabase
func (mmSyncDatabase *mClientMockSyncDatabase) ExpectCtxParam1(ctx context.Context) *mClientMockSyncDatabase {
	if mmSyncDatabase.mock.funcSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Set")
	}

	if mmSyncDatabase.defaultExpectation == nil {
		mmSyncDatabase.defaultExpectation = &ClientMockSyncDatabaseExpectation{}
	}

	if mmSyncDatabase.defaultExpectation.params != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Expect")
	}

	if mmSyncDatabase.defaultExpectation.paramPtrs == nil {
		mmSyncDatabase.defaultExpectation.paramPtrs = &ClientMockSyncDatabaseParamPtrs{}
	}
	mmSyncDatabase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSyncDatabase
}

// ExpectServiceIDParam2 sets up expected param serviceID for Client.SyncDatabase
func (mmSyncDatabase *mClientMockSyncDatabase) ExpectServiceIDParam2(serviceID string) *mClientMockSyncDatabase {
	if mmSyncDatabase.mock.funcSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Set")
	}

	if mmSyncDatabase.defaultExpectation == nil {
		mmSyncDatabase.defaultExpectation = &ClientMockSyncDatabaseExpectation{}
	}

	if mmSyncDatabase.defaultExpectation.params != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Expect")
	}

	if mmSyncDatabase.defaultExpectation.paramPtrs == nil {
		mmSyncDatabase.defaultExpectation.paramPtrs = &ClientMockSyncDatabaseParamPtrs{}
	}
	mmSyncDatabase.defaultExpectation.paramPtrs.serviceID = &serviceID

	return mmSyncDatabase
}

// ExpectDbParam3 sets up expected param db for Client.SyncDatabase
func (mmSyncDatabase *mClientMockSyncDatabase) ExpectDbParam3(db Database) *mClientMockSyncDatabase {
	if mmSyncDatabase.mock.funcSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Set")
	}

	if mmSyncDatabase.defaultExpectation == nil {
		mmSyncDatabase.defaultExpectation = &ClientMockSyncDatabaseExpectation{}
	}

	if mmSyncDatabase.defaultExpectation.params != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Expect")
	}

	if mmSyncDatabase.defaultExpectation.paramPtrs == nil {
		mmSyncDatabase.defaultExpectation.paramPtrs = &ClientMockSyncDatabaseParamPtrs{}
	}
	mmSyncDatabase.defaultExpectation.paramPtrs.db = &db

	return mmSyncDatabase
}

// Inspect accepts an inspector function that has same arguments as the Client.SyncDatabase
func (mmSyncDatabase *mClientMockSyncDatabase) Inspect(f func(ctx context.Context, serviceID string, db Database)) *mClientMockSyncDatabase {
	if mmSyncDatabase.mock.inspectFuncSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("Inspect function is already set for ClientMock.SyncDatabase")
	}

	mmSyncDatabase.mock.inspectFuncSyncDatabase = f

	return mmSyncDatabase
}

// Return sets up results that will be returned by Client.SyncDatabase
func (mmSyncDatabase *mClientMockSyncDatabase) Return(err error) *ClientMock {
	if mmSyncDatabase.mock.funcSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Set")
	}

	if mmSyncDatabase.defaultExpectation == nil {
		mmSyncDatabase.defaultExpectation = &ClientMockSyncDatabaseExpectation{mock: mmSyncDatabase.mock}
	}
	mmSyncDatabase.defaultExpectation.results = &ClientMockSyncDatabaseResults{err}
	return mmSyncDatabase.mock
}

// Set uses given function f to mock the Client.SyncDatabase method
func (mmSyncDatabase *mClientMockSyncDatabase) Set(f func(ctx context.Context, serviceID string, db Database) (err error)) *ClientMock {
	if mmSyncDatabase.defaultExpectation != nil {
		mmSyncDatabase.mock.t.Fatalf("Default expectation is already set for the Client.SyncDatabase method")
	}

	if len(mmSyncDatabase.expectations) > 0 {
		mmSyncDatabase.mock.t.Fatalf("Some expectations are already set for the Client.SyncDatabase method")
	}

	mmSyncDatabase.mock.funcSyncDatabase = f
	return mmSyncDatabase.mock
}

// When sets expectation for the Client.SyncDatabase which will trigger the result defined by the following
// Then helper
func (mmSyncDatabase *mClientMockSyncDatabase) When(ctx context.Context, serviceID string, db Database) *ClientMockSyncDatabaseExpectation {
	if mmSyncDatabase.mock.funcSyncDatabase != nil {
		mmSyncDatabase.mock.t.Fatalf("ClientMock.SyncDatabase mock is already set by Set")
	}

	expectation := &ClientMockSyncDatabaseExpectation{
		mock:   mmSyncDatabase.mock,
		params: &ClientMockSyncDatabaseParams{ctx, serviceID, db},
	}
	mmSyncDatabase.expectations = append(mmSyncDatabase.expectations, expectation)
	return expectation
}

// Then sets up Client.SyncDatabase return parameters for the expectation previously defined by the When method
func (e *ClientMockSyncDatabaseExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockSyncDatabaseResults{err}
	return e.mock
}

// Times sets number of times Client.SyncDatabase should be invoked
func (mmSyncDatabase *mClientMockSyncDatabase) Times(n uint64) *mClientMockSyncDatabase {
	if n == 0 {
		mmSyncDatabase.mock.t.Fatalf("Times of ClientMock.SyncDatabase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSyncDatabase.expectedInvocations, n)
	return mmSyncDatabase
}

func (mmSyncDatabase *mClientMockSyncDatabase) invocationsDone() bool {
	if len(mmSyncDatabase.expectations) == 0 && mmSyncDatabase.defaultExpectation == nil && mmSyncDatabase.mock.funcSyncDatabase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSyncDatabase.mock.afterSyncDatabaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSyncDatabase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SyncDatabase implements Client
func (mmSyncDatabase *ClientMock) SyncDatabase(ctx context.Context, serviceID string, db Database) (err error) {
	mm_atomic.AddUint64(&mmSyncDatabase.beforeSyncDatabaseCounter, 1)
	defer mm_atomic.AddUint64(&mmSyncDatabase.afterSyncDatabaseCounter, 1)

	if mmSyncDatabase.inspectFuncSyncDatabase != nil {
		mmSyncDatabase.inspectFuncSyncDatabase(ctx, serviceID, db)
	}

	mm_params := ClientMockSyncDatabaseParams{ctx, serviceID, db}

	// Record call args
	mmSyncDatabase.SyncDatabaseMock.mutex.Lock()
	mmSyncDatabase.SyncDatabaseMock.callArgs = append(mmSyncDatabase.SyncDatabaseMock.callArgs, &mm_params)
	mmSyncDatabase.SyncDatabaseMock.mutex.Unlock()

	for _, e := range mmSyncDatabase.SyncDatabaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSyncDatabase.SyncDatabaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSyncDatabase.SyncDatabaseMock.defaultExpectation.Counter, 1)
		mm_want := mmSyncDatabase.SyncDatabaseMock.defaultExpectation.params
		mm_want_ptrs := mmSyncDatabase.SyncDatabaseMock.defaultExpectation.paramPtrs

		mm_got := ClientMockSyncDatabaseParams{ctx, serviceID, db}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSyncDatabase.t.Errorf("ClientMock.SyncDatabase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceID != nil && !minimock.Equal(*mm_want_ptrs.serviceID, mm_got.serviceID) {
				mmSyncDatabase.t.Errorf("ClientMock.SyncDatabase got unexpected parameter serviceID, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceID, mm_got.serviceID, minimock.Diff(*mm_want_ptrs.serviceID, mm_got.serviceID))
			}

			if mm_want_ptrs.db != nil && !minimock.Equal(*mm_want_ptrs.db, mm_got.db) {
				mmSyncDatabase.t.Errorf("ClientMock.SyncDatabase got unexpected parameter db, want: %#v, got: %#v%s\n", *mm_want_ptrs.db, mm_got.db, minimock.Diff(*mm_want_ptrs.db, mm_got.db))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSyncDatabase.t.Errorf("ClientMock.SyncDatabase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSyncDatabase.SyncDatabaseMock.defaultExpectation.results
		if mm_results == nil {
			mmSyncDatabase.t.Fatal("No results are set for the ClientMock.SyncDatabase")
		}
		return (*mm_results).err
	}
	if mmSyncDatabase.funcSyncDatabase != nil {
		return mmSyncDatabase.funcSyncDatabase(ctx, serviceID, db)
	}
	mmSyncDatabase.t.Fatalf("Unexpected call to ClientMock.SyncDatabase. %v %v %v", ctx, serviceID, db)
	return
}

// SyncDatabaseAfterCounter returns a count of finished ClientMock.SyncDatabase invocations
func (mmSyncDatabase *ClientMock) SyncDatabaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSyncDatabase.afterSyncDatabaseCounter)
}

// SyncDatabaseBeforeCounter returns a count of ClientMock.SyncDatabase invocations
func (mmSyncDatabase *ClientMock) SyncDatabaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSyncDatabase.beforeSyncDatabaseCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.SyncDatabase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSyncDatabase *mClientMockSyncDatabase) Calls() []*ClientMockSyncDatabaseParams {
	mmSyncDatabase.mutex.RLock()

	argCopy := make([]*ClientMockSyncDatabaseParams, len(mmSyncDatabase.callArgs))
	copy(argCopy, mmSyncDatabase.callArgs)

	mmSyncDatabase.mutex.RUnlock()

	return argCopy
}

// MinimockSyncDatabaseDone returns true if the count of the SyncDatabase invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSyncDatabaseDone() bool {
	if m.SyncDatabaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SyncDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SyncDatabaseMock.invocationsDone()
}

// MinimockSyncDatabaseInspect logs each unmet expectation
func (m *ClientMock) MinimockSyncDatabaseInspect() {
	for _, e := range m.SyncDatabaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.SyncDatabase with params: %#v", *e.params)
		}
	}

	afterSyncDatabaseCounter := mm_atomic.LoadUint64(&m.afterSyncDatabaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SyncDatabaseMock.defaultExpectation != nil && afterSyncDatabaseCounter < 1 {
		if m.SyncDatabaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.SyncDatabase")
		} else {
			m.t.Errorf("Expected call to ClientMock.SyncDatabase with params: %#v", *m.SyncDatabaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSyncDatabase != nil && afterSyncDatabaseCounter < 1 {
		m.t.Error("Expected call to ClientMock.SyncDatabase")
	}

	if !m.SyncDatabaseMock.invocationsDone() && afterSyncDatabaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.SyncDatabase but found %d calls",
			mm_atomic.LoadUint64(&m.SyncDatabaseMock.expectedInvocations), afterSyncDatabaseCounter)
	}
}

type mClientMockUpdateBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateBackupConfigurationExpectation
	expectations       []*ClientMockUpdateBackupConfigurationExpectation

	callArgs []*ClientMockUpdateBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateBackupConfigurationExpectation specifies expectation struct of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateBackupConfigurationParams
	paramPtrs *ClientMockUpdateBackupConfigurationParamPtrs
	results   *ClientMockUpdateBackupConfigurationResults
	Counter   uint64
}

// ClientMockUpdateBackupConfigurationParams contains parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
	b         BackupConfiguration
}

// ClientMockUpdateBackupConfigurationParamPtrs contains pointers to parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	b         *BackupConfiguration
}

// ClientMockUpdateBackupConfigurationResults contains results of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Optional() *mClientMockUpdateBackupConfiguration {
	mmUpdateBackupConfiguration.optional = true
	return mmUpdateBackupConfiguration
}

// Expect sets up expected params for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Expect(ctx context.Context, serviceId string, b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmUpdateBackupConfiguration.defaultExpectation.params = &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}
	for _, e := range mmUpdateBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmUpdateBackupConfiguration.defaultExpectation.params) {
			mmUpdateBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmUpdateBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateBackupConfiguration
}

// ExpectBParam3 sets up expected param b for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectBParam3(b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.b = &b

	return mmUpdateBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string, b BackupConfiguration)) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateBackupConfiguration")
	}

	mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration = f

	return mmUpdateBackupConfiguration
}

// Return sets up results that will be returned by Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{mock: mmUpdateBackupConfiguration.mock}
	}
	mmUpdateBackupConfiguration.defaultExpectation.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return mmUpdateBackupConfiguration.mock
}

// Set uses given function f to mock the Client.UpdateBackupConfiguration method
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Set(f func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmUpdateBackupConfiguration.defaultExpectation != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.UpdateBackupConfiguration method")
	}

	if len(mmUpdateBackupConfiguration.expectations) > 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.UpdateBackupConfiguration method")
	}

	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration = f
	return mmUpdateBackupConfiguration.mock
}

// When sets expectation for the Client.UpdateBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) When(ctx context.Context, serviceId string, b BackupConfiguration) *ClientMockUpdateBackupConfigurationExpectation {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockUpdateBackupConfigurationExpectation{
		mock:   mmUpdateBackupConfiguration.mock,
		params: &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b},
	}
	mmUpdateBackupConfiguration.expectations = append(mmUpdateBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateBackupConfiguration should be invoked
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Times(n uint64) *mClientMockUpdateBackupConfiguration {
	if n == 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Times of ClientMock.UpdateBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateBackupConfiguration.expectedInvocations, n)
	return mmUpdateBackupConfiguration
}

func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) invocationsDone() bool {
	if len(mmUpdateBackupConfiguration.expectations) == 0 && mmUpdateBackupConfiguration.defaultExpectation == nil && mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.mock.afterUpdateBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateBackupConfiguration implements Client
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfiguration(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter, 1)

	if mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration(ctx, serviceId, b)
	}

	mm_params := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

	// Record call args
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Lock()
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs = append(mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs, &mm_params)
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter b, want: %#v, got: %#v%s\n", *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBackupConfiguration.t.Fatal("No results are set for the ClientMock.UpdateBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmUpdateBackupConfiguration.funcUpdateBackupConfiguration != nil {
		return mmUpdateBackupConfiguration.funcUpdateBackupConfiguration(ctx, serviceId, b)
	}
	mmUpdateBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.UpdateBackupConfiguration. %v %v %v", ctx, serviceId, b)
	return
}

// UpdateBackupConfigurationAfterCounter returns a count of finished ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter)
}

// UpdateBackupConfigurationBeforeCounter returns a count of ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Calls() []*ClientMockUpdateBackupConfigurationParams {
	mmUpdateBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockUpdateBackupConfigurationParams, len(mmUpdateBackupConfiguration.callArgs))
	copy(argCopy, mmUpdateBackupConfiguration.callArgs)

	mmUpdateBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBackupConfigurationDone returns true if the count of the UpdateBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateBackupConfigurationDone() bool {
	if m.UpdateBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateBackupConfigurationMock.invocationsDone()
}

// MinimockUpdateBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateBackupConfigurationInspect() {
	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration with params: %#v", *e.params)
		}
	}

	afterUpdateBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterUpdateBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBackupConfigurationMock.defaultExpectation != nil && afterUpdateBackupConfigurationCounter < 1 {
		if m.UpdateBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateBackupConfiguration")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration with params: %#v", *m.UpdateBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBackupConfiguration != nil && afterUpdateBackupConfigurationCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateBackupConfiguration")
	}

	if !m.UpdateBackupConfigurationMock.invocationsDone() && afterUpdateBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateBackupConfiguration but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateBackupConfigurationMock.expectedInvocations), afterUpdateBackupConfigurationCounter)
	}
}

type mClientMockUpdateClickPipe struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateClickPipeExpectation
	expectations       []*ClientMockUpdateClickPipeExpectation

	callArgs []*ClientMockUpdateClickPipeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateClickPipeExpectation specifies expectation struct of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateClickPipeParams
	paramPtrs *ClientMockUpdateClickPipeParamPtrs
	results   *ClientMockUpdateClickPipeResults
	Counter   uint64
}

// ClientMockUpdateClickPipeParams contains parameters of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeParams struct {
	ctx         context.Context
	serviceId   string
	clickPipeId string
	request     ClickPipeUpdate
}

// ClientMockUpdateClickPipeParamPtrs contains pointers to parameters of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeParamPtrs struct {
	ctx         *context.Context
	serviceId   *string
	clickPipeId *string
	request     *ClickPipeUpdate
}

// ClientMockUpdateClickPipeResults contains results of the Client.UpdateClickPipe
type ClientMockUpdateClickPipeResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Optional() *mClientMockUpdateClickPipe {
	mmUpdateClickPipe.optional = true
	return mmUpdateClickPipe
}

// Expect sets up expected params for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Expect(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by ExpectParams functions")
	}

	mmUpdateClickPipe.defaultExpectation.params = &ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request}
	for _, e := range mmUpdateClickPipe.expectations {
		if minimock.Equal(e.params, mmUpdateClickPipe.defaultExpectation.params) {
			mmUpdateClickPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateClickPipe.defaultExpectation.params)
		}
	}

	return mmUpdateClickPipe
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateClickPipe
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateClickPipe
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmUpdateClickPipe
}

// ExpectRequestParam4 sets up expected param request for Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) ExpectRequestParam4(request ClickPipeUpdate) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{}
	}

	if mmUpdateClickPipe.defaultExpectation.params != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Expect")
	}

	if mmUpdateClickPipe.defaultExpectation.paramPtrs == nil {
		mmUpdateClickPipe.defaultExpectation.paramPtrs = &ClientMockUpdateClickPipeParamPtrs{}
	}
	mmUpdateClickPipe.defaultExpectation.paramPtrs.request = &request

	return mmUpdateClickPipe
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate)) *mClientMockUpdateClickPipe {
	if mmUpdateClickPipe.mock.inspectFuncUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateClickPipe")
	}

	mmUpdateClickPipe.mock.inspectFuncUpdateClickPipe = f

	return mmUpdateClickPipe
}

// Return sets up results that will be returned by Client.UpdateClickPipe
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	if mmUpdateClickPipe.defaultExpectation == nil {
		mmUpdateClickPipe.defaultExpectation = &ClientMockUpdateClickPipeExpectation{mock: mmUpdateClickPipe.mock}
	}
	mmUpdateClickPipe.defaultExpectation.results = &ClientMockUpdateClickPipeResults{cp1, err}
	return mmUpdateClickPipe.mock
}

// Set uses given function f to mock the Client.UpdateClickPipe method
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Set(f func(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmUpdateClickPipe.defaultExpectation != nil {
		mmUpdateClickPipe.mock.t.Fatalf("Default expectation is already set for the Client.UpdateClickPipe method")
	}

	if len(mmUpdateClickPipe.expectations) > 0 {
		mmUpdateClickPipe.mock.t.Fatalf("Some expectations are already set for the Client.UpdateClickPipe method")
	}

	mmUpdateClickPipe.mock.funcUpdateClickPipe = f
	return mmUpdateClickPipe.mock
}

// When sets expectation for the Client.UpdateClickPipe which will trigger the result defined by the following
// Then helper
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) When(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) *ClientMockUpdateClickPipeExpectation {
	if mmUpdateClickPipe.mock.funcUpdateClickPipe != nil {
		mmUpdateClickPipe.mock.t.Fatalf("ClientMock.UpdateClickPipe mock is already set by Set")
	}

	expectation := &ClientMockUpdateClickPipeExpectation{
		mock:   mmUpdateClickPipe.mock,
		params: &ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request},
	}
	mmUpdateClickPipe.expectations = append(mmUpdateClickPipe.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateClickPipe return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateClickPipeExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockUpdateClickPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateClickPipe should be invoked
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Times(n uint64) *mClientMockUpdateClickPipe {
	if n == 0 {
		mmUpdateClickPipe.mock.t.Fatalf("Times of ClientMock.UpdateClickPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateClickPipe.expectedInvocations, n)
	return mmUpdateClickPipe
}

func (mmUpdateClickPipe *mClientMockUpdateClickPipe) invocationsDone() bool {
	if len(mmUpdateClickPipe.expectations) == 0 && mmUpdateClickPipe.defaultExpectation == nil && mmUpdateClickPipe.mock.funcUpdateClickPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateClickPipe.mock.afterUpdateClickPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateClickPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateClickPipe implements Client
func (mmUpdateClickPipe *ClientMock) UpdateClickPipe(ctx context.Context, serviceId string, clickPipeId string, request ClickPipeUpdate) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmUpdateClickPipe.beforeUpdateClickPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateClickPipe.afterUpdateClickPipeCounter, 1)

	if mmUpdateClickPipe.inspectFuncUpdateClickPipe != nil {
		mmUpdateClickPipe.inspectFuncUpdateClickPipe(ctx, serviceId, clickPipeId, request)
	}

	mm_params := ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request}

	// Record call args
	mmUpdateClickPipe.UpdateClickPipeMock.mutex.Lock()
	mmUpdateClickPipe.UpdateClickPipeMock.callArgs = append(mmUpdateClickPipe.UpdateClickPipeMock.callArgs, &mm_params)
	mmUpdateClickPipe.UpdateClickPipeMock.mutex.Unlock()

	for _, e := range mmUpdateClickPipe.UpdateClickPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateClickPipeParams{ctx, serviceId, clickPipeId, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameter request, want: %#v, got: %#v%s\n", *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateClickPipe.t.Errorf("ClientMock.UpdateClickPipe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateClickPipe.UpdateClickPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateClickPipe.t.Fatal("No results are set for the ClientMock.UpdateClickPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpdateClickPipe.funcUpdateClickPipe != nil {
		return mmUpdateClickPipe.funcUpdateClickPipe(ctx, serviceId, clickPipeId, request)
	}
	mmUpdateClickPipe.t.Fatalf("Unexpected call to ClientMock.UpdateClickPipe. %v %v %v %v", ctx, serviceId, clickPipeId, request)
	return
}

// UpdateClickPipeAfterCounter returns a count of finished ClientMock.UpdateClickPipe invocations
func (mmUpdateClickPipe *ClientMock) UpdateClickPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClickPipe.afterUpdateClickPipeCounter)
}

// UpdateClickPipeBeforeCounter returns a count of ClientMock.UpdateClickPipe invocations
func (mmUpdateClickPipe *ClientMock) UpdateClickPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClickPipe.beforeUpdateClickPipeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateClickPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateClickPipe *mClientMockUpdateClickPipe) Calls() []*ClientMockUpdateClickPipeParams {
	mmUpdateClickPipe.mutex.RLock()

	argCopy := make([]*ClientMockUpdateClickPipeParams, len(mmUpdateClickPipe.callArgs))
	copy(argCopy, mmUpdateClickPipe.callArgs)

	mmUpdateClickPipe.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateClickPipeDone returns true if the count of the UpdateClickPipe invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateClickPipeDone() bool {
	if m.UpdateClickPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateClickPipeMock.invocationsDone()
}

// MinimockUpdateClickPipeInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateClickPipeInspect() {
	for _, e := range m.UpdateClickPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateClickPipe with params: %#v", *e.params)
		}
	}

	afterUpdateClickPipeCounter := mm_atomic.LoadUint64(&m.afterUpdateClickPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClickPipeMock.defaultExpectation != nil && afterUpdateClickPipeCounter < 1 {
		if m.UpdateClickPipeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateClickPipe")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateClickPipe with params: %#v", *m.UpdateClickPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClickPipe != nil && afterUpdateClickPipeCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateClickPipe")
	}

	if !m.UpdateClickPipeMock.invocationsDone() && afterUpdateClickPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateClickPipe but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateClickPipeMock.expectedInvocations), afterUpdateClickPipeCounter)
	}
}

type mClientMockUpdateOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockUpdateOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockUpdateOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateOrganizationPrivateEndpointsParams
	paramPtrs *ClientMockUpdateOrganizationPrivateEndpointsParamPtrs
	results   *ClientMockUpdateOrganizationPrivateEndpointsResults
	Counter   uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsParams contains parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParams struct {
	ctx       context.Context
	orgUpdate OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	orgUpdate *OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsResults contains results of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Optional() *mClientMockUpdateOrganizationPrivateEndpoints {
	mmUpdateOrganizationPrivateEndpoints.optional = true
	return mmUpdateOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Expect(ctx context.Context, orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}
	for _, e := range mmUpdateOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectOrgUpdateParam2 sets up expected param orgUpdate for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectOrgUpdateParam2(orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.orgUpdate = &orgUpdate

	return mmUpdateOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context, orgUpdate OrganizationUpdate)) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints = f

	return mmUpdateOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{mock: mmUpdateOrganizationPrivateEndpoints.mock}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.UpdateOrganizationPrivateEndpoints method
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Set(f func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	if len(mmUpdateOrganizationPrivateEndpoints.expectations) > 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints = f
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.UpdateOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) When(ctx context.Context, orgUpdate OrganizationUpdate) *ClientMockUpdateOrganizationPrivateEndpointsExpectation {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockUpdateOrganizationPrivateEndpointsExpectation{
		mock:   mmUpdateOrganizationPrivateEndpoints.mock,
		params: &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate},
	}
	mmUpdateOrganizationPrivateEndpoints.expectations = append(mmUpdateOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.UpdateOrganizationPrivateEndpoints should be invoked
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Times(n uint64) *mClientMockUpdateOrganizationPrivateEndpoints {
	if n == 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.UpdateOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations, n)
	return mmUpdateOrganizationPrivateEndpoints
}

func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmUpdateOrganizationPrivateEndpoints.expectations) == 0 && mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil && mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.mock.afterUpdateOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrganizationPrivateEndpoints implements Client
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpoints(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter, 1)

	if mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}

	mm_params := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

	// Record call args
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Lock()
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs = append(mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orgUpdate != nil && !minimock.Equal(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter orgUpdate, want: %#v, got: %#v%s\n", *mm_want_ptrs.orgUpdate, mm_got.orgUpdate, minimock.Diff(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.UpdateOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints != nil {
		return mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}
	mmUpdateOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.UpdateOrganizationPrivateEndpoints. %v %v", ctx, orgUpdate)
	return
}

// UpdateOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter)
}

// UpdateOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Calls() []*ClientMockUpdateOrganizationPrivateEndpointsParams {
	mmUpdateOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockUpdateOrganizationPrivateEndpointsParams, len(mmUpdateOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmUpdateOrganizationPrivateEndpoints.callArgs)

	mmUpdateOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrganizationPrivateEndpointsDone returns true if the count of the UpdateOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsDone() bool {
	if m.UpdateOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockUpdateOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsInspect() {
	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterUpdateOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterUpdateOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints with params: %#v", *m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrganizationPrivateEndpoints != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	if !m.UpdateOrganizationPrivateEndpointsMock.invocationsDone() && afterUpdateOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateOrganizationPrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrganizationPrivateEndpointsMock.expectedInvocations), afterUpdateOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockUpdateReplicaScaling struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateReplicaScalingExpectation
	expectations       []*ClientMockUpdateReplicaScalingExpectation

	callArgs []*ClientMockUpdateReplicaScalingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateReplicaScalingExpectation specifies expectation struct of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateReplicaScalingParams
	paramPtrs *ClientMockUpdateReplicaScalingParamPtrs
	results   *ClientMockUpdateReplicaScalingResults
	Counter   uint64
}

// ClientMockUpdateReplicaScalingParams contains parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParams struct {
	ctx       context.Context
	serviceId string
	s         ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingParamPtrs contains pointers to parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingResults contains results of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Optional() *mClientMockUpdateReplicaScaling {
	mmUpdateReplicaScaling.optional = true
	return mmUpdateReplicaScaling
}

// Expect sets up expected params for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Expect(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by ExpectParams functions")
	}

	mmUpdateReplicaScaling.defaultExpectation.params = &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}
	for _, e := range mmUpdateReplicaScaling.expectations {
		if minimock.Equal(e.params, mmUpdateReplicaScaling.defaultExpectation.params) {
			mmUpdateReplicaScaling.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReplicaScaling.defaultExpectation.params)
		}
	}

	return mmUpdateReplicaScaling
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateReplicaScaling
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateReplicaScaling
}

// ExpectSParam3 sets up expected param s for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectSParam3(s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.s = &s

	return mmUpdateReplicaScaling
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Inspect(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateReplicaScaling")
	}

	mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling = f

	return mmUpdateReplicaScaling
}

// Return sets up results that will be returned by Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{mock: mmUpdateReplicaScaling.mock}
	}
	mmUpdateReplicaScaling.defaultExpectation.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return mmUpdateReplicaScaling.mock
}

// Set uses given function f to mock the Client.UpdateReplicaScaling method
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Set(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateReplicaScaling.defaultExpectation != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Default expectation is already set for the Client.UpdateReplicaScaling method")
	}

	if len(mmUpdateReplicaScaling.expectations) > 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Some expectations are already set for the Client.UpdateReplicaScaling method")
	}

	mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling = f
	return mmUpdateReplicaScaling.mock
}

// When sets expectation for the Client.UpdateReplicaScaling which will trigger the result defined by the following
// Then helper
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) When(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *ClientMockUpdateReplicaScalingExpectation {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	expectation := &ClientMockUpdateReplicaScalingExpectation{
		mock:   mmUpdateReplicaScaling.mock,
		params: &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s},
	}
	mmUpdateReplicaScaling.expectations = append(mmUpdateReplicaScaling.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateReplicaScaling return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateReplicaScalingExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateReplicaScaling should be invoked
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Times(n uint64) *mClientMockUpdateReplicaScaling {
	if n == 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Times of ClientMock.UpdateReplicaScaling mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReplicaScaling.expectedInvocations, n)
	return mmUpdateReplicaScaling
}

func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) invocationsDone() bool {
	if len(mmUpdateReplicaScaling.expectations) == 0 && mmUpdateReplicaScaling.defaultExpectation == nil && mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.mock.afterUpdateReplicaScalingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReplicaScaling implements Client
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScaling(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter, 1)

	if mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

	// Record call args
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Lock()
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs = append(mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs, &mm_params)
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Unlock()

	for _, e := range mmUpdateReplicaScaling.UpdateReplicaScalingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReplicaScaling.t.Fatal("No results are set for the ClientMock.UpdateReplicaScaling")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateReplicaScaling.funcUpdateReplicaScaling != nil {
		return mmUpdateReplicaScaling.funcUpdateReplicaScaling(ctx, serviceId, s)
	}
	mmUpdateReplicaScaling.t.Fatalf("Unexpected call to ClientMock.UpdateReplicaScaling. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateReplicaScalingAfterCounter returns a count of finished ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter)
}

// UpdateReplicaScalingBeforeCounter returns a count of ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateReplicaScaling.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Calls() []*ClientMockUpdateReplicaScalingParams {
	mmUpdateReplicaScaling.mutex.RLock()

	argCopy := make([]*ClientMockUpdateReplicaScalingParams, len(mmUpdateReplicaScaling.callArgs))
	copy(argCopy, mmUpdateReplicaScaling.callArgs)

	mmUpdateReplicaScaling.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReplicaScalingDone returns true if the count of the UpdateReplicaScaling invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateReplicaScalingDone() bool {
	if m.UpdateReplicaScalingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReplicaScalingMock.invocationsDone()
}

// MinimockUpdateReplicaScalingInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateReplicaScalingInspect() {
	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling with params: %#v", *e.params)
		}
	}

	afterUpdateReplicaScalingCounter := mm_atomic.LoadUint64(&m.afterUpdateReplicaScalingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReplicaScalingMock.defaultExpectation != nil && afterUpdateReplicaScalingCounter < 1 {
		if m.UpdateReplicaScalingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateReplicaScaling")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling with params: %#v", *m.UpdateReplicaScalingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReplicaScaling != nil && afterUpdateReplicaScalingCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateReplicaScaling")
	}

	if !m.UpdateReplicaScalingMock.invocationsDone() && afterUpdateReplicaScalingCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateReplicaScaling but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReplicaScalingMock.expectedInvocations), afterUpdateReplicaScalingCounter)
	}
}

type mClientMockUpdateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServiceExpectation
	expectations       []*ClientMockUpdateServiceExpectation

	callArgs []*ClientMockUpdateServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateServiceExpectation specifies expectation struct of the Client.UpdateService
type ClientMockUpdateServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateServiceParams
	paramPtrs *ClientMockUpdateServiceParamPtrs
	results   *ClientMockUpdateServiceResults
	Counter   uint64
}

// ClientMockUpdateServiceParams contains parameters of the Client.UpdateService
type ClientMockUpdateServiceParams struct {
	ctx       context.Context
	serviceId string
	s         ServiceUpdate
}

// ClientMockUpdateServiceParamPtrs contains pointers to parameters of the Client.UpdateService
type ClientMockUpdateServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ServiceUpdate
}

// ClientMockUpdateServiceResults contains results of the Client.UpdateService
type ClientMockUpdateServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateService *mClientMockUpdateService) Optional() *mClientMockUpdateService {
	mmUpdateService.optional = true
	return mmUpdateService
}

// Expect sets up expected params for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Expect(ctx context.Context, serviceId string, s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.paramPtrs != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by ExpectParams functions")
	}

	mmUpdateService.defaultExpectation.params = &ClientMockUpdateServiceParams{ctx, serviceId, s}
	for _, e := range mmUpdateService.expectations {
		if minimock.Equal(e.params, mmUpdateService.defaultExpectation.params) {
			mmUpdateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateService.defaultExpectation.params)
		}
	}

	return mmUpdateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateService
}

// ExpectSParam3 sets up expected param s for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectSParam3(s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.s = &s

	return mmUpdateService
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Inspect(f func(ctx context.Context, serviceId string, s ServiceUpdate)) *mClientMockUpdateService {
	if mmUpdateService.mock.inspectFuncUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateService")
	}

	mmUpdateService.mock.inspectFuncUpdateService = f

	return mmUpdateService
}

// Return sets up results that will be returned by Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{mock: mmUpdateService.mock}
	}
	mmUpdateService.defaultExpectation.results = &ClientMockUpdateServiceResults{sp1, err}
	return mmUpdateService.mock
}

// Set uses given function f to mock the Client.UpdateService method
func (mmUpdateService *mClientMockUpdateService) Set(f func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateService.defaultExpectation != nil {
		mmUpdateService.mock.t.Fatalf("Default expectation is already set for the Client.UpdateService method")
	}

	if len(mmUpdateService.expectations) > 0 {
		mmUpdateService.mock.t.Fatalf("Some expectations are already set for the Client.UpdateService method")
	}

	mmUpdateService.mock.funcUpdateService = f
	return mmUpdateService.mock
}

// When sets expectation for the Client.UpdateService which will trigger the result defined by the following
// Then helper
func (mmUpdateService *mClientMockUpdateService) When(ctx context.Context, serviceId string, s ServiceUpdate) *ClientMockUpdateServiceExpectation {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	expectation := &ClientMockUpdateServiceExpectation{
		mock:   mmUpdateService.mock,
		params: &ClientMockUpdateServiceParams{ctx, serviceId, s},
	}
	mmUpdateService.expectations = append(mmUpdateService.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateService return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateService should be invoked
func (mmUpdateService *mClientMockUpdateService) Times(n uint64) *mClientMockUpdateService {
	if n == 0 {
		mmUpdateService.mock.t.Fatalf("Times of ClientMock.UpdateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateService.expectedInvocations, n)
	return mmUpdateService
}

func (mmUpdateService *mClientMockUpdateService) invocationsDone() bool {
	if len(mmUpdateService.expectations) == 0 && mmUpdateService.defaultExpectation == nil && mmUpdateService.mock.funcUpdateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateService.mock.afterUpdateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateService implements Client
func (mmUpdateService *ClientMock) UpdateService(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateService.beforeUpdateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateService.afterUpdateServiceCounter, 1)

	if mmUpdateService.inspectFuncUpdateService != nil {
		mmUpdateService.inspectFuncUpdateService(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateServiceParams{ctx, serviceId, s}

	// Record call args
	mmUpdateService.UpdateServiceMock.mutex.Lock()
	mmUpdateService.UpdateServiceMock.callArgs = append(mmUpdateService.UpdateServiceMock.callArgs, &mm_params)
	mmUpdateService.UpdateServiceMock.mutex.Unlock()

	for _, e := range mmUpdateService.UpdateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateService.UpdateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateService.UpdateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateService.UpdateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateService.UpdateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServiceParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateService.UpdateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateService.t.Fatal("No results are set for the ClientMock.UpdateService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateService.funcUpdateService != nil {
		return mmUpdateService.funcUpdateService(ctx, serviceId, s)
	}
	mmUpdateService.t.Fatalf("Unexpected call to ClientMock.UpdateService. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateServiceAfterCounter returns a count of finished ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.afterUpdateServiceCounter)
}

// UpdateServiceBeforeCounter returns a count of ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.beforeUpdateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateService *mClientMockUpdateService) Calls() []*ClientMockUpdateServiceParams {
	mmUpdateService.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServiceParams, len(mmUpdateService.callArgs))
	copy(argCopy, mmUpdateService.callArgs)

	mmUpdateService.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServiceDone returns true if the count of the UpdateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServiceDone() bool {
	if m.UpdateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServiceMock.invocationsDone()
}

// MinimockUpdateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServiceInspect() {
	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateService with params: %#v", *e.params)
		}
	}

	afterUpdateServiceCounter := mm_atomic.LoadUint64(&m.afterUpdateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServiceMock.defaultExpectation != nil && afterUpdateServiceCounter < 1 {
		if m.UpdateServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateService")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateService with params: %#v", *m.UpdateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateService != nil && afterUpdateServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateService")
	}

	if !m.UpdateServiceMock.invocationsDone() && afterUpdateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateService but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServiceMock.expectedInvocations), afterUpdateServiceCounter)
	}
}

type mClientMockUpdateServicePassword struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServicePasswordExpectation
	expectations       []*ClientMockUpdateServicePasswordExpectation

	callArgs []*ClientMockUpdateServicePasswordParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateServicePasswordExpectation specifies expectation struct of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateServicePasswordParams
	paramPtrs *ClientMockUpdateServicePasswordParamPtrs
	results   *ClientMockUpdateServicePasswordResults
	Counter   uint64
}

// ClientMockUpdateServicePasswordParams contains parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParams struct {
	ctx       context.Context
	serviceId string
	u         ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordParamPtrs contains pointers to parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	u         *ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordResults contains results of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordResults struct {
	sp1 *ServicePasswordUpdateResult
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Optional() *mClientMockUpdateServicePassword {
	mmUpdateServicePassword.optional = true
	return mmUpdateServicePassword
}

// Expect sets up expected params for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Expect(ctx context.Context, serviceId string, u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by ExpectParams functions")
	}

	mmUpdateServicePassword.defaultExpectation.params = &ClientMockUpdateServicePasswordParams{ctx, serviceId, u}
	for _, e := range mmUpdateServicePassword.expectations {
		if minimock.Equal(e.params, mmUpdateServicePassword.defaultExpectation.params) {
			mmUpdateServicePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateServicePassword.defaultExpectation.params)
		}
	}

	return mmUpdateServicePassword
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateServicePassword
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateServicePassword
}

// ExpectUParam3 sets up expected param u for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectUParam3(u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.u = &u

	return mmUpdateServicePassword
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Inspect(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate)) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateServicePassword")
	}

	mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword = f

	return mmUpdateServicePassword
}

// Return sets up results that will be returned by Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Return(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{mock: mmUpdateServicePassword.mock}
	}
	mmUpdateServicePassword.defaultExpectation.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return mmUpdateServicePassword.mock
}

// Set uses given function f to mock the Client.UpdateServicePassword method
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Set(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)) *ClientMock {
	if mmUpdateServicePassword.defaultExpectation != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Default expectation is already set for the Client.UpdateServicePassword method")
	}

	if len(mmUpdateServicePassword.expectations) > 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Some expectations are already set for the Client.UpdateServicePassword method")
	}

	mmUpdateServicePassword.mock.funcUpdateServicePassword = f
	return mmUpdateServicePassword.mock
}

// When sets expectation for the Client.UpdateServicePassword which will trigger the result defined by the following
// Then helper
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) When(ctx context.Context, serviceId string, u ServicePasswordUpdate) *ClientMockUpdateServicePasswordExpectation {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	expectation := &ClientMockUpdateServicePasswordExpectation{
		mock:   mmUpdateServicePassword.mock,
		params: &ClientMockUpdateServicePasswordParams{ctx, serviceId, u},
	}
	mmUpdateServicePassword.expectations = append(mmUpdateServicePassword.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateServicePassword return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServicePasswordExpectation) Then(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	e.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateServicePassword should be invoked
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Times(n uint64) *mClientMockUpdateServicePassword {
	if n == 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Times of ClientMock.UpdateServicePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateServicePassword.expectedInvocations, n)
	return mmUpdateServicePassword
}

func (mmUpdateServicePassword *mClientMockUpdateServicePassword) invocationsDone() bool {
	if len(mmUpdateServicePassword.expectations) == 0 && mmUpdateServicePassword.defaultExpectation == nil && mmUpdateServicePassword.mock.funcUpdateServicePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.mock.afterUpdateServicePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateServicePassword implements Client
func (mmUpdateServicePassword *ClientMock) UpdateServicePassword(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error) {
	mm_atomic.AddUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter, 1)

	if mmUpdateServicePassword.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.inspectFuncUpdateServicePassword(ctx, serviceId, u)
	}

	mm_params := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

	// Record call args
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Lock()
	mmUpdateServicePassword.UpdateServicePasswordMock.callArgs = append(mmUpdateServicePassword.UpdateServicePasswordMock.callArgs, &mm_params)
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Unlock()

	for _, e := range mmUpdateServicePassword.UpdateServicePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.u != nil && !minimock.Equal(*mm_want_ptrs.u, mm_got.u) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter u, want: %#v, got: %#v%s\n", *mm_want_ptrs.u, mm_got.u, minimock.Diff(*mm_want_ptrs.u, mm_got.u))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateServicePassword.t.Fatal("No results are set for the ClientMock.UpdateServicePassword")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateServicePassword.funcUpdateServicePassword != nil {
		return mmUpdateServicePassword.funcUpdateServicePassword(ctx, serviceId, u)
	}
	mmUpdateServicePassword.t.Fatalf("Unexpected call to ClientMock.UpdateServicePassword. %v %v %v", ctx, serviceId, u)
	return
}

// UpdateServicePasswordAfterCounter returns a count of finished ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter)
}

// UpdateServicePasswordBeforeCounter returns a count of ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateServicePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Calls() []*ClientMockUpdateServicePasswordParams {
	mmUpdateServicePassword.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServicePasswordParams, len(mmUpdateServicePassword.callArgs))
	copy(argCopy, mmUpdateServicePassword.callArgs)

	mmUpdateServicePassword.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServicePasswordDone returns true if the count of the UpdateServicePassword invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServicePasswordDone() bool {
	if m.UpdateServicePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServicePasswordMock.invocationsDone()
}

// MinimockUpdateServicePasswordInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServicePasswordInspect() {
	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword with params: %#v", *e.params)
		}
	}

	afterUpdateServicePasswordCounter := mm_atomic.LoadUint64(&m.afterUpdateServicePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServicePasswordMock.defaultExpectation != nil && afterUpdateServicePasswordCounter < 1 {
		if m.UpdateServicePasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateServicePassword")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword with params: %#v", *m.UpdateServicePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateServicePassword != nil && afterUpdateServicePasswordCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateServicePassword")
	}

	if !m.UpdateServicePasswordMock.invocationsDone() && afterUpdateServicePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateServicePassword but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServicePasswordMock.expectedInvocations), afterUpdateServicePasswordCounter)
	}
}

type mClientMockWaitForClickPipeState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForClickPipeStateExpectation
	expectations       []*ClientMockWaitForClickPipeStateExpectation

	callArgs []*ClientMockWaitForClickPipeStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockWaitForClickPipeStateExpectation specifies expectation struct of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockWaitForClickPipeStateParams
	paramPtrs *ClientMockWaitForClickPipeStateParamPtrs
	results   *ClientMockWaitForClickPipeStateResults
	Counter   uint64
}

// ClientMockWaitForClickPipeStateParams contains parameters of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateParams struct {
	ctx            context.Context
	serviceId      string
	clickPipeId    string
	stateChecker   func(string) bool
	maxWaitSeconds uint64
}

// ClientMockWaitForClickPipeStateParamPtrs contains pointers to parameters of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	clickPipeId    *string
	stateChecker   *func(string) bool
	maxWaitSeconds *uint64
}

// ClientMockWaitForClickPipeStateResults contains results of the Client.WaitForClickPipeState
type ClientMockWaitForClickPipeStateResults struct {
	cp1 *ClickPipe
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Optional() *mClientMockWaitForClickPipeState {
	mmWaitForClickPipeState.optional = true
	return mmWaitForClickPipeState
}

// Expect sets up expected params for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Expect(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by ExpectParams functions")
	}

	mmWaitForClickPipeState.defaultExpectation.params = &ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}
	for _, e := range mmWaitForClickPipeState.expectations {
		if minimock.Equal(e.params, mmWaitForClickPipeState.defaultExpectation.params) {
			mmWaitForClickPipeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForClickPipeState.defaultExpectation.params)
		}
	}

	return mmWaitForClickPipeState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWaitForClickPipeState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmWaitForClickPipeState
}

// ExpectClickPipeIdParam3 sets up expected param clickPipeId for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectClickPipeIdParam3(clickPipeId string) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.clickPipeId = &clickPipeId

	return mmWaitForClickPipeState
}

// ExpectStateCheckerParam4 sets up expected param stateChecker for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectStateCheckerParam4(stateChecker func(string) bool) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.stateChecker = &stateChecker

	return mmWaitForClickPipeState
}

// ExpectMaxWaitSecondsParam5 sets up expected param maxWaitSeconds for Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) ExpectMaxWaitSecondsParam5(maxWaitSeconds uint64) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{}
	}

	if mmWaitForClickPipeState.defaultExpectation.params != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Expect")
	}

	if mmWaitForClickPipeState.defaultExpectation.paramPtrs == nil {
		mmWaitForClickPipeState.defaultExpectation.paramPtrs = &ClientMockWaitForClickPipeStateParamPtrs{}
	}
	mmWaitForClickPipeState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds

	return mmWaitForClickPipeState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Inspect(f func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64)) *mClientMockWaitForClickPipeState {
	if mmWaitForClickPipeState.mock.inspectFuncWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForClickPipeState")
	}

	mmWaitForClickPipeState.mock.inspectFuncWaitForClickPipeState = f

	return mmWaitForClickPipeState
}

// Return sets up results that will be returned by Client.WaitForClickPipeState
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Return(cp1 *ClickPipe, err error) *ClientMock {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	if mmWaitForClickPipeState.defaultExpectation == nil {
		mmWaitForClickPipeState.defaultExpectation = &ClientMockWaitForClickPipeStateExpectation{mock: mmWaitForClickPipeState.mock}
	}
	mmWaitForClickPipeState.defaultExpectation.results = &ClientMockWaitForClickPipeStateResults{cp1, err}
	return mmWaitForClickPipeState.mock
}

// Set uses given function f to mock the Client.WaitForClickPipeState method
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Set(f func(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error)) *ClientMock {
	if mmWaitForClickPipeState.defaultExpectation != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForClickPipeState method")
	}

	if len(mmWaitForClickPipeState.expectations) > 0 {
		mmWaitForClickPipeState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForClickPipeState method")
	}

	mmWaitForClickPipeState.mock.funcWaitForClickPipeState = f
	return mmWaitForClickPipeState.mock
}

// When sets expectation for the Client.WaitForClickPipeState which will trigger the result defined by the following
// Then helper
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) When(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) *ClientMockWaitForClickPipeStateExpectation {
	if mmWaitForClickPipeState.mock.funcWaitForClickPipeState != nil {
		mmWaitForClickPipeState.mock.t.Fatalf("ClientMock.WaitForClickPipeState mock is already set by Set")
	}

	expectation := &ClientMockWaitForClickPipeStateExpectation{
		mock:   mmWaitForClickPipeState.mock,
		params: &ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds},
	}
	mmWaitForClickPipeState.expectations = append(mmWaitForClickPipeState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForClickPipeState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForClickPipeStateExpectation) Then(cp1 *ClickPipe, err error) *ClientMock {
	e.results = &ClientMockWaitForClickPipeStateResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.WaitForClickPipeState should be invoked
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Times(n uint64) *mClientMockWaitForClickPipeState {
	if n == 0 {
		mmWaitForClickPipeState.mock.t.Fatalf("Times of ClientMock.WaitForClickPipeState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForClickPipeState.expectedInvocations, n)
	return mmWaitForClickPipeState
}

func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) invocationsDone() bool {
	if len(mmWaitForClickPipeState.expectations) == 0 && mmWaitForClickPipeState.defaultExpectation == nil && mmWaitForClickPipeState.mock.funcWaitForClickPipeState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForClickPipeState.mock.afterWaitForClickPipeStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForClickPipeState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForClickPipeState implements Client
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeState(ctx context.Context, serviceId string, clickPipeId string, stateChecker func(string) bool, maxWaitSeconds uint64) (cp1 *ClickPipe, err error) {
	mm_atomic.AddUint64(&mmWaitForClickPipeState.beforeWaitForClickPipeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForClickPipeState.afterWaitForClickPipeStateCounter, 1)

	if mmWaitForClickPipeState.inspectFuncWaitForClickPipeState != nil {
		mmWaitForClickPipeState.inspectFuncWaitForClickPipeState(ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForClickPipeState.WaitForClickPipeStateMock.mutex.Lock()
	mmWaitForClickPipeState.WaitForClickPipeStateMock.callArgs = append(mmWaitForClickPipeState.WaitForClickPipeStateMock.callArgs, &mm_params)
	mmWaitForClickPipeState.WaitForClickPipeStateMock.mutex.Unlock()

	for _, e := range mmWaitForClickPipeState.WaitForClickPipeStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForClickPipeStateParams{ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.clickPipeId != nil && !minimock.Equal(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter clickPipeId, want: %#v, got: %#v%s\n", *mm_want_ptrs.clickPipeId, mm_got.clickPipeId, minimock.Diff(*mm_want_ptrs.clickPipeId, mm_got.clickPipeId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter stateChecker, want: %#v, got: %#v%s\n", *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameter maxWaitSeconds, want: %#v, got: %#v%s\n", *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForClickPipeState.t.Errorf("ClientMock.WaitForClickPipeState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForClickPipeState.WaitForClickPipeStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForClickPipeState.t.Fatal("No results are set for the ClientMock.WaitForClickPipeState")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmWaitForClickPipeState.funcWaitForClickPipeState != nil {
		return mmWaitForClickPipeState.funcWaitForClickPipeState(ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	}
	mmWaitForClickPipeState.t.Fatalf("Unexpected call to ClientMock.WaitForClickPipeState. %v %v %v %v %v", ctx, serviceId, clickPipeId, stateChecker, maxWaitSeconds)
	return
}

// WaitForClickPipeStateAfterCounter returns a count of finished ClientMock.WaitForClickPipeState invocations
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForClickPipeState.afterWaitForClickPipeStateCounter)
}

// WaitForClickPipeStateBeforeCounter returns a count of ClientMock.WaitForClickPipeState invocations
func (mmWaitForClickPipeState *ClientMock) WaitForClickPipeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForClickPipeState.beforeWaitForClickPipeStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForClickPipeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForClickPipeState *mClientMockWaitForClickPipeState) Calls() []*ClientMockWaitForClickPipeStateParams {
	mmWaitForClickPipeState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForClickPipeStateParams, len(mmWaitForClickPipeState.callArgs))
	copy(argCopy, mmWaitForClickPipeState.callArgs)

	mmWaitForClickPipeState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForClickPipeStateDone returns true if the count of the WaitForClickPipeState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForClickPipeStateDone() bool {
	if m.WaitForClickPipeStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForClickPipeStateMock.invocationsDone()
}

// MinimockWaitForClickPipeStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForClickPipeStateInspect() {
	for _, e := range m.WaitForClickPipeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState with params: %#v", *e.params)
		}
	}

	afterWaitForClickPipeStateCounter := mm_atomic.LoadUint64(&m.afterWaitForClickPipeStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForClickPipeStateMock.defaultExpectation != nil && afterWaitForClickPipeStateCounter < 1 {
		if m.WaitForClickPipeStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.WaitForClickPipeState")
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForClickPipeState with params: %#v", *m.WaitForClickPipeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForClickPipeState != nil && afterWaitForClickPipeStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.WaitForClickPipeState")
	}

	if !m.WaitForClickPipeStateMock.invocationsDone() && afterWaitForClickPipeStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForClickPipeState but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForClickPipeStateMock.expectedInvocations), afterWaitForClickPipeStateCounter)
	}
}

type mClientMockWaitForReversePrivateEndpointState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForReversePrivateEndpointStateExpectation
	expectations       []*ClientMockWaitForReversePrivateEndpointStateExpectation

	callArgs []*ClientMockWaitForReversePrivateEndpointStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockWaitForReversePrivateEndpointStateExpectation specifies expectation struct of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockWaitForReversePrivateEndpointStateParams
	paramPtrs *ClientMockWaitForReversePrivateEndpointStateParamPtrs
	results   *ClientMockWaitForReversePrivateEndpointStateResults
	Counter   uint64
}

// ClientMockWaitForReversePrivateEndpointStateParams contains parameters of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateParams struct {
	ctx                      context.Context
	serviceId                string
	reversePrivateEndpointId string
	stateChecker             func(string) bool
	maxWaitSeconds           uint64
}

// ClientMockWaitForReversePrivateEndpointStateParamPtrs contains pointers to parameters of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateParamPtrs struct {
	ctx                      *context.Context
	serviceId                *string
	reversePrivateEndpointId *string
	stateChecker             *func(string) bool
	maxWaitSeconds           *uint64
}

// ClientMockWaitForReversePrivateEndpointStateResults contains results of the Client.WaitForReversePrivateEndpointState
type ClientMockWaitForReversePrivateEndpointStateResults struct {
	rp1 *ReversePrivateEndpoint
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Optional() *mClientMockWaitForReversePrivateEndpointState {
	mmWaitForReversePrivateEndpointState.optional = true
	return mmWaitForReversePrivateEndpointState
}

// Expect sets up expected params for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Expect(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by ExpectParams functions")
	}

	mmWaitForReversePrivateEndpointState.defaultExpectation.params = &ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds}
	for _, e := range mmWaitForReversePrivateEndpointState.expectations {
		if minimock.Equal(e.params, mmWaitForReversePrivateEndpointState.defaultExpectation.params) {
			mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForReversePrivateEndpointState.defaultExpectation.params)
		}
	}

	return mmWaitForReversePrivateEndpointState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWaitForReversePrivateEndpointState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmWaitForReversePrivateEndpointState
}

// ExpectReversePrivateEndpointIdParam3 sets up expected param reversePrivateEndpointId for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectReversePrivateEndpointIdParam3(reversePrivateEndpointId string) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.reversePrivateEndpointId = &reversePrivateEndpointId

	return mmWaitForReversePrivateEndpointState
}

// ExpectStateCheckerParam4 sets up expected param stateChecker for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectStateCheckerParam4(stateChecker func(string) bool) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.stateChecker = &stateChecker

	return mmWaitForReversePrivateEndpointState
}

// ExpectMaxWaitSecondsParam5 sets up expected param maxWaitSeconds for Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) ExpectMaxWaitSecondsParam5(maxWaitSeconds uint64) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{}
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.params != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Expect")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs = &ClientMockWaitForReversePrivateEndpointStateParamPtrs{}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds

	return mmWaitForReversePrivateEndpointState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Inspect(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64)) *mClientMockWaitForReversePrivateEndpointState {
	if mmWaitForReversePrivateEndpointState.mock.inspectFuncWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForReversePrivateEndpointState")
	}

	mmWaitForReversePrivateEndpointState.mock.inspectFuncWaitForReversePrivateEndpointState = f

	return mmWaitForReversePrivateEndpointState
}

// Return sets up results that will be returned by Client.WaitForReversePrivateEndpointState
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Return(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	if mmWaitForReversePrivateEndpointState.defaultExpectation == nil {
		mmWaitForReversePrivateEndpointState.defaultExpectation = &ClientMockWaitForReversePrivateEndpointStateExpectation{mock: mmWaitForReversePrivateEndpointState.mock}
	}
	mmWaitForReversePrivateEndpointState.defaultExpectation.results = &ClientMockWaitForReversePrivateEndpointStateResults{rp1, err}
	return mmWaitForReversePrivateEndpointState.mock
}

// Set uses given function f to mock the Client.WaitForReversePrivateEndpointState method
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Set(f func(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) (rp1 *ReversePrivateEndpoint, err error)) *ClientMock {
	if mmWaitForReversePrivateEndpointState.defaultExpectation != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForReversePrivateEndpointState method")
	}

	if len(mmWaitForReversePrivateEndpointState.expectations) > 0 {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForReversePrivateEndpointState method")
	}

	mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState = f
	return mmWaitForReversePrivateEndpointState.mock
}

// When sets expectation for the Client.WaitForReversePrivateEndpointState which will trigger the result defined by the following
// Then helper
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) When(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) *ClientMockWaitForReversePrivateEndpointStateExpectation {
	if mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("ClientMock.WaitForReversePrivateEndpointState mock is already set by Set")
	}

	expectation := &ClientMockWaitForReversePrivateEndpointStateExpectation{
		mock:   mmWaitForReversePrivateEndpointState.mock,
		params: &ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds},
	}
	mmWaitForReversePrivateEndpointState.expectations = append(mmWaitForReversePrivateEndpointState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForReversePrivateEndpointState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForReversePrivateEndpointStateExpectation) Then(rp1 *ReversePrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockWaitForReversePrivateEndpointStateResults{rp1, err}
	return e.mock
}

// Times sets number of times Client.WaitForReversePrivateEndpointState should be invoked
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Times(n uint64) *mClientMockWaitForReversePrivateEndpointState {
	if n == 0 {
		mmWaitForReversePrivateEndpointState.mock.t.Fatalf("Times of ClientMock.WaitForReversePrivateEndpointState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForReversePrivateEndpointState.expectedInvocations, n)
	return mmWaitForReversePrivateEndpointState
}

func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) invocationsDone() bool {
	if len(mmWaitForReversePrivateEndpointState.expectations) == 0 && mmWaitForReversePrivateEndpointState.defaultExpectation == nil && mmWaitForReversePrivateEndpointState.mock.funcWaitForReversePrivateEndpointState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.mock.afterWaitForReversePrivateEndpointStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForReversePrivateEndpointState implements Client
func (mmWaitForReversePrivateEndpointState *ClientMock) WaitForReversePrivateEndpointState(ctx context.Context, serviceId string, reversePrivateEndpointId string, stateChecker func(string) bool, maxWaitSeconds uint64) (rp1 *ReversePrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmWaitForReversePrivateEndpointState.beforeWaitForReversePrivateEndpointStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForReversePrivateEndpointState.afterWaitForReversePrivateEndpointStateCounter, 1)

	if mmWaitForReversePrivateEndpointState.inspectFuncWaitForReversePrivateEndpointState != nil {
		mmWaitForReversePrivateEndpointState.inspectFuncWaitForReversePrivateEndpointState(ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.mutex.Lock()
	mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.callArgs = append(mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.callArgs, &mm_params)
	mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.mutex.Unlock()

	for _, e := range mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForReversePrivateEndpointStateParams{ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.reversePrivateEndpointId != nil && !minimock.Equal(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter reversePrivateEndpointId, want: %#v, got: %#v%s\n", *mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId, minimock.Diff(*mm_want_ptrs.reversePrivateEndpointId, mm_got.reversePrivateEndpointId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter stateChecker, want: %#v, got: %#v%s\n", *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameter maxWaitSeconds, want: %#v, got: %#v%s\n", *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForReversePrivateEndpointState.t.Errorf("ClientMock.WaitForReversePrivateEndpointState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForReversePrivateEndpointState.WaitForReversePrivateEndpointStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForReversePrivateEndpointState.t.Fatal("No results are set for the ClientMock.WaitForReversePrivateEndpointState")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmWaitForReversePrivateEndpointState.funcWaitForReversePrivateEndpointState != nil {
		return mmWaitForReversePrivateEndpointState.funcWaitForReversePrivateEndpointState(ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds)
	}
	mmWaitForReversePrivateEndpointState.t.Fatalf("Unexpected call to ClientMock.WaitForReversePrivateEndpointState. %v %v %v %v %v", ctx, serviceId, reversePrivateEndpointId, stateChecker, maxWaitSeconds)
	return
}

// WaitForReversePrivateEndpointStateAfterCounter returns a count of finished ClientMock.WaitForReversePrivateEndpointState invocations
func (mmWaitForReversePrivateEndpointState *ClientMock) WaitForReversePrivateEndpointStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.afterWaitForReversePrivateEndpointStateCounter)
}

// WaitForReversePrivateEndpointStateBeforeCounter returns a count of ClientMock.WaitForReversePrivateEndpointState invocations
func (mmWaitForReversePrivateEndpointState *ClientMock) WaitForReversePrivateEndpointStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForReversePrivateEndpointState.beforeWaitForReversePrivateEndpointStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForReversePrivateEndpointState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForReversePrivateEndpointState *mClientMockWaitForReversePrivateEndpointState) Calls() []*ClientMockWaitForReversePrivateEndpointStateParams {
	mmWaitForReversePrivateEndpointState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForReversePrivateEndpointStateParams, len(mmWaitForReversePrivateEndpointState.callArgs))
	copy(argCopy, mmWaitForReversePrivateEndpointState.callArgs)

	mmWaitForReversePrivateEndpointState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForReversePrivateEndpointStateDone returns true if the count of the WaitForReversePrivateEndpointState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForReversePrivateEndpointStateDone() bool {
	if m.WaitForReversePrivateEndpointStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForReversePrivateEndpointStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForReversePrivateEndpointStateMock.invocationsDone()
}

// MinimockWaitForReversePrivateEndpointStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForReversePrivateEndpointStateInspect() {
	for _, e := range m.WaitForReversePrivateEndpointStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForReversePrivateEndpointState with params: %#v", *e.params)
		}
	}

	afterWaitForReversePrivateEndpointStateCounter := mm_atomic.LoadUint64(&m.afterWaitForReversePrivateEndpointStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForReversePrivateEndpointStateMock.defaultExpectation != nil && afterWaitForReversePrivateEndpointStateCounter < 1 {
		if m.WaitForReversePrivateEndpointStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.WaitForReversePrivateEndpointState")
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForReversePrivateEndpointState with params: %#v", *m.WaitForReversePrivateEndpointStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForReversePrivateEndpointState != nil && afterWaitForReversePrivateEndpointStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.WaitForReversePrivateEndpointState")
	}

	if !m.WaitForReversePrivateEndpointStateMock.invocationsDone() && afterWaitForReversePrivateEndpointStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForReversePrivateEndpointState but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForReversePrivateEndpointStateMock.expectedInvocations), afterWaitForReversePrivateEndpointStateCounter)
	}
}

type mClientMockWaitForServiceState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForServiceStateExpectation
	expectations       []*ClientMockWaitForServiceStateExpectation

	callArgs []*ClientMockWaitForServiceStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockWaitForServiceStateExpectation specifies expectation struct of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockWaitForServiceStateParams
	paramPtrs *ClientMockWaitForServiceStateParamPtrs
	results   *ClientMockWaitForServiceStateResults
	Counter   uint64
}

// ClientMockWaitForServiceStateParams contains parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParams struct {
	ctx            context.Context
	serviceId      string
	stateChecker   func(string) bool
	maxWaitSeconds int
}

// ClientMockWaitForServiceStateParamPtrs contains pointers to parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	stateChecker   *func(string) bool
	maxWaitSeconds *int
}

// ClientMockWaitForServiceStateResults contains results of the Client.WaitForServiceState
type ClientMockWaitForServiceStateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForServiceState *mClientMockWaitForServiceState) Optional() *mClientMockWaitForServiceState {
	mmWaitForServiceState.optional = true
	return mmWaitForServiceState
}

// Expect sets up expected params for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Expect(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by ExpectParams functions")
	}

	mmWaitForServiceState.defaultExpectation.params = &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}
	for _, e := range mmWaitForServiceState.expectations {
		if minimock.Equal(e.params, mmWaitForServiceState.defaultExpectation.params) {
			mmWaitForServiceState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForServiceState.defaultExpectation.params)
		}
	}

	return mmWaitForServiceState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWaitForServiceState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmWaitForServiceState
}

// ExpectStateCheckerParam3 sets up expected param stateChecker for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectStateCheckerParam3(stateChecker func(string) bool) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.stateChecker = &stateChecker

	return mmWaitForServiceState
}

// ExpectMaxWaitSecondsParam4 sets up expected param maxWaitSeconds for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectMaxWaitSecondsParam4(maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds

	return mmWaitForServiceState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Inspect(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForServiceState")
	}

	mmWaitForServiceState.mock.inspectFuncWaitForServiceState = f

	return mmWaitForServiceState
}

// Return sets up results that will be returned by Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Return(err error) *ClientMock {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{mock: mmWaitForServiceState.mock}
	}
	mmWaitForServiceState.defaultExpectation.results = &ClientMockWaitForServiceStateResults{err}
	return mmWaitForServiceState.mock
}

// Set uses given function f to mock the Client.WaitForServiceState method
func (mmWaitForServiceState *mClientMockWaitForServiceState) Set(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)) *ClientMock {
	if mmWaitForServiceState.defaultExpectation != nil {
		mmWaitForServiceState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForServiceState method")
	}

	if len(mmWaitForServiceState.expectations) > 0 {
		mmWaitForServiceState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForServiceState method")
	}

	mmWaitForServiceState.mock.funcWaitForServiceState = f
	return mmWaitForServiceState.mock
}

// When sets expectation for the Client.WaitForServiceState which will trigger the result defined by the following
// Then helper
func (mmWaitForServiceState *mClientMockWaitForServiceState) When(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *ClientMockWaitForServiceStateExpectation {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	expectation := &ClientMockWaitForServiceStateExpectation{
		mock:   mmWaitForServiceState.mock,
		params: &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds},
	}
	mmWaitForServiceState.expectations = append(mmWaitForServiceState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForServiceState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForServiceStateExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockWaitForServiceStateResults{err}
	return e.mock
}

// Times sets number of times Client.WaitForServiceState should be invoked
func (mmWaitForServiceState *mClientMockWaitForServiceState) Times(n uint64) *mClientMockWaitForServiceState {
	if n == 0 {
		mmWaitForServiceState.mock.t.Fatalf("Times of ClientMock.WaitForServiceState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForServiceState.expectedInvocations, n)
	return mmWaitForServiceState
}

func (mmWaitForServiceState *mClientMockWaitForServiceState) invocationsDone() bool {
	if len(mmWaitForServiceState.expectations) == 0 && mmWaitForServiceState.defaultExpectation == nil && mmWaitForServiceState.mock.funcWaitForServiceState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.mock.afterWaitForServiceStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForServiceState implements Client
func (mmWaitForServiceState *ClientMock) WaitForServiceState(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error) {
	mm_atomic.AddUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter, 1)

	if mmWaitForServiceState.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.inspectFuncWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Lock()
	mmWaitForServiceState.WaitForServiceStateMock.callArgs = append(mmWaitForServiceState.WaitForServiceStateMock.callArgs, &mm_params)
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Unlock()

	for _, e := range mmWaitForServiceState.WaitForServiceStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter stateChecker, want: %#v, got: %#v%s\n", *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter maxWaitSeconds, want: %#v, got: %#v%s\n", *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForServiceState.t.Fatal("No results are set for the ClientMock.WaitForServiceState")
		}
		return (*mm_results).err
	}
	if mmWaitForServiceState.funcWaitForServiceState != nil {
		return mmWaitForServiceState.funcWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}
	mmWaitForServiceState.t.Fatalf("Unexpected call to ClientMock.WaitForServiceState. %v %v %v %v", ctx, serviceId, stateChecker, maxWaitSeconds)
	return
}

// WaitForServiceStateAfterCounter returns a count of finished ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter)
}

// WaitForServiceStateBeforeCounter returns a count of ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForServiceState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForServiceState *mClientMockWaitForServiceState) Calls() []*ClientMockWaitForServiceStateParams {
	mmWaitForServiceState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForServiceStateParams, len(mmWaitForServiceState.callArgs))
	copy(argCopy, mmWaitForServiceState.callArgs)

	mmWaitForServiceState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForServiceStateDone returns true if the count of the WaitForServiceState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForServiceStateDone() bool {
	if m.WaitForServiceStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForServiceStateMock.invocationsDone()
}

// MinimockWaitForServiceStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForServiceStateInspect() {
	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState with params: %#v", *e.params)
		}
	}

	afterWaitForServiceStateCounter := mm_atomic.LoadUint64(&m.afterWaitForServiceStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForServiceStateMock.defaultExpectation != nil && afterWaitForServiceStateCounter < 1 {
		if m.WaitForServiceStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.WaitForServiceState")
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState with params: %#v", *m.WaitForServiceStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForServiceState != nil && afterWaitForServiceStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.WaitForServiceState")
	}

	if !m.WaitForServiceStateMock.invocationsDone() && afterWaitForServiceStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForServiceState but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForServiceStateMock.expectedInvocations), afterWaitForServiceStateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangeClickPipeStateInspect()

			m.MinimockCreateApiKeyInspect()

			m.MinimockCreateClickPipeInspect()

			m.MinimockCreateDatabaseInspect()

			m.MinimockCreateQueryEndpointInspect()

			m.MinimockCreateReversePrivateEndpointInspect()

			m.MinimockCreateRoleInspect()

			m.MinimockCreateServiceInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteApiKeyInspect()

			m.MinimockDeleteClickPipeInspect()

			m.MinimockDeleteDatabaseInspect()

			m.MinimockDeleteQueryEndpointInspect()

			m.MinimockDeleteReversePrivateEndpointInspect()

			m.MinimockDeleteRoleInspect()

			m.MinimockDeleteServiceInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetApiKeyInspect()

			m.MinimockGetBackupConfigurationInspect()

			m.MinimockGetClickPipeInspect()

			m.MinimockGetCurrentApiKeyInspect()

			m.MinimockGetDatabaseInspect()

			m.MinimockGetGrantPrivilegeInspect()

			m.MinimockGetGrantRoleInspect()

			m.MinimockGetOrgPrivateEndpointConfigInspect()

			m.MinimockGetOrganizationPrivateEndpointsInspect()

			m.MinimockGetQueryEndpointInspect()

			m.MinimockGetReversePrivateEndpointInspect()

			m.MinimockGetReversePrivateEndpointPathInspect()

			m.MinimockGetRoleInspect()

			m.MinimockGetServiceInspect()

			m.MinimockGetUserInspect()

			m.MinimockGrantPrivilegeInspect()

			m.MinimockGrantRoleInspect()

			m.MinimockListReversePrivateEndpointsInspect()

			m.MinimockRevokeGrantPrivilegeInspect()

			m.MinimockRevokeGrantRoleInspect()

			m.MinimockRotateTDEKeyInspect()

			m.MinimockScalingClickPipeInspect()

			m.MinimockSyncDatabaseInspect()

			m.MinimockUpdateBackupConfigurationInspect()

			m.MinimockUpdateClickPipeInspect()

			m.MinimockUpdateOrganizationPrivateEndpointsInspect()

			m.MinimockUpdateReplicaScalingInspect()

			m.MinimockUpdateServiceInspect()

			m.MinimockUpdateServicePasswordInspect()

			m.MinimockWaitForClickPipeStateInspect()

			m.MinimockWaitForReversePrivateEndpointStateInspect()

			m.MinimockWaitForServiceStateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangeClickPipeStateDone() &&
		m.MinimockCreateApiKeyDone() &&
		m.MinimockCreateClickPipeDone() &&
		m.MinimockCreateDatabaseDone() &&
		m.MinimockCreateQueryEndpointDone() &&
		m.MinimockCreateReversePrivateEndpointDone() &&
		m.MinimockCreateRoleDone() &&
		m.MinimockCreateServiceDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteApiKeyDone() &&
		m.MinimockDeleteClickPipeDone() &&
		m.MinimockDeleteDatabaseDone() &&
		m.MinimockDeleteQueryEndpointDone() &&
		m.MinimockDeleteReversePrivateEndpointDone() &&
		m.MinimockDeleteRoleDone() &&
		m.MinimockDeleteServiceDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetApiKeyDone() &&
		m.MinimockGetBackupConfigurationDone() &&
		m.MinimockGetClickPipeDone() &&
		m.MinimockGetCurrentApiKeyDone() &&
		m.MinimockGetDatabaseDone() &&
		m.MinimockGetGrantPrivilegeDone() &&
		m.MinimockGetGrantRoleDone() &&
		m.MinimockGetOrgPrivateEndpointConfigDone() &&
		m.MinimockGetOrganizationPrivateEndpointsDone() &&
		m.MinimockGetQueryEndpointDone() &&
		m.MinimockGetReversePrivateEndpointDone() &&
		m.MinimockGetReversePrivateEndpointPathDone() &&
		m.MinimockGetRoleDone() &&
		m.MinimockGetServiceDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockGrantPrivilegeDone() &&
		m.MinimockGrantRoleDone() &&
		m.MinimockListReversePrivateEndpointsDone() &&
		m.MinimockRevokeGrantPrivilegeDone() &&
		m.MinimockRevokeGrantRoleDone() &&
		m.MinimockRotateTDEKeyDone() &&
		m.MinimockScalingClickPipeDone() &&
		m.MinimockSyncDatabaseDone() &&
		m.MinimockUpdateBackupConfigurationDone() &&
		m.MinimockUpdateClickPipeDone() &&
		m.MinimockUpdateOrganizationPrivateEndpointsDone() &&
		m.MinimockUpdateReplicaScalingDone() &&
		m.MinimockUpdateServiceDone() &&
		m.MinimockUpdateServicePasswordDone() &&
		m.MinimockWaitForClickPipeStateDone() &&
		m.MinimockWaitForReversePrivateEndpointStateDone() &&
		m.MinimockWaitForServiceStateDone()
}
