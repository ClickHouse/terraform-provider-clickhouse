// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package api

//go:generate minimock -i github.com/ClickHouse/terraform-provider-clickhouse/pkg/internal/api.Client -o client_mock_test.go -n ClientMock -p api

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateService          func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)
	inspectFuncCreateService   func(ctx context.Context, s Service)
	afterCreateServiceCounter  uint64
	beforeCreateServiceCounter uint64
	CreateServiceMock          mClientMockCreateService

	funcDeleteService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	inspectFuncDeleteService   func(ctx context.Context, serviceId string)
	afterDeleteServiceCounter  uint64
	beforeDeleteServiceCounter uint64
	DeleteServiceMock          mClientMockDeleteService

	funcGetBackupConfiguration          func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)
	inspectFuncGetBackupConfiguration   func(ctx context.Context, serviceId string)
	afterGetBackupConfigurationCounter  uint64
	beforeGetBackupConfigurationCounter uint64
	GetBackupConfigurationMock          mClientMockGetBackupConfiguration

	funcGetOrgPrivateEndpointConfig          func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)
	inspectFuncGetOrgPrivateEndpointConfig   func(ctx context.Context, cloudProvider string, region string)
	afterGetOrgPrivateEndpointConfigCounter  uint64
	beforeGetOrgPrivateEndpointConfigCounter uint64
	GetOrgPrivateEndpointConfigMock          mClientMockGetOrgPrivateEndpointConfig

	funcGetOrganizationPrivateEndpoints          func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)
	inspectFuncGetOrganizationPrivateEndpoints   func(ctx context.Context)
	afterGetOrganizationPrivateEndpointsCounter  uint64
	beforeGetOrganizationPrivateEndpointsCounter uint64
	GetOrganizationPrivateEndpointsMock          mClientMockGetOrganizationPrivateEndpoints

	funcGetService          func(ctx context.Context, serviceId string) (sp1 *Service, err error)
	inspectFuncGetService   func(ctx context.Context, serviceId string)
	afterGetServiceCounter  uint64
	beforeGetServiceCounter uint64
	GetServiceMock          mClientMockGetService

	funcUpdateBackupConfiguration          func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)
	inspectFuncUpdateBackupConfiguration   func(ctx context.Context, serviceId string, b BackupConfiguration)
	afterUpdateBackupConfigurationCounter  uint64
	beforeUpdateBackupConfigurationCounter uint64
	UpdateBackupConfigurationMock          mClientMockUpdateBackupConfiguration

	funcUpdateOrganizationPrivateEndpoints          func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)
	inspectFuncUpdateOrganizationPrivateEndpoints   func(ctx context.Context, orgUpdate OrganizationUpdate)
	afterUpdateOrganizationPrivateEndpointsCounter  uint64
	beforeUpdateOrganizationPrivateEndpointsCounter uint64
	UpdateOrganizationPrivateEndpointsMock          mClientMockUpdateOrganizationPrivateEndpoints

	funcUpdateReplicaScaling          func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)
	inspectFuncUpdateReplicaScaling   func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)
	afterUpdateReplicaScalingCounter  uint64
	beforeUpdateReplicaScalingCounter uint64
	UpdateReplicaScalingMock          mClientMockUpdateReplicaScaling

	funcUpdateService          func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)
	inspectFuncUpdateService   func(ctx context.Context, serviceId string, s ServiceUpdate)
	afterUpdateServiceCounter  uint64
	beforeUpdateServiceCounter uint64
	UpdateServiceMock          mClientMockUpdateService

	funcUpdateServicePassword          func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)
	inspectFuncUpdateServicePassword   func(ctx context.Context, serviceId string, u ServicePasswordUpdate)
	afterUpdateServicePasswordCounter  uint64
	beforeUpdateServicePasswordCounter uint64
	UpdateServicePasswordMock          mClientMockUpdateServicePassword

	funcWaitForServiceState          func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)
	inspectFuncWaitForServiceState   func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)
	afterWaitForServiceStateCounter  uint64
	beforeWaitForServiceStateCounter uint64
	WaitForServiceStateMock          mClientMockWaitForServiceState
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateServiceMock = mClientMockCreateService{mock: m}
	m.CreateServiceMock.callArgs = []*ClientMockCreateServiceParams{}

	m.DeleteServiceMock = mClientMockDeleteService{mock: m}
	m.DeleteServiceMock.callArgs = []*ClientMockDeleteServiceParams{}

	m.GetBackupConfigurationMock = mClientMockGetBackupConfiguration{mock: m}
	m.GetBackupConfigurationMock.callArgs = []*ClientMockGetBackupConfigurationParams{}

	m.GetOrgPrivateEndpointConfigMock = mClientMockGetOrgPrivateEndpointConfig{mock: m}
	m.GetOrgPrivateEndpointConfigMock.callArgs = []*ClientMockGetOrgPrivateEndpointConfigParams{}

	m.GetOrganizationPrivateEndpointsMock = mClientMockGetOrganizationPrivateEndpoints{mock: m}
	m.GetOrganizationPrivateEndpointsMock.callArgs = []*ClientMockGetOrganizationPrivateEndpointsParams{}

	m.GetServiceMock = mClientMockGetService{mock: m}
	m.GetServiceMock.callArgs = []*ClientMockGetServiceParams{}

	m.UpdateBackupConfigurationMock = mClientMockUpdateBackupConfiguration{mock: m}
	m.UpdateBackupConfigurationMock.callArgs = []*ClientMockUpdateBackupConfigurationParams{}

	m.UpdateOrganizationPrivateEndpointsMock = mClientMockUpdateOrganizationPrivateEndpoints{mock: m}
	m.UpdateOrganizationPrivateEndpointsMock.callArgs = []*ClientMockUpdateOrganizationPrivateEndpointsParams{}

	m.UpdateReplicaScalingMock = mClientMockUpdateReplicaScaling{mock: m}
	m.UpdateReplicaScalingMock.callArgs = []*ClientMockUpdateReplicaScalingParams{}

	m.UpdateServiceMock = mClientMockUpdateService{mock: m}
	m.UpdateServiceMock.callArgs = []*ClientMockUpdateServiceParams{}

	m.UpdateServicePasswordMock = mClientMockUpdateServicePassword{mock: m}
	m.UpdateServicePasswordMock.callArgs = []*ClientMockUpdateServicePasswordParams{}

	m.WaitForServiceStateMock = mClientMockWaitForServiceState{mock: m}
	m.WaitForServiceStateMock.callArgs = []*ClientMockWaitForServiceStateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockCreateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateServiceExpectation
	expectations       []*ClientMockCreateServiceExpectation

	callArgs []*ClientMockCreateServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockCreateServiceExpectation specifies expectation struct of the Client.CreateService
type ClientMockCreateServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockCreateServiceParams
	paramPtrs *ClientMockCreateServiceParamPtrs
	results   *ClientMockCreateServiceResults
	Counter   uint64
}

// ClientMockCreateServiceParams contains parameters of the Client.CreateService
type ClientMockCreateServiceParams struct {
	ctx context.Context
	s   Service
}

// ClientMockCreateServiceParamPtrs contains pointers to parameters of the Client.CreateService
type ClientMockCreateServiceParamPtrs struct {
	ctx *context.Context
	s   *Service
}

// ClientMockCreateServiceResults contains results of the Client.CreateService
type ClientMockCreateServiceResults struct {
	sp1 *Service
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateService *mClientMockCreateService) Optional() *mClientMockCreateService {
	mmCreateService.optional = true
	return mmCreateService
}

// Expect sets up expected params for Client.CreateService
func (mmCreateService *mClientMockCreateService) Expect(ctx context.Context, s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.paramPtrs != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by ExpectParams functions")
	}

	mmCreateService.defaultExpectation.params = &ClientMockCreateServiceParams{ctx, s}
	for _, e := range mmCreateService.expectations {
		if minimock.Equal(e.params, mmCreateService.defaultExpectation.params) {
			mmCreateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateService.defaultExpectation.params)
		}
	}

	return mmCreateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectCtxParam1(ctx context.Context) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateService
}

// ExpectSParam2 sets up expected param s for Client.CreateService
func (mmCreateService *mClientMockCreateService) ExpectSParam2(s Service) *mClientMockCreateService {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{}
	}

	if mmCreateService.defaultExpectation.params != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Expect")
	}

	if mmCreateService.defaultExpectation.paramPtrs == nil {
		mmCreateService.defaultExpectation.paramPtrs = &ClientMockCreateServiceParamPtrs{}
	}
	mmCreateService.defaultExpectation.paramPtrs.s = &s

	return mmCreateService
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateService
func (mmCreateService *mClientMockCreateService) Inspect(f func(ctx context.Context, s Service)) *mClientMockCreateService {
	if mmCreateService.mock.inspectFuncCreateService != nil {
		mmCreateService.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateService")
	}

	mmCreateService.mock.inspectFuncCreateService = f

	return mmCreateService
}

// Return sets up results that will be returned by Client.CreateService
func (mmCreateService *mClientMockCreateService) Return(sp1 *Service, s1 string, err error) *ClientMock {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	if mmCreateService.defaultExpectation == nil {
		mmCreateService.defaultExpectation = &ClientMockCreateServiceExpectation{mock: mmCreateService.mock}
	}
	mmCreateService.defaultExpectation.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return mmCreateService.mock
}

// Set uses given function f to mock the Client.CreateService method
func (mmCreateService *mClientMockCreateService) Set(f func(ctx context.Context, s Service) (sp1 *Service, s1 string, err error)) *ClientMock {
	if mmCreateService.defaultExpectation != nil {
		mmCreateService.mock.t.Fatalf("Default expectation is already set for the Client.CreateService method")
	}

	if len(mmCreateService.expectations) > 0 {
		mmCreateService.mock.t.Fatalf("Some expectations are already set for the Client.CreateService method")
	}

	mmCreateService.mock.funcCreateService = f
	return mmCreateService.mock
}

// When sets expectation for the Client.CreateService which will trigger the result defined by the following
// Then helper
func (mmCreateService *mClientMockCreateService) When(ctx context.Context, s Service) *ClientMockCreateServiceExpectation {
	if mmCreateService.mock.funcCreateService != nil {
		mmCreateService.mock.t.Fatalf("ClientMock.CreateService mock is already set by Set")
	}

	expectation := &ClientMockCreateServiceExpectation{
		mock:   mmCreateService.mock,
		params: &ClientMockCreateServiceParams{ctx, s},
	}
	mmCreateService.expectations = append(mmCreateService.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateService return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateServiceExpectation) Then(sp1 *Service, s1 string, err error) *ClientMock {
	e.results = &ClientMockCreateServiceResults{sp1, s1, err}
	return e.mock
}

// Times sets number of times Client.CreateService should be invoked
func (mmCreateService *mClientMockCreateService) Times(n uint64) *mClientMockCreateService {
	if n == 0 {
		mmCreateService.mock.t.Fatalf("Times of ClientMock.CreateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateService.expectedInvocations, n)
	return mmCreateService
}

func (mmCreateService *mClientMockCreateService) invocationsDone() bool {
	if len(mmCreateService.expectations) == 0 && mmCreateService.defaultExpectation == nil && mmCreateService.mock.funcCreateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateService.mock.afterCreateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateService implements Client
func (mmCreateService *ClientMock) CreateService(ctx context.Context, s Service) (sp1 *Service, s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateService.beforeCreateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateService.afterCreateServiceCounter, 1)

	if mmCreateService.inspectFuncCreateService != nil {
		mmCreateService.inspectFuncCreateService(ctx, s)
	}

	mm_params := ClientMockCreateServiceParams{ctx, s}

	// Record call args
	mmCreateService.CreateServiceMock.mutex.Lock()
	mmCreateService.CreateServiceMock.callArgs = append(mmCreateService.CreateServiceMock.callArgs, &mm_params)
	mmCreateService.CreateServiceMock.mutex.Unlock()

	for _, e := range mmCreateService.CreateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.err
		}
	}

	if mmCreateService.CreateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateService.CreateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateService.CreateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmCreateService.CreateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateServiceParams{ctx, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateService.t.Errorf("ClientMock.CreateService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateService.CreateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateService.t.Fatal("No results are set for the ClientMock.CreateService")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).err
	}
	if mmCreateService.funcCreateService != nil {
		return mmCreateService.funcCreateService(ctx, s)
	}
	mmCreateService.t.Fatalf("Unexpected call to ClientMock.CreateService. %v %v", ctx, s)
	return
}

// CreateServiceAfterCounter returns a count of finished ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.afterCreateServiceCounter)
}

// CreateServiceBeforeCounter returns a count of ClientMock.CreateService invocations
func (mmCreateService *ClientMock) CreateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateService.beforeCreateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateService *mClientMockCreateService) Calls() []*ClientMockCreateServiceParams {
	mmCreateService.mutex.RLock()

	argCopy := make([]*ClientMockCreateServiceParams, len(mmCreateService.callArgs))
	copy(argCopy, mmCreateService.callArgs)

	mmCreateService.mutex.RUnlock()

	return argCopy
}

// MinimockCreateServiceDone returns true if the count of the CreateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateServiceDone() bool {
	if m.CreateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateServiceMock.invocationsDone()
}

// MinimockCreateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateServiceInspect() {
	for _, e := range m.CreateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateService with params: %#v", *e.params)
		}
	}

	afterCreateServiceCounter := mm_atomic.LoadUint64(&m.afterCreateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceMock.defaultExpectation != nil && afterCreateServiceCounter < 1 {
		if m.CreateServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateService")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateService with params: %#v", *m.CreateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateService != nil && afterCreateServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.CreateService")
	}

	if !m.CreateServiceMock.invocationsDone() && afterCreateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateService but found %d calls",
			mm_atomic.LoadUint64(&m.CreateServiceMock.expectedInvocations), afterCreateServiceCounter)
	}
}

type mClientMockDeleteService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteServiceExpectation
	expectations       []*ClientMockDeleteServiceExpectation

	callArgs []*ClientMockDeleteServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockDeleteServiceExpectation specifies expectation struct of the Client.DeleteService
type ClientMockDeleteServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockDeleteServiceParams
	paramPtrs *ClientMockDeleteServiceParamPtrs
	results   *ClientMockDeleteServiceResults
	Counter   uint64
}

// ClientMockDeleteServiceParams contains parameters of the Client.DeleteService
type ClientMockDeleteServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockDeleteServiceParamPtrs contains pointers to parameters of the Client.DeleteService
type ClientMockDeleteServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockDeleteServiceResults contains results of the Client.DeleteService
type ClientMockDeleteServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteService *mClientMockDeleteService) Optional() *mClientMockDeleteService {
	mmDeleteService.optional = true
	return mmDeleteService
}

// Expect sets up expected params for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Expect(ctx context.Context, serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.paramPtrs != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by ExpectParams functions")
	}

	mmDeleteService.defaultExpectation.params = &ClientMockDeleteServiceParams{ctx, serviceId}
	for _, e := range mmDeleteService.expectations {
		if minimock.Equal(e.params, mmDeleteService.defaultExpectation.params) {
			mmDeleteService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteService.defaultExpectation.params)
		}
	}

	return mmDeleteService
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) ExpectServiceIdParam2(serviceId string) *mClientMockDeleteService {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{}
	}

	if mmDeleteService.defaultExpectation.params != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Expect")
	}

	if mmDeleteService.defaultExpectation.paramPtrs == nil {
		mmDeleteService.defaultExpectation.paramPtrs = &ClientMockDeleteServiceParamPtrs{}
	}
	mmDeleteService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmDeleteService
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockDeleteService {
	if mmDeleteService.mock.inspectFuncDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteService")
	}

	mmDeleteService.mock.inspectFuncDeleteService = f

	return mmDeleteService
}

// Return sets up results that will be returned by Client.DeleteService
func (mmDeleteService *mClientMockDeleteService) Return(sp1 *Service, err error) *ClientMock {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	if mmDeleteService.defaultExpectation == nil {
		mmDeleteService.defaultExpectation = &ClientMockDeleteServiceExpectation{mock: mmDeleteService.mock}
	}
	mmDeleteService.defaultExpectation.results = &ClientMockDeleteServiceResults{sp1, err}
	return mmDeleteService.mock
}

// Set uses given function f to mock the Client.DeleteService method
func (mmDeleteService *mClientMockDeleteService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmDeleteService.defaultExpectation != nil {
		mmDeleteService.mock.t.Fatalf("Default expectation is already set for the Client.DeleteService method")
	}

	if len(mmDeleteService.expectations) > 0 {
		mmDeleteService.mock.t.Fatalf("Some expectations are already set for the Client.DeleteService method")
	}

	mmDeleteService.mock.funcDeleteService = f
	return mmDeleteService.mock
}

// When sets expectation for the Client.DeleteService which will trigger the result defined by the following
// Then helper
func (mmDeleteService *mClientMockDeleteService) When(ctx context.Context, serviceId string) *ClientMockDeleteServiceExpectation {
	if mmDeleteService.mock.funcDeleteService != nil {
		mmDeleteService.mock.t.Fatalf("ClientMock.DeleteService mock is already set by Set")
	}

	expectation := &ClientMockDeleteServiceExpectation{
		mock:   mmDeleteService.mock,
		params: &ClientMockDeleteServiceParams{ctx, serviceId},
	}
	mmDeleteService.expectations = append(mmDeleteService.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteService return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockDeleteServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.DeleteService should be invoked
func (mmDeleteService *mClientMockDeleteService) Times(n uint64) *mClientMockDeleteService {
	if n == 0 {
		mmDeleteService.mock.t.Fatalf("Times of ClientMock.DeleteService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteService.expectedInvocations, n)
	return mmDeleteService
}

func (mmDeleteService *mClientMockDeleteService) invocationsDone() bool {
	if len(mmDeleteService.expectations) == 0 && mmDeleteService.defaultExpectation == nil && mmDeleteService.mock.funcDeleteService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteService.mock.afterDeleteServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteService implements Client
func (mmDeleteService *ClientMock) DeleteService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmDeleteService.beforeDeleteServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteService.afterDeleteServiceCounter, 1)

	if mmDeleteService.inspectFuncDeleteService != nil {
		mmDeleteService.inspectFuncDeleteService(ctx, serviceId)
	}

	mm_params := ClientMockDeleteServiceParams{ctx, serviceId}

	// Record call args
	mmDeleteService.DeleteServiceMock.mutex.Lock()
	mmDeleteService.DeleteServiceMock.callArgs = append(mmDeleteService.DeleteServiceMock.callArgs, &mm_params)
	mmDeleteService.DeleteServiceMock.mutex.Unlock()

	for _, e := range mmDeleteService.DeleteServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDeleteService.DeleteServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteService.DeleteServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteService.DeleteServiceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteService.DeleteServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteService.t.Errorf("ClientMock.DeleteService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteService.DeleteServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteService.t.Fatal("No results are set for the ClientMock.DeleteService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDeleteService.funcDeleteService != nil {
		return mmDeleteService.funcDeleteService(ctx, serviceId)
	}
	mmDeleteService.t.Fatalf("Unexpected call to ClientMock.DeleteService. %v %v", ctx, serviceId)
	return
}

// DeleteServiceAfterCounter returns a count of finished ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.afterDeleteServiceCounter)
}

// DeleteServiceBeforeCounter returns a count of ClientMock.DeleteService invocations
func (mmDeleteService *ClientMock) DeleteServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteService.beforeDeleteServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteService *mClientMockDeleteService) Calls() []*ClientMockDeleteServiceParams {
	mmDeleteService.mutex.RLock()

	argCopy := make([]*ClientMockDeleteServiceParams, len(mmDeleteService.callArgs))
	copy(argCopy, mmDeleteService.callArgs)

	mmDeleteService.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteServiceDone returns true if the count of the DeleteService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteServiceDone() bool {
	if m.DeleteServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteServiceMock.invocationsDone()
}

// MinimockDeleteServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteServiceInspect() {
	for _, e := range m.DeleteServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteService with params: %#v", *e.params)
		}
	}

	afterDeleteServiceCounter := mm_atomic.LoadUint64(&m.afterDeleteServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteServiceMock.defaultExpectation != nil && afterDeleteServiceCounter < 1 {
		if m.DeleteServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteService")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteService with params: %#v", *m.DeleteServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteService != nil && afterDeleteServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.DeleteService")
	}

	if !m.DeleteServiceMock.invocationsDone() && afterDeleteServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteService but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteServiceMock.expectedInvocations), afterDeleteServiceCounter)
	}
}

type mClientMockGetBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetBackupConfigurationExpectation
	expectations       []*ClientMockGetBackupConfigurationExpectation

	callArgs []*ClientMockGetBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetBackupConfigurationExpectation specifies expectation struct of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetBackupConfigurationParams
	paramPtrs *ClientMockGetBackupConfigurationParamPtrs
	results   *ClientMockGetBackupConfigurationResults
	Counter   uint64
}

// ClientMockGetBackupConfigurationParams contains parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetBackupConfigurationParamPtrs contains pointers to parameters of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetBackupConfigurationResults contains results of the Client.GetBackupConfiguration
type ClientMockGetBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Optional() *mClientMockGetBackupConfiguration {
	mmGetBackupConfiguration.optional = true
	return mmGetBackupConfiguration
}

// Expect sets up expected params for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Expect(ctx context.Context, serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmGetBackupConfiguration.defaultExpectation.params = &ClientMockGetBackupConfigurationParams{ctx, serviceId}
	for _, e := range mmGetBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmGetBackupConfiguration.defaultExpectation.params) {
			mmGetBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmGetBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{}
	}

	if mmGetBackupConfiguration.defaultExpectation.params != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Expect")
	}

	if mmGetBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmGetBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockGetBackupConfigurationParamPtrs{}
	}
	mmGetBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetBackupConfiguration {
	if mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.GetBackupConfiguration")
	}

	mmGetBackupConfiguration.mock.inspectFuncGetBackupConfiguration = f

	return mmGetBackupConfiguration
}

// Return sets up results that will be returned by Client.GetBackupConfiguration
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	if mmGetBackupConfiguration.defaultExpectation == nil {
		mmGetBackupConfiguration.defaultExpectation = &ClientMockGetBackupConfigurationExpectation{mock: mmGetBackupConfiguration.mock}
	}
	mmGetBackupConfiguration.defaultExpectation.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return mmGetBackupConfiguration.mock
}

// Set uses given function f to mock the Client.GetBackupConfiguration method
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Set(f func(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmGetBackupConfiguration.defaultExpectation != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.GetBackupConfiguration method")
	}

	if len(mmGetBackupConfiguration.expectations) > 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.GetBackupConfiguration method")
	}

	mmGetBackupConfiguration.mock.funcGetBackupConfiguration = f
	return mmGetBackupConfiguration.mock
}

// When sets expectation for the Client.GetBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) When(ctx context.Context, serviceId string) *ClientMockGetBackupConfigurationExpectation {
	if mmGetBackupConfiguration.mock.funcGetBackupConfiguration != nil {
		mmGetBackupConfiguration.mock.t.Fatalf("ClientMock.GetBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockGetBackupConfigurationExpectation{
		mock:   mmGetBackupConfiguration.mock,
		params: &ClientMockGetBackupConfigurationParams{ctx, serviceId},
	}
	mmGetBackupConfiguration.expectations = append(mmGetBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.GetBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockGetBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockGetBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.GetBackupConfiguration should be invoked
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Times(n uint64) *mClientMockGetBackupConfiguration {
	if n == 0 {
		mmGetBackupConfiguration.mock.t.Fatalf("Times of ClientMock.GetBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBackupConfiguration.expectedInvocations, n)
	return mmGetBackupConfiguration
}

func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) invocationsDone() bool {
	if len(mmGetBackupConfiguration.expectations) == 0 && mmGetBackupConfiguration.defaultExpectation == nil && mmGetBackupConfiguration.mock.funcGetBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.mock.afterGetBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBackupConfiguration implements Client
func (mmGetBackupConfiguration *ClientMock) GetBackupConfiguration(ctx context.Context, serviceId string) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter, 1)

	if mmGetBackupConfiguration.inspectFuncGetBackupConfiguration != nil {
		mmGetBackupConfiguration.inspectFuncGetBackupConfiguration(ctx, serviceId)
	}

	mm_params := ClientMockGetBackupConfigurationParams{ctx, serviceId}

	// Record call args
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Lock()
	mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs = append(mmGetBackupConfiguration.GetBackupConfigurationMock.callArgs, &mm_params)
	mmGetBackupConfiguration.GetBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmGetBackupConfiguration.GetBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetBackupConfigurationParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBackupConfiguration.t.Errorf("ClientMock.GetBackupConfiguration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBackupConfiguration.GetBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBackupConfiguration.t.Fatal("No results are set for the ClientMock.GetBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBackupConfiguration.funcGetBackupConfiguration != nil {
		return mmGetBackupConfiguration.funcGetBackupConfiguration(ctx, serviceId)
	}
	mmGetBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.GetBackupConfiguration. %v %v", ctx, serviceId)
	return
}

// GetBackupConfigurationAfterCounter returns a count of finished ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.afterGetBackupConfigurationCounter)
}

// GetBackupConfigurationBeforeCounter returns a count of ClientMock.GetBackupConfiguration invocations
func (mmGetBackupConfiguration *ClientMock) GetBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBackupConfiguration.beforeGetBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBackupConfiguration *mClientMockGetBackupConfiguration) Calls() []*ClientMockGetBackupConfigurationParams {
	mmGetBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockGetBackupConfigurationParams, len(mmGetBackupConfiguration.callArgs))
	copy(argCopy, mmGetBackupConfiguration.callArgs)

	mmGetBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockGetBackupConfigurationDone returns true if the count of the GetBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetBackupConfigurationDone() bool {
	if m.GetBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBackupConfigurationMock.invocationsDone()
}

// MinimockGetBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockGetBackupConfigurationInspect() {
	for _, e := range m.GetBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration with params: %#v", *e.params)
		}
	}

	afterGetBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterGetBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBackupConfigurationMock.defaultExpectation != nil && afterGetBackupConfigurationCounter < 1 {
		if m.GetBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetBackupConfiguration")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetBackupConfiguration with params: %#v", *m.GetBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBackupConfiguration != nil && afterGetBackupConfigurationCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetBackupConfiguration")
	}

	if !m.GetBackupConfigurationMock.invocationsDone() && afterGetBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetBackupConfiguration but found %d calls",
			mm_atomic.LoadUint64(&m.GetBackupConfigurationMock.expectedInvocations), afterGetBackupConfigurationCounter)
	}
}

type mClientMockGetOrgPrivateEndpointConfig struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrgPrivateEndpointConfigExpectation
	expectations       []*ClientMockGetOrgPrivateEndpointConfigExpectation

	callArgs []*ClientMockGetOrgPrivateEndpointConfigParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetOrgPrivateEndpointConfigExpectation specifies expectation struct of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetOrgPrivateEndpointConfigParams
	paramPtrs *ClientMockGetOrgPrivateEndpointConfigParamPtrs
	results   *ClientMockGetOrgPrivateEndpointConfigResults
	Counter   uint64
}

// ClientMockGetOrgPrivateEndpointConfigParams contains parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParams struct {
	ctx           context.Context
	cloudProvider string
	region        string
}

// ClientMockGetOrgPrivateEndpointConfigParamPtrs contains pointers to parameters of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigParamPtrs struct {
	ctx           *context.Context
	cloudProvider *string
	region        *string
}

// ClientMockGetOrgPrivateEndpointConfigResults contains results of the Client.GetOrgPrivateEndpointConfig
type ClientMockGetOrgPrivateEndpointConfigResults struct {
	op1 *OrgPrivateEndpointConfig
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Optional() *mClientMockGetOrgPrivateEndpointConfig {
	mmGetOrgPrivateEndpointConfig.optional = true
	return mmGetOrgPrivateEndpointConfig
}

// Expect sets up expected params for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Expect(ctx context.Context, cloudProvider string, region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by ExpectParams functions")
	}

	mmGetOrgPrivateEndpointConfig.defaultExpectation.params = &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}
	for _, e := range mmGetOrgPrivateEndpointConfig.expectations {
		if minimock.Equal(e.params, mmGetOrgPrivateEndpointConfig.defaultExpectation.params) {
			mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrgPrivateEndpointConfig.defaultExpectation.params)
		}
	}

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrgPrivateEndpointConfig
}

// ExpectCloudProviderParam2 sets up expected param cloudProvider for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectCloudProviderParam2(cloudProvider string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.cloudProvider = &cloudProvider

	return mmGetOrgPrivateEndpointConfig
}

// ExpectRegionParam3 sets up expected param region for Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) ExpectRegionParam3(region string) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{}
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.params != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Expect")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs = &ClientMockGetOrgPrivateEndpointConfigParamPtrs{}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.paramPtrs.region = &region

	return mmGetOrgPrivateEndpointConfig
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Inspect(f func(ctx context.Context, cloudProvider string, region string)) *mClientMockGetOrgPrivateEndpointConfig {
	if mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrgPrivateEndpointConfig")
	}

	mmGetOrgPrivateEndpointConfig.mock.inspectFuncGetOrgPrivateEndpointConfig = f

	return mmGetOrgPrivateEndpointConfig
}

// Return sets up results that will be returned by Client.GetOrgPrivateEndpointConfig
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Return(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	if mmGetOrgPrivateEndpointConfig.defaultExpectation == nil {
		mmGetOrgPrivateEndpointConfig.defaultExpectation = &ClientMockGetOrgPrivateEndpointConfigExpectation{mock: mmGetOrgPrivateEndpointConfig.mock}
	}
	mmGetOrgPrivateEndpointConfig.defaultExpectation.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return mmGetOrgPrivateEndpointConfig.mock
}

// Set uses given function f to mock the Client.GetOrgPrivateEndpointConfig method
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Set(f func(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error)) *ClientMock {
	if mmGetOrgPrivateEndpointConfig.defaultExpectation != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Default expectation is already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	if len(mmGetOrgPrivateEndpointConfig.expectations) > 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Some expectations are already set for the Client.GetOrgPrivateEndpointConfig method")
	}

	mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig = f
	return mmGetOrgPrivateEndpointConfig.mock
}

// When sets expectation for the Client.GetOrgPrivateEndpointConfig which will trigger the result defined by the following
// Then helper
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) When(ctx context.Context, cloudProvider string, region string) *ClientMockGetOrgPrivateEndpointConfigExpectation {
	if mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("ClientMock.GetOrgPrivateEndpointConfig mock is already set by Set")
	}

	expectation := &ClientMockGetOrgPrivateEndpointConfigExpectation{
		mock:   mmGetOrgPrivateEndpointConfig.mock,
		params: &ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region},
	}
	mmGetOrgPrivateEndpointConfig.expectations = append(mmGetOrgPrivateEndpointConfig.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrgPrivateEndpointConfig return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrgPrivateEndpointConfigExpectation) Then(op1 *OrgPrivateEndpointConfig, err error) *ClientMock {
	e.results = &ClientMockGetOrgPrivateEndpointConfigResults{op1, err}
	return e.mock
}

// Times sets number of times Client.GetOrgPrivateEndpointConfig should be invoked
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Times(n uint64) *mClientMockGetOrgPrivateEndpointConfig {
	if n == 0 {
		mmGetOrgPrivateEndpointConfig.mock.t.Fatalf("Times of ClientMock.GetOrgPrivateEndpointConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations, n)
	return mmGetOrgPrivateEndpointConfig
}

func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) invocationsDone() bool {
	if len(mmGetOrgPrivateEndpointConfig.expectations) == 0 && mmGetOrgPrivateEndpointConfig.defaultExpectation == nil && mmGetOrgPrivateEndpointConfig.mock.funcGetOrgPrivateEndpointConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.mock.afterGetOrgPrivateEndpointConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrgPrivateEndpointConfig implements Client
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfig(ctx context.Context, cloudProvider string, region string) (op1 *OrgPrivateEndpointConfig, err error) {
	mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter, 1)

	if mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig != nil {
		mmGetOrgPrivateEndpointConfig.inspectFuncGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}

	mm_params := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

	// Record call args
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Lock()
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs = append(mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.callArgs, &mm_params)
	mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.mutex.Unlock()

	for _, e := range mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrgPrivateEndpointConfigParams{ctx, cloudProvider, region}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cloudProvider != nil && !minimock.Equal(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter cloudProvider, want: %#v, got: %#v%s\n", *mm_want_ptrs.cloudProvider, mm_got.cloudProvider, minimock.Diff(*mm_want_ptrs.cloudProvider, mm_got.cloudProvider))
			}

			if mm_want_ptrs.region != nil && !minimock.Equal(*mm_want_ptrs.region, mm_got.region) {
				mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameter region, want: %#v, got: %#v%s\n", *mm_want_ptrs.region, mm_got.region, minimock.Diff(*mm_want_ptrs.region, mm_got.region))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrgPrivateEndpointConfig.t.Errorf("ClientMock.GetOrgPrivateEndpointConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrgPrivateEndpointConfig.GetOrgPrivateEndpointConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrgPrivateEndpointConfig.t.Fatal("No results are set for the ClientMock.GetOrgPrivateEndpointConfig")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig != nil {
		return mmGetOrgPrivateEndpointConfig.funcGetOrgPrivateEndpointConfig(ctx, cloudProvider, region)
	}
	mmGetOrgPrivateEndpointConfig.t.Fatalf("Unexpected call to ClientMock.GetOrgPrivateEndpointConfig. %v %v %v", ctx, cloudProvider, region)
	return
}

// GetOrgPrivateEndpointConfigAfterCounter returns a count of finished ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.afterGetOrgPrivateEndpointConfigCounter)
}

// GetOrgPrivateEndpointConfigBeforeCounter returns a count of ClientMock.GetOrgPrivateEndpointConfig invocations
func (mmGetOrgPrivateEndpointConfig *ClientMock) GetOrgPrivateEndpointConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrgPrivateEndpointConfig.beforeGetOrgPrivateEndpointConfigCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrgPrivateEndpointConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrgPrivateEndpointConfig *mClientMockGetOrgPrivateEndpointConfig) Calls() []*ClientMockGetOrgPrivateEndpointConfigParams {
	mmGetOrgPrivateEndpointConfig.mutex.RLock()

	argCopy := make([]*ClientMockGetOrgPrivateEndpointConfigParams, len(mmGetOrgPrivateEndpointConfig.callArgs))
	copy(argCopy, mmGetOrgPrivateEndpointConfig.callArgs)

	mmGetOrgPrivateEndpointConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrgPrivateEndpointConfigDone returns true if the count of the GetOrgPrivateEndpointConfig invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigDone() bool {
	if m.GetOrgPrivateEndpointConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrgPrivateEndpointConfigMock.invocationsDone()
}

// MinimockGetOrgPrivateEndpointConfigInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrgPrivateEndpointConfigInspect() {
	for _, e := range m.GetOrgPrivateEndpointConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig with params: %#v", *e.params)
		}
	}

	afterGetOrgPrivateEndpointConfigCounter := mm_atomic.LoadUint64(&m.afterGetOrgPrivateEndpointConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrgPrivateEndpointConfigMock.defaultExpectation != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		if m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetOrgPrivateEndpointConfig")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrgPrivateEndpointConfig with params: %#v", *m.GetOrgPrivateEndpointConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrgPrivateEndpointConfig != nil && afterGetOrgPrivateEndpointConfigCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetOrgPrivateEndpointConfig")
	}

	if !m.GetOrgPrivateEndpointConfigMock.invocationsDone() && afterGetOrgPrivateEndpointConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrgPrivateEndpointConfig but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrgPrivateEndpointConfigMock.expectedInvocations), afterGetOrgPrivateEndpointConfigCounter)
	}
}

type mClientMockGetOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockGetOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockGetOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetOrganizationPrivateEndpointsParams
	paramPtrs *ClientMockGetOrganizationPrivateEndpointsParamPtrs
	results   *ClientMockGetOrganizationPrivateEndpointsResults
	Counter   uint64
}

// ClientMockGetOrganizationPrivateEndpointsParams contains parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParams struct {
	ctx context.Context
}

// ClientMockGetOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsParamPtrs struct {
	ctx *context.Context
}

// ClientMockGetOrganizationPrivateEndpointsResults contains results of the Client.GetOrganizationPrivateEndpoints
type ClientMockGetOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Optional() *mClientMockGetOrganizationPrivateEndpoints {
	mmGetOrganizationPrivateEndpoints.optional = true
	return mmGetOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Expect(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmGetOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockGetOrganizationPrivateEndpointsParams{ctx}
	for _, e := range mmGetOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmGetOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmGetOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{}
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockGetOrganizationPrivateEndpointsParamPtrs{}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context)) *mClientMockGetOrganizationPrivateEndpoints {
	if mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.GetOrganizationPrivateEndpoints")
	}

	mmGetOrganizationPrivateEndpoints.mock.inspectFuncGetOrganizationPrivateEndpoints = f

	return mmGetOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.GetOrganizationPrivateEndpoints
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmGetOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmGetOrganizationPrivateEndpoints.defaultExpectation = &ClientMockGetOrganizationPrivateEndpointsExpectation{mock: mmGetOrganizationPrivateEndpoints.mock}
	}
	mmGetOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return mmGetOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.GetOrganizationPrivateEndpoints method
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Set(f func(ctx context.Context) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmGetOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	if len(mmGetOrganizationPrivateEndpoints.expectations) > 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.GetOrganizationPrivateEndpoints method")
	}

	mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints = f
	return mmGetOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.GetOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) When(ctx context.Context) *ClientMockGetOrganizationPrivateEndpointsExpectation {
	if mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.GetOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockGetOrganizationPrivateEndpointsExpectation{
		mock:   mmGetOrganizationPrivateEndpoints.mock,
		params: &ClientMockGetOrganizationPrivateEndpointsParams{ctx},
	}
	mmGetOrganizationPrivateEndpoints.expectations = append(mmGetOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.GetOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockGetOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockGetOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.GetOrganizationPrivateEndpoints should be invoked
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Times(n uint64) *mClientMockGetOrganizationPrivateEndpoints {
	if n == 0 {
		mmGetOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.GetOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations, n)
	return mmGetOrganizationPrivateEndpoints
}

func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmGetOrganizationPrivateEndpoints.expectations) == 0 && mmGetOrganizationPrivateEndpoints.defaultExpectation == nil && mmGetOrganizationPrivateEndpoints.mock.funcGetOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.mock.afterGetOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationPrivateEndpoints implements Client
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpoints(ctx context.Context) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter, 1)

	if mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints != nil {
		mmGetOrganizationPrivateEndpoints.inspectFuncGetOrganizationPrivateEndpoints(ctx)
	}

	mm_params := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

	// Record call args
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Lock()
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs = append(mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetOrganizationPrivateEndpointsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationPrivateEndpoints.t.Errorf("ClientMock.GetOrganizationPrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationPrivateEndpoints.GetOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.GetOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints != nil {
		return mmGetOrganizationPrivateEndpoints.funcGetOrganizationPrivateEndpoints(ctx)
	}
	mmGetOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.GetOrganizationPrivateEndpoints. %v", ctx)
	return
}

// GetOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.afterGetOrganizationPrivateEndpointsCounter)
}

// GetOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.GetOrganizationPrivateEndpoints invocations
func (mmGetOrganizationPrivateEndpoints *ClientMock) GetOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationPrivateEndpoints.beforeGetOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationPrivateEndpoints *mClientMockGetOrganizationPrivateEndpoints) Calls() []*ClientMockGetOrganizationPrivateEndpointsParams {
	mmGetOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockGetOrganizationPrivateEndpointsParams, len(mmGetOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmGetOrganizationPrivateEndpoints.callArgs)

	mmGetOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationPrivateEndpointsDone returns true if the count of the GetOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsDone() bool {
	if m.GetOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockGetOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetOrganizationPrivateEndpointsInspect() {
	for _, e := range m.GetOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterGetOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		if m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetOrganizationPrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetOrganizationPrivateEndpoints with params: %#v", *m.GetOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationPrivateEndpoints != nil && afterGetOrganizationPrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetOrganizationPrivateEndpoints")
	}

	if !m.GetOrganizationPrivateEndpointsMock.invocationsDone() && afterGetOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetOrganizationPrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationPrivateEndpointsMock.expectedInvocations), afterGetOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockGetService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetServiceExpectation
	expectations       []*ClientMockGetServiceExpectation

	callArgs []*ClientMockGetServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockGetServiceExpectation specifies expectation struct of the Client.GetService
type ClientMockGetServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockGetServiceParams
	paramPtrs *ClientMockGetServiceParamPtrs
	results   *ClientMockGetServiceResults
	Counter   uint64
}

// ClientMockGetServiceParams contains parameters of the Client.GetService
type ClientMockGetServiceParams struct {
	ctx       context.Context
	serviceId string
}

// ClientMockGetServiceParamPtrs contains pointers to parameters of the Client.GetService
type ClientMockGetServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
}

// ClientMockGetServiceResults contains results of the Client.GetService
type ClientMockGetServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetService *mClientMockGetService) Optional() *mClientMockGetService {
	mmGetService.optional = true
	return mmGetService
}

// Expect sets up expected params for Client.GetService
func (mmGetService *mClientMockGetService) Expect(ctx context.Context, serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.paramPtrs != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by ExpectParams functions")
	}

	mmGetService.defaultExpectation.params = &ClientMockGetServiceParams{ctx, serviceId}
	for _, e := range mmGetService.expectations {
		if minimock.Equal(e.params, mmGetService.defaultExpectation.params) {
			mmGetService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetService.defaultExpectation.params)
		}
	}

	return mmGetService
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetService
func (mmGetService *mClientMockGetService) ExpectCtxParam1(ctx context.Context) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.GetService
func (mmGetService *mClientMockGetService) ExpectServiceIdParam2(serviceId string) *mClientMockGetService {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{}
	}

	if mmGetService.defaultExpectation.params != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Expect")
	}

	if mmGetService.defaultExpectation.paramPtrs == nil {
		mmGetService.defaultExpectation.paramPtrs = &ClientMockGetServiceParamPtrs{}
	}
	mmGetService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmGetService
}

// Inspect accepts an inspector function that has same arguments as the Client.GetService
func (mmGetService *mClientMockGetService) Inspect(f func(ctx context.Context, serviceId string)) *mClientMockGetService {
	if mmGetService.mock.inspectFuncGetService != nil {
		mmGetService.mock.t.Fatalf("Inspect function is already set for ClientMock.GetService")
	}

	mmGetService.mock.inspectFuncGetService = f

	return mmGetService
}

// Return sets up results that will be returned by Client.GetService
func (mmGetService *mClientMockGetService) Return(sp1 *Service, err error) *ClientMock {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	if mmGetService.defaultExpectation == nil {
		mmGetService.defaultExpectation = &ClientMockGetServiceExpectation{mock: mmGetService.mock}
	}
	mmGetService.defaultExpectation.results = &ClientMockGetServiceResults{sp1, err}
	return mmGetService.mock
}

// Set uses given function f to mock the Client.GetService method
func (mmGetService *mClientMockGetService) Set(f func(ctx context.Context, serviceId string) (sp1 *Service, err error)) *ClientMock {
	if mmGetService.defaultExpectation != nil {
		mmGetService.mock.t.Fatalf("Default expectation is already set for the Client.GetService method")
	}

	if len(mmGetService.expectations) > 0 {
		mmGetService.mock.t.Fatalf("Some expectations are already set for the Client.GetService method")
	}

	mmGetService.mock.funcGetService = f
	return mmGetService.mock
}

// When sets expectation for the Client.GetService which will trigger the result defined by the following
// Then helper
func (mmGetService *mClientMockGetService) When(ctx context.Context, serviceId string) *ClientMockGetServiceExpectation {
	if mmGetService.mock.funcGetService != nil {
		mmGetService.mock.t.Fatalf("ClientMock.GetService mock is already set by Set")
	}

	expectation := &ClientMockGetServiceExpectation{
		mock:   mmGetService.mock,
		params: &ClientMockGetServiceParams{ctx, serviceId},
	}
	mmGetService.expectations = append(mmGetService.expectations, expectation)
	return expectation
}

// Then sets up Client.GetService return parameters for the expectation previously defined by the When method
func (e *ClientMockGetServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockGetServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.GetService should be invoked
func (mmGetService *mClientMockGetService) Times(n uint64) *mClientMockGetService {
	if n == 0 {
		mmGetService.mock.t.Fatalf("Times of ClientMock.GetService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetService.expectedInvocations, n)
	return mmGetService
}

func (mmGetService *mClientMockGetService) invocationsDone() bool {
	if len(mmGetService.expectations) == 0 && mmGetService.defaultExpectation == nil && mmGetService.mock.funcGetService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetService.mock.afterGetServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetService implements Client
func (mmGetService *ClientMock) GetService(ctx context.Context, serviceId string) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmGetService.beforeGetServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetService.afterGetServiceCounter, 1)

	if mmGetService.inspectFuncGetService != nil {
		mmGetService.inspectFuncGetService(ctx, serviceId)
	}

	mm_params := ClientMockGetServiceParams{ctx, serviceId}

	// Record call args
	mmGetService.GetServiceMock.mutex.Lock()
	mmGetService.GetServiceMock.callArgs = append(mmGetService.GetServiceMock.callArgs, &mm_params)
	mmGetService.GetServiceMock.mutex.Unlock()

	for _, e := range mmGetService.GetServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetService.GetServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetService.GetServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetService.GetServiceMock.defaultExpectation.params
		mm_want_ptrs := mmGetService.GetServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetServiceParams{ctx, serviceId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmGetService.t.Errorf("ClientMock.GetService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetService.t.Errorf("ClientMock.GetService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetService.GetServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetService.t.Fatal("No results are set for the ClientMock.GetService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetService.funcGetService != nil {
		return mmGetService.funcGetService(ctx, serviceId)
	}
	mmGetService.t.Fatalf("Unexpected call to ClientMock.GetService. %v %v", ctx, serviceId)
	return
}

// GetServiceAfterCounter returns a count of finished ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.afterGetServiceCounter)
}

// GetServiceBeforeCounter returns a count of ClientMock.GetService invocations
func (mmGetService *ClientMock) GetServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetService.beforeGetServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetService *mClientMockGetService) Calls() []*ClientMockGetServiceParams {
	mmGetService.mutex.RLock()

	argCopy := make([]*ClientMockGetServiceParams, len(mmGetService.callArgs))
	copy(argCopy, mmGetService.callArgs)

	mmGetService.mutex.RUnlock()

	return argCopy
}

// MinimockGetServiceDone returns true if the count of the GetService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetServiceDone() bool {
	if m.GetServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetServiceMock.invocationsDone()
}

// MinimockGetServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockGetServiceInspect() {
	for _, e := range m.GetServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetService with params: %#v", *e.params)
		}
	}

	afterGetServiceCounter := mm_atomic.LoadUint64(&m.afterGetServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetServiceMock.defaultExpectation != nil && afterGetServiceCounter < 1 {
		if m.GetServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetService")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetService with params: %#v", *m.GetServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetService != nil && afterGetServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.GetService")
	}

	if !m.GetServiceMock.invocationsDone() && afterGetServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetService but found %d calls",
			mm_atomic.LoadUint64(&m.GetServiceMock.expectedInvocations), afterGetServiceCounter)
	}
}

type mClientMockUpdateBackupConfiguration struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateBackupConfigurationExpectation
	expectations       []*ClientMockUpdateBackupConfigurationExpectation

	callArgs []*ClientMockUpdateBackupConfigurationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateBackupConfigurationExpectation specifies expectation struct of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateBackupConfigurationParams
	paramPtrs *ClientMockUpdateBackupConfigurationParamPtrs
	results   *ClientMockUpdateBackupConfigurationResults
	Counter   uint64
}

// ClientMockUpdateBackupConfigurationParams contains parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParams struct {
	ctx       context.Context
	serviceId string
	b         BackupConfiguration
}

// ClientMockUpdateBackupConfigurationParamPtrs contains pointers to parameters of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	b         *BackupConfiguration
}

// ClientMockUpdateBackupConfigurationResults contains results of the Client.UpdateBackupConfiguration
type ClientMockUpdateBackupConfigurationResults struct {
	bp1 *BackupConfiguration
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Optional() *mClientMockUpdateBackupConfiguration {
	mmUpdateBackupConfiguration.optional = true
	return mmUpdateBackupConfiguration
}

// Expect sets up expected params for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Expect(ctx context.Context, serviceId string, b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by ExpectParams functions")
	}

	mmUpdateBackupConfiguration.defaultExpectation.params = &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}
	for _, e := range mmUpdateBackupConfiguration.expectations {
		if minimock.Equal(e.params, mmUpdateBackupConfiguration.defaultExpectation.params) {
			mmUpdateBackupConfiguration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBackupConfiguration.defaultExpectation.params)
		}
	}

	return mmUpdateBackupConfiguration
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateBackupConfiguration
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateBackupConfiguration
}

// ExpectBParam3 sets up expected param b for Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) ExpectBParam3(b BackupConfiguration) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{}
	}

	if mmUpdateBackupConfiguration.defaultExpectation.params != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Expect")
	}

	if mmUpdateBackupConfiguration.defaultExpectation.paramPtrs == nil {
		mmUpdateBackupConfiguration.defaultExpectation.paramPtrs = &ClientMockUpdateBackupConfigurationParamPtrs{}
	}
	mmUpdateBackupConfiguration.defaultExpectation.paramPtrs.b = &b

	return mmUpdateBackupConfiguration
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Inspect(f func(ctx context.Context, serviceId string, b BackupConfiguration)) *mClientMockUpdateBackupConfiguration {
	if mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateBackupConfiguration")
	}

	mmUpdateBackupConfiguration.mock.inspectFuncUpdateBackupConfiguration = f

	return mmUpdateBackupConfiguration
}

// Return sets up results that will be returned by Client.UpdateBackupConfiguration
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Return(bp1 *BackupConfiguration, err error) *ClientMock {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	if mmUpdateBackupConfiguration.defaultExpectation == nil {
		mmUpdateBackupConfiguration.defaultExpectation = &ClientMockUpdateBackupConfigurationExpectation{mock: mmUpdateBackupConfiguration.mock}
	}
	mmUpdateBackupConfiguration.defaultExpectation.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return mmUpdateBackupConfiguration.mock
}

// Set uses given function f to mock the Client.UpdateBackupConfiguration method
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Set(f func(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error)) *ClientMock {
	if mmUpdateBackupConfiguration.defaultExpectation != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Default expectation is already set for the Client.UpdateBackupConfiguration method")
	}

	if len(mmUpdateBackupConfiguration.expectations) > 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Some expectations are already set for the Client.UpdateBackupConfiguration method")
	}

	mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration = f
	return mmUpdateBackupConfiguration.mock
}

// When sets expectation for the Client.UpdateBackupConfiguration which will trigger the result defined by the following
// Then helper
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) When(ctx context.Context, serviceId string, b BackupConfiguration) *ClientMockUpdateBackupConfigurationExpectation {
	if mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.mock.t.Fatalf("ClientMock.UpdateBackupConfiguration mock is already set by Set")
	}

	expectation := &ClientMockUpdateBackupConfigurationExpectation{
		mock:   mmUpdateBackupConfiguration.mock,
		params: &ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b},
	}
	mmUpdateBackupConfiguration.expectations = append(mmUpdateBackupConfiguration.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateBackupConfiguration return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateBackupConfigurationExpectation) Then(bp1 *BackupConfiguration, err error) *ClientMock {
	e.results = &ClientMockUpdateBackupConfigurationResults{bp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateBackupConfiguration should be invoked
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Times(n uint64) *mClientMockUpdateBackupConfiguration {
	if n == 0 {
		mmUpdateBackupConfiguration.mock.t.Fatalf("Times of ClientMock.UpdateBackupConfiguration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateBackupConfiguration.expectedInvocations, n)
	return mmUpdateBackupConfiguration
}

func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) invocationsDone() bool {
	if len(mmUpdateBackupConfiguration.expectations) == 0 && mmUpdateBackupConfiguration.defaultExpectation == nil && mmUpdateBackupConfiguration.mock.funcUpdateBackupConfiguration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.mock.afterUpdateBackupConfigurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateBackupConfiguration implements Client
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfiguration(ctx context.Context, serviceId string, b BackupConfiguration) (bp1 *BackupConfiguration, err error) {
	mm_atomic.AddUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter, 1)

	if mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration != nil {
		mmUpdateBackupConfiguration.inspectFuncUpdateBackupConfiguration(ctx, serviceId, b)
	}

	mm_params := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

	// Record call args
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Lock()
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs = append(mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.callArgs, &mm_params)
	mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.mutex.Unlock()

	for _, e := range mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateBackupConfigurationParams{ctx, serviceId, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameter b, want: %#v, got: %#v%s\n", *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBackupConfiguration.t.Errorf("ClientMock.UpdateBackupConfiguration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBackupConfiguration.UpdateBackupConfigurationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBackupConfiguration.t.Fatal("No results are set for the ClientMock.UpdateBackupConfiguration")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmUpdateBackupConfiguration.funcUpdateBackupConfiguration != nil {
		return mmUpdateBackupConfiguration.funcUpdateBackupConfiguration(ctx, serviceId, b)
	}
	mmUpdateBackupConfiguration.t.Fatalf("Unexpected call to ClientMock.UpdateBackupConfiguration. %v %v %v", ctx, serviceId, b)
	return
}

// UpdateBackupConfigurationAfterCounter returns a count of finished ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.afterUpdateBackupConfigurationCounter)
}

// UpdateBackupConfigurationBeforeCounter returns a count of ClientMock.UpdateBackupConfiguration invocations
func (mmUpdateBackupConfiguration *ClientMock) UpdateBackupConfigurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBackupConfiguration.beforeUpdateBackupConfigurationCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateBackupConfiguration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBackupConfiguration *mClientMockUpdateBackupConfiguration) Calls() []*ClientMockUpdateBackupConfigurationParams {
	mmUpdateBackupConfiguration.mutex.RLock()

	argCopy := make([]*ClientMockUpdateBackupConfigurationParams, len(mmUpdateBackupConfiguration.callArgs))
	copy(argCopy, mmUpdateBackupConfiguration.callArgs)

	mmUpdateBackupConfiguration.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBackupConfigurationDone returns true if the count of the UpdateBackupConfiguration invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateBackupConfigurationDone() bool {
	if m.UpdateBackupConfigurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateBackupConfigurationMock.invocationsDone()
}

// MinimockUpdateBackupConfigurationInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateBackupConfigurationInspect() {
	for _, e := range m.UpdateBackupConfigurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration with params: %#v", *e.params)
		}
	}

	afterUpdateBackupConfigurationCounter := mm_atomic.LoadUint64(&m.afterUpdateBackupConfigurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBackupConfigurationMock.defaultExpectation != nil && afterUpdateBackupConfigurationCounter < 1 {
		if m.UpdateBackupConfigurationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateBackupConfiguration")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateBackupConfiguration with params: %#v", *m.UpdateBackupConfigurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBackupConfiguration != nil && afterUpdateBackupConfigurationCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateBackupConfiguration")
	}

	if !m.UpdateBackupConfigurationMock.invocationsDone() && afterUpdateBackupConfigurationCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateBackupConfiguration but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateBackupConfigurationMock.expectedInvocations), afterUpdateBackupConfigurationCounter)
	}
}

type mClientMockUpdateOrganizationPrivateEndpoints struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateOrganizationPrivateEndpointsExpectation
	expectations       []*ClientMockUpdateOrganizationPrivateEndpointsExpectation

	callArgs []*ClientMockUpdateOrganizationPrivateEndpointsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsExpectation specifies expectation struct of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateOrganizationPrivateEndpointsParams
	paramPtrs *ClientMockUpdateOrganizationPrivateEndpointsParamPtrs
	results   *ClientMockUpdateOrganizationPrivateEndpointsResults
	Counter   uint64
}

// ClientMockUpdateOrganizationPrivateEndpointsParams contains parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParams struct {
	ctx       context.Context
	orgUpdate OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsParamPtrs contains pointers to parameters of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsParamPtrs struct {
	ctx       *context.Context
	orgUpdate *OrganizationUpdate
}

// ClientMockUpdateOrganizationPrivateEndpointsResults contains results of the Client.UpdateOrganizationPrivateEndpoints
type ClientMockUpdateOrganizationPrivateEndpointsResults struct {
	pap1 *[]PrivateEndpoint
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Optional() *mClientMockUpdateOrganizationPrivateEndpoints {
	mmUpdateOrganizationPrivateEndpoints.optional = true
	return mmUpdateOrganizationPrivateEndpoints
}

// Expect sets up expected params for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Expect(ctx context.Context, orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by ExpectParams functions")
	}

	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params = &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}
	for _, e := range mmUpdateOrganizationPrivateEndpoints.expectations {
		if minimock.Equal(e.params, mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params) {
			mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params)
		}
	}

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateOrganizationPrivateEndpoints
}

// ExpectOrgUpdateParam2 sets up expected param orgUpdate for Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) ExpectOrgUpdateParam2(orgUpdate OrganizationUpdate) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{}
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.params != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Expect")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs = &ClientMockUpdateOrganizationPrivateEndpointsParamPtrs{}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.paramPtrs.orgUpdate = &orgUpdate

	return mmUpdateOrganizationPrivateEndpoints
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Inspect(f func(ctx context.Context, orgUpdate OrganizationUpdate)) *mClientMockUpdateOrganizationPrivateEndpoints {
	if mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.inspectFuncUpdateOrganizationPrivateEndpoints = f

	return mmUpdateOrganizationPrivateEndpoints
}

// Return sets up results that will be returned by Client.UpdateOrganizationPrivateEndpoints
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Return(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil {
		mmUpdateOrganizationPrivateEndpoints.defaultExpectation = &ClientMockUpdateOrganizationPrivateEndpointsExpectation{mock: mmUpdateOrganizationPrivateEndpoints.mock}
	}
	mmUpdateOrganizationPrivateEndpoints.defaultExpectation.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// Set uses given function f to mock the Client.UpdateOrganizationPrivateEndpoints method
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Set(f func(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error)) *ClientMock {
	if mmUpdateOrganizationPrivateEndpoints.defaultExpectation != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Default expectation is already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	if len(mmUpdateOrganizationPrivateEndpoints.expectations) > 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Some expectations are already set for the Client.UpdateOrganizationPrivateEndpoints method")
	}

	mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints = f
	return mmUpdateOrganizationPrivateEndpoints.mock
}

// When sets expectation for the Client.UpdateOrganizationPrivateEndpoints which will trigger the result defined by the following
// Then helper
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) When(ctx context.Context, orgUpdate OrganizationUpdate) *ClientMockUpdateOrganizationPrivateEndpointsExpectation {
	if mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("ClientMock.UpdateOrganizationPrivateEndpoints mock is already set by Set")
	}

	expectation := &ClientMockUpdateOrganizationPrivateEndpointsExpectation{
		mock:   mmUpdateOrganizationPrivateEndpoints.mock,
		params: &ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate},
	}
	mmUpdateOrganizationPrivateEndpoints.expectations = append(mmUpdateOrganizationPrivateEndpoints.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateOrganizationPrivateEndpoints return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateOrganizationPrivateEndpointsExpectation) Then(pap1 *[]PrivateEndpoint, err error) *ClientMock {
	e.results = &ClientMockUpdateOrganizationPrivateEndpointsResults{pap1, err}
	return e.mock
}

// Times sets number of times Client.UpdateOrganizationPrivateEndpoints should be invoked
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Times(n uint64) *mClientMockUpdateOrganizationPrivateEndpoints {
	if n == 0 {
		mmUpdateOrganizationPrivateEndpoints.mock.t.Fatalf("Times of ClientMock.UpdateOrganizationPrivateEndpoints mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations, n)
	return mmUpdateOrganizationPrivateEndpoints
}

func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) invocationsDone() bool {
	if len(mmUpdateOrganizationPrivateEndpoints.expectations) == 0 && mmUpdateOrganizationPrivateEndpoints.defaultExpectation == nil && mmUpdateOrganizationPrivateEndpoints.mock.funcUpdateOrganizationPrivateEndpoints == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.mock.afterUpdateOrganizationPrivateEndpointsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrganizationPrivateEndpoints implements Client
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpoints(ctx context.Context, orgUpdate OrganizationUpdate) (pap1 *[]PrivateEndpoint, err error) {
	mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter, 1)

	if mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints != nil {
		mmUpdateOrganizationPrivateEndpoints.inspectFuncUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}

	mm_params := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

	// Record call args
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Lock()
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs = append(mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.callArgs, &mm_params)
	mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.mutex.Unlock()

	for _, e := range mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pap1, e.results.err
		}
	}

	if mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateOrganizationPrivateEndpointsParams{ctx, orgUpdate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orgUpdate != nil && !minimock.Equal(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate) {
				mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameter orgUpdate, want: %#v, got: %#v%s\n", *mm_want_ptrs.orgUpdate, mm_got.orgUpdate, minimock.Diff(*mm_want_ptrs.orgUpdate, mm_got.orgUpdate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrganizationPrivateEndpoints.t.Errorf("ClientMock.UpdateOrganizationPrivateEndpoints got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrganizationPrivateEndpoints.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrganizationPrivateEndpoints.t.Fatal("No results are set for the ClientMock.UpdateOrganizationPrivateEndpoints")
		}
		return (*mm_results).pap1, (*mm_results).err
	}
	if mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints != nil {
		return mmUpdateOrganizationPrivateEndpoints.funcUpdateOrganizationPrivateEndpoints(ctx, orgUpdate)
	}
	mmUpdateOrganizationPrivateEndpoints.t.Fatalf("Unexpected call to ClientMock.UpdateOrganizationPrivateEndpoints. %v %v", ctx, orgUpdate)
	return
}

// UpdateOrganizationPrivateEndpointsAfterCounter returns a count of finished ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.afterUpdateOrganizationPrivateEndpointsCounter)
}

// UpdateOrganizationPrivateEndpointsBeforeCounter returns a count of ClientMock.UpdateOrganizationPrivateEndpoints invocations
func (mmUpdateOrganizationPrivateEndpoints *ClientMock) UpdateOrganizationPrivateEndpointsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationPrivateEndpoints.beforeUpdateOrganizationPrivateEndpointsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateOrganizationPrivateEndpoints.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrganizationPrivateEndpoints *mClientMockUpdateOrganizationPrivateEndpoints) Calls() []*ClientMockUpdateOrganizationPrivateEndpointsParams {
	mmUpdateOrganizationPrivateEndpoints.mutex.RLock()

	argCopy := make([]*ClientMockUpdateOrganizationPrivateEndpointsParams, len(mmUpdateOrganizationPrivateEndpoints.callArgs))
	copy(argCopy, mmUpdateOrganizationPrivateEndpoints.callArgs)

	mmUpdateOrganizationPrivateEndpoints.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrganizationPrivateEndpointsDone returns true if the count of the UpdateOrganizationPrivateEndpoints invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsDone() bool {
	if m.UpdateOrganizationPrivateEndpointsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrganizationPrivateEndpointsMock.invocationsDone()
}

// MinimockUpdateOrganizationPrivateEndpointsInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateOrganizationPrivateEndpointsInspect() {
	for _, e := range m.UpdateOrganizationPrivateEndpointsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints with params: %#v", *e.params)
		}
	}

	afterUpdateOrganizationPrivateEndpointsCounter := mm_atomic.LoadUint64(&m.afterUpdateOrganizationPrivateEndpointsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		if m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints with params: %#v", *m.UpdateOrganizationPrivateEndpointsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrganizationPrivateEndpoints != nil && afterUpdateOrganizationPrivateEndpointsCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateOrganizationPrivateEndpoints")
	}

	if !m.UpdateOrganizationPrivateEndpointsMock.invocationsDone() && afterUpdateOrganizationPrivateEndpointsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateOrganizationPrivateEndpoints but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrganizationPrivateEndpointsMock.expectedInvocations), afterUpdateOrganizationPrivateEndpointsCounter)
	}
}

type mClientMockUpdateReplicaScaling struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateReplicaScalingExpectation
	expectations       []*ClientMockUpdateReplicaScalingExpectation

	callArgs []*ClientMockUpdateReplicaScalingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateReplicaScalingExpectation specifies expectation struct of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateReplicaScalingParams
	paramPtrs *ClientMockUpdateReplicaScalingParamPtrs
	results   *ClientMockUpdateReplicaScalingResults
	Counter   uint64
}

// ClientMockUpdateReplicaScalingParams contains parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParams struct {
	ctx       context.Context
	serviceId string
	s         ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingParamPtrs contains pointers to parameters of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ReplicaScalingUpdate
}

// ClientMockUpdateReplicaScalingResults contains results of the Client.UpdateReplicaScaling
type ClientMockUpdateReplicaScalingResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Optional() *mClientMockUpdateReplicaScaling {
	mmUpdateReplicaScaling.optional = true
	return mmUpdateReplicaScaling
}

// Expect sets up expected params for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Expect(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by ExpectParams functions")
	}

	mmUpdateReplicaScaling.defaultExpectation.params = &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}
	for _, e := range mmUpdateReplicaScaling.expectations {
		if minimock.Equal(e.params, mmUpdateReplicaScaling.defaultExpectation.params) {
			mmUpdateReplicaScaling.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReplicaScaling.defaultExpectation.params)
		}
	}

	return mmUpdateReplicaScaling
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateReplicaScaling
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateReplicaScaling
}

// ExpectSParam3 sets up expected param s for Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) ExpectSParam3(s ReplicaScalingUpdate) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{}
	}

	if mmUpdateReplicaScaling.defaultExpectation.params != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Expect")
	}

	if mmUpdateReplicaScaling.defaultExpectation.paramPtrs == nil {
		mmUpdateReplicaScaling.defaultExpectation.paramPtrs = &ClientMockUpdateReplicaScalingParamPtrs{}
	}
	mmUpdateReplicaScaling.defaultExpectation.paramPtrs.s = &s

	return mmUpdateReplicaScaling
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Inspect(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate)) *mClientMockUpdateReplicaScaling {
	if mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateReplicaScaling")
	}

	mmUpdateReplicaScaling.mock.inspectFuncUpdateReplicaScaling = f

	return mmUpdateReplicaScaling
}

// Return sets up results that will be returned by Client.UpdateReplicaScaling
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	if mmUpdateReplicaScaling.defaultExpectation == nil {
		mmUpdateReplicaScaling.defaultExpectation = &ClientMockUpdateReplicaScalingExpectation{mock: mmUpdateReplicaScaling.mock}
	}
	mmUpdateReplicaScaling.defaultExpectation.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return mmUpdateReplicaScaling.mock
}

// Set uses given function f to mock the Client.UpdateReplicaScaling method
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Set(f func(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateReplicaScaling.defaultExpectation != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("Default expectation is already set for the Client.UpdateReplicaScaling method")
	}

	if len(mmUpdateReplicaScaling.expectations) > 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Some expectations are already set for the Client.UpdateReplicaScaling method")
	}

	mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling = f
	return mmUpdateReplicaScaling.mock
}

// When sets expectation for the Client.UpdateReplicaScaling which will trigger the result defined by the following
// Then helper
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) When(ctx context.Context, serviceId string, s ReplicaScalingUpdate) *ClientMockUpdateReplicaScalingExpectation {
	if mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.mock.t.Fatalf("ClientMock.UpdateReplicaScaling mock is already set by Set")
	}

	expectation := &ClientMockUpdateReplicaScalingExpectation{
		mock:   mmUpdateReplicaScaling.mock,
		params: &ClientMockUpdateReplicaScalingParams{ctx, serviceId, s},
	}
	mmUpdateReplicaScaling.expectations = append(mmUpdateReplicaScaling.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateReplicaScaling return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateReplicaScalingExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateReplicaScalingResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateReplicaScaling should be invoked
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Times(n uint64) *mClientMockUpdateReplicaScaling {
	if n == 0 {
		mmUpdateReplicaScaling.mock.t.Fatalf("Times of ClientMock.UpdateReplicaScaling mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReplicaScaling.expectedInvocations, n)
	return mmUpdateReplicaScaling
}

func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) invocationsDone() bool {
	if len(mmUpdateReplicaScaling.expectations) == 0 && mmUpdateReplicaScaling.defaultExpectation == nil && mmUpdateReplicaScaling.mock.funcUpdateReplicaScaling == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.mock.afterUpdateReplicaScalingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReplicaScaling.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReplicaScaling implements Client
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScaling(ctx context.Context, serviceId string, s ReplicaScalingUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter, 1)

	if mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling != nil {
		mmUpdateReplicaScaling.inspectFuncUpdateReplicaScaling(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

	// Record call args
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Lock()
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs = append(mmUpdateReplicaScaling.UpdateReplicaScalingMock.callArgs, &mm_params)
	mmUpdateReplicaScaling.UpdateReplicaScalingMock.mutex.Unlock()

	for _, e := range mmUpdateReplicaScaling.UpdateReplicaScalingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateReplicaScalingParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReplicaScaling.t.Errorf("ClientMock.UpdateReplicaScaling got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReplicaScaling.UpdateReplicaScalingMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReplicaScaling.t.Fatal("No results are set for the ClientMock.UpdateReplicaScaling")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateReplicaScaling.funcUpdateReplicaScaling != nil {
		return mmUpdateReplicaScaling.funcUpdateReplicaScaling(ctx, serviceId, s)
	}
	mmUpdateReplicaScaling.t.Fatalf("Unexpected call to ClientMock.UpdateReplicaScaling. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateReplicaScalingAfterCounter returns a count of finished ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.afterUpdateReplicaScalingCounter)
}

// UpdateReplicaScalingBeforeCounter returns a count of ClientMock.UpdateReplicaScaling invocations
func (mmUpdateReplicaScaling *ClientMock) UpdateReplicaScalingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReplicaScaling.beforeUpdateReplicaScalingCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateReplicaScaling.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReplicaScaling *mClientMockUpdateReplicaScaling) Calls() []*ClientMockUpdateReplicaScalingParams {
	mmUpdateReplicaScaling.mutex.RLock()

	argCopy := make([]*ClientMockUpdateReplicaScalingParams, len(mmUpdateReplicaScaling.callArgs))
	copy(argCopy, mmUpdateReplicaScaling.callArgs)

	mmUpdateReplicaScaling.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReplicaScalingDone returns true if the count of the UpdateReplicaScaling invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateReplicaScalingDone() bool {
	if m.UpdateReplicaScalingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReplicaScalingMock.invocationsDone()
}

// MinimockUpdateReplicaScalingInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateReplicaScalingInspect() {
	for _, e := range m.UpdateReplicaScalingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling with params: %#v", *e.params)
		}
	}

	afterUpdateReplicaScalingCounter := mm_atomic.LoadUint64(&m.afterUpdateReplicaScalingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReplicaScalingMock.defaultExpectation != nil && afterUpdateReplicaScalingCounter < 1 {
		if m.UpdateReplicaScalingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateReplicaScaling")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateReplicaScaling with params: %#v", *m.UpdateReplicaScalingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReplicaScaling != nil && afterUpdateReplicaScalingCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateReplicaScaling")
	}

	if !m.UpdateReplicaScalingMock.invocationsDone() && afterUpdateReplicaScalingCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateReplicaScaling but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReplicaScalingMock.expectedInvocations), afterUpdateReplicaScalingCounter)
	}
}

type mClientMockUpdateService struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServiceExpectation
	expectations       []*ClientMockUpdateServiceExpectation

	callArgs []*ClientMockUpdateServiceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateServiceExpectation specifies expectation struct of the Client.UpdateService
type ClientMockUpdateServiceExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateServiceParams
	paramPtrs *ClientMockUpdateServiceParamPtrs
	results   *ClientMockUpdateServiceResults
	Counter   uint64
}

// ClientMockUpdateServiceParams contains parameters of the Client.UpdateService
type ClientMockUpdateServiceParams struct {
	ctx       context.Context
	serviceId string
	s         ServiceUpdate
}

// ClientMockUpdateServiceParamPtrs contains pointers to parameters of the Client.UpdateService
type ClientMockUpdateServiceParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	s         *ServiceUpdate
}

// ClientMockUpdateServiceResults contains results of the Client.UpdateService
type ClientMockUpdateServiceResults struct {
	sp1 *Service
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateService *mClientMockUpdateService) Optional() *mClientMockUpdateService {
	mmUpdateService.optional = true
	return mmUpdateService
}

// Expect sets up expected params for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Expect(ctx context.Context, serviceId string, s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.paramPtrs != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by ExpectParams functions")
	}

	mmUpdateService.defaultExpectation.params = &ClientMockUpdateServiceParams{ctx, serviceId, s}
	for _, e := range mmUpdateService.expectations {
		if minimock.Equal(e.params, mmUpdateService.defaultExpectation.params) {
			mmUpdateService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateService.defaultExpectation.params)
		}
	}

	return mmUpdateService
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateService
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateService
}

// ExpectSParam3 sets up expected param s for Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) ExpectSParam3(s ServiceUpdate) *mClientMockUpdateService {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{}
	}

	if mmUpdateService.defaultExpectation.params != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Expect")
	}

	if mmUpdateService.defaultExpectation.paramPtrs == nil {
		mmUpdateService.defaultExpectation.paramPtrs = &ClientMockUpdateServiceParamPtrs{}
	}
	mmUpdateService.defaultExpectation.paramPtrs.s = &s

	return mmUpdateService
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Inspect(f func(ctx context.Context, serviceId string, s ServiceUpdate)) *mClientMockUpdateService {
	if mmUpdateService.mock.inspectFuncUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateService")
	}

	mmUpdateService.mock.inspectFuncUpdateService = f

	return mmUpdateService
}

// Return sets up results that will be returned by Client.UpdateService
func (mmUpdateService *mClientMockUpdateService) Return(sp1 *Service, err error) *ClientMock {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	if mmUpdateService.defaultExpectation == nil {
		mmUpdateService.defaultExpectation = &ClientMockUpdateServiceExpectation{mock: mmUpdateService.mock}
	}
	mmUpdateService.defaultExpectation.results = &ClientMockUpdateServiceResults{sp1, err}
	return mmUpdateService.mock
}

// Set uses given function f to mock the Client.UpdateService method
func (mmUpdateService *mClientMockUpdateService) Set(f func(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error)) *ClientMock {
	if mmUpdateService.defaultExpectation != nil {
		mmUpdateService.mock.t.Fatalf("Default expectation is already set for the Client.UpdateService method")
	}

	if len(mmUpdateService.expectations) > 0 {
		mmUpdateService.mock.t.Fatalf("Some expectations are already set for the Client.UpdateService method")
	}

	mmUpdateService.mock.funcUpdateService = f
	return mmUpdateService.mock
}

// When sets expectation for the Client.UpdateService which will trigger the result defined by the following
// Then helper
func (mmUpdateService *mClientMockUpdateService) When(ctx context.Context, serviceId string, s ServiceUpdate) *ClientMockUpdateServiceExpectation {
	if mmUpdateService.mock.funcUpdateService != nil {
		mmUpdateService.mock.t.Fatalf("ClientMock.UpdateService mock is already set by Set")
	}

	expectation := &ClientMockUpdateServiceExpectation{
		mock:   mmUpdateService.mock,
		params: &ClientMockUpdateServiceParams{ctx, serviceId, s},
	}
	mmUpdateService.expectations = append(mmUpdateService.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateService return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServiceExpectation) Then(sp1 *Service, err error) *ClientMock {
	e.results = &ClientMockUpdateServiceResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateService should be invoked
func (mmUpdateService *mClientMockUpdateService) Times(n uint64) *mClientMockUpdateService {
	if n == 0 {
		mmUpdateService.mock.t.Fatalf("Times of ClientMock.UpdateService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateService.expectedInvocations, n)
	return mmUpdateService
}

func (mmUpdateService *mClientMockUpdateService) invocationsDone() bool {
	if len(mmUpdateService.expectations) == 0 && mmUpdateService.defaultExpectation == nil && mmUpdateService.mock.funcUpdateService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateService.mock.afterUpdateServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateService implements Client
func (mmUpdateService *ClientMock) UpdateService(ctx context.Context, serviceId string, s ServiceUpdate) (sp1 *Service, err error) {
	mm_atomic.AddUint64(&mmUpdateService.beforeUpdateServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateService.afterUpdateServiceCounter, 1)

	if mmUpdateService.inspectFuncUpdateService != nil {
		mmUpdateService.inspectFuncUpdateService(ctx, serviceId, s)
	}

	mm_params := ClientMockUpdateServiceParams{ctx, serviceId, s}

	// Record call args
	mmUpdateService.UpdateServiceMock.mutex.Lock()
	mmUpdateService.UpdateServiceMock.callArgs = append(mmUpdateService.UpdateServiceMock.callArgs, &mm_params)
	mmUpdateService.UpdateServiceMock.mutex.Unlock()

	for _, e := range mmUpdateService.UpdateServiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateService.UpdateServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateService.UpdateServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateService.UpdateServiceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateService.UpdateServiceMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServiceParams{ctx, serviceId, s}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.s != nil && !minimock.Equal(*mm_want_ptrs.s, mm_got.s) {
				mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameter s, want: %#v, got: %#v%s\n", *mm_want_ptrs.s, mm_got.s, minimock.Diff(*mm_want_ptrs.s, mm_got.s))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateService.t.Errorf("ClientMock.UpdateService got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateService.UpdateServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateService.t.Fatal("No results are set for the ClientMock.UpdateService")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateService.funcUpdateService != nil {
		return mmUpdateService.funcUpdateService(ctx, serviceId, s)
	}
	mmUpdateService.t.Fatalf("Unexpected call to ClientMock.UpdateService. %v %v %v", ctx, serviceId, s)
	return
}

// UpdateServiceAfterCounter returns a count of finished ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.afterUpdateServiceCounter)
}

// UpdateServiceBeforeCounter returns a count of ClientMock.UpdateService invocations
func (mmUpdateService *ClientMock) UpdateServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateService.beforeUpdateServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateService.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateService *mClientMockUpdateService) Calls() []*ClientMockUpdateServiceParams {
	mmUpdateService.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServiceParams, len(mmUpdateService.callArgs))
	copy(argCopy, mmUpdateService.callArgs)

	mmUpdateService.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServiceDone returns true if the count of the UpdateService invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServiceDone() bool {
	if m.UpdateServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServiceMock.invocationsDone()
}

// MinimockUpdateServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServiceInspect() {
	for _, e := range m.UpdateServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateService with params: %#v", *e.params)
		}
	}

	afterUpdateServiceCounter := mm_atomic.LoadUint64(&m.afterUpdateServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServiceMock.defaultExpectation != nil && afterUpdateServiceCounter < 1 {
		if m.UpdateServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateService")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateService with params: %#v", *m.UpdateServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateService != nil && afterUpdateServiceCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateService")
	}

	if !m.UpdateServiceMock.invocationsDone() && afterUpdateServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateService but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServiceMock.expectedInvocations), afterUpdateServiceCounter)
	}
}

type mClientMockUpdateServicePassword struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateServicePasswordExpectation
	expectations       []*ClientMockUpdateServicePasswordExpectation

	callArgs []*ClientMockUpdateServicePasswordParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockUpdateServicePasswordExpectation specifies expectation struct of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordExpectation struct {
	mock      *ClientMock
	params    *ClientMockUpdateServicePasswordParams
	paramPtrs *ClientMockUpdateServicePasswordParamPtrs
	results   *ClientMockUpdateServicePasswordResults
	Counter   uint64
}

// ClientMockUpdateServicePasswordParams contains parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParams struct {
	ctx       context.Context
	serviceId string
	u         ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordParamPtrs contains pointers to parameters of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordParamPtrs struct {
	ctx       *context.Context
	serviceId *string
	u         *ServicePasswordUpdate
}

// ClientMockUpdateServicePasswordResults contains results of the Client.UpdateServicePassword
type ClientMockUpdateServicePasswordResults struct {
	sp1 *ServicePasswordUpdateResult
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Optional() *mClientMockUpdateServicePassword {
	mmUpdateServicePassword.optional = true
	return mmUpdateServicePassword
}

// Expect sets up expected params for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Expect(ctx context.Context, serviceId string, u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by ExpectParams functions")
	}

	mmUpdateServicePassword.defaultExpectation.params = &ClientMockUpdateServicePasswordParams{ctx, serviceId, u}
	for _, e := range mmUpdateServicePassword.expectations {
		if minimock.Equal(e.params, mmUpdateServicePassword.defaultExpectation.params) {
			mmUpdateServicePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateServicePassword.defaultExpectation.params)
		}
	}

	return mmUpdateServicePassword
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateServicePassword
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectServiceIdParam2(serviceId string) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmUpdateServicePassword
}

// ExpectUParam3 sets up expected param u for Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) ExpectUParam3(u ServicePasswordUpdate) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{}
	}

	if mmUpdateServicePassword.defaultExpectation.params != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Expect")
	}

	if mmUpdateServicePassword.defaultExpectation.paramPtrs == nil {
		mmUpdateServicePassword.defaultExpectation.paramPtrs = &ClientMockUpdateServicePasswordParamPtrs{}
	}
	mmUpdateServicePassword.defaultExpectation.paramPtrs.u = &u

	return mmUpdateServicePassword
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Inspect(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate)) *mClientMockUpdateServicePassword {
	if mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateServicePassword")
	}

	mmUpdateServicePassword.mock.inspectFuncUpdateServicePassword = f

	return mmUpdateServicePassword
}

// Return sets up results that will be returned by Client.UpdateServicePassword
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Return(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	if mmUpdateServicePassword.defaultExpectation == nil {
		mmUpdateServicePassword.defaultExpectation = &ClientMockUpdateServicePasswordExpectation{mock: mmUpdateServicePassword.mock}
	}
	mmUpdateServicePassword.defaultExpectation.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return mmUpdateServicePassword.mock
}

// Set uses given function f to mock the Client.UpdateServicePassword method
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Set(f func(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error)) *ClientMock {
	if mmUpdateServicePassword.defaultExpectation != nil {
		mmUpdateServicePassword.mock.t.Fatalf("Default expectation is already set for the Client.UpdateServicePassword method")
	}

	if len(mmUpdateServicePassword.expectations) > 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Some expectations are already set for the Client.UpdateServicePassword method")
	}

	mmUpdateServicePassword.mock.funcUpdateServicePassword = f
	return mmUpdateServicePassword.mock
}

// When sets expectation for the Client.UpdateServicePassword which will trigger the result defined by the following
// Then helper
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) When(ctx context.Context, serviceId string, u ServicePasswordUpdate) *ClientMockUpdateServicePasswordExpectation {
	if mmUpdateServicePassword.mock.funcUpdateServicePassword != nil {
		mmUpdateServicePassword.mock.t.Fatalf("ClientMock.UpdateServicePassword mock is already set by Set")
	}

	expectation := &ClientMockUpdateServicePasswordExpectation{
		mock:   mmUpdateServicePassword.mock,
		params: &ClientMockUpdateServicePasswordParams{ctx, serviceId, u},
	}
	mmUpdateServicePassword.expectations = append(mmUpdateServicePassword.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateServicePassword return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateServicePasswordExpectation) Then(sp1 *ServicePasswordUpdateResult, err error) *ClientMock {
	e.results = &ClientMockUpdateServicePasswordResults{sp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateServicePassword should be invoked
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Times(n uint64) *mClientMockUpdateServicePassword {
	if n == 0 {
		mmUpdateServicePassword.mock.t.Fatalf("Times of ClientMock.UpdateServicePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateServicePassword.expectedInvocations, n)
	return mmUpdateServicePassword
}

func (mmUpdateServicePassword *mClientMockUpdateServicePassword) invocationsDone() bool {
	if len(mmUpdateServicePassword.expectations) == 0 && mmUpdateServicePassword.defaultExpectation == nil && mmUpdateServicePassword.mock.funcUpdateServicePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.mock.afterUpdateServicePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateServicePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateServicePassword implements Client
func (mmUpdateServicePassword *ClientMock) UpdateServicePassword(ctx context.Context, serviceId string, u ServicePasswordUpdate) (sp1 *ServicePasswordUpdateResult, err error) {
	mm_atomic.AddUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter, 1)

	if mmUpdateServicePassword.inspectFuncUpdateServicePassword != nil {
		mmUpdateServicePassword.inspectFuncUpdateServicePassword(ctx, serviceId, u)
	}

	mm_params := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

	// Record call args
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Lock()
	mmUpdateServicePassword.UpdateServicePasswordMock.callArgs = append(mmUpdateServicePassword.UpdateServicePasswordMock.callArgs, &mm_params)
	mmUpdateServicePassword.UpdateServicePasswordMock.mutex.Unlock()

	for _, e := range mmUpdateServicePassword.UpdateServicePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateServicePasswordParams{ctx, serviceId, u}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.u != nil && !minimock.Equal(*mm_want_ptrs.u, mm_got.u) {
				mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameter u, want: %#v, got: %#v%s\n", *mm_want_ptrs.u, mm_got.u, minimock.Diff(*mm_want_ptrs.u, mm_got.u))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateServicePassword.t.Errorf("ClientMock.UpdateServicePassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateServicePassword.UpdateServicePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateServicePassword.t.Fatal("No results are set for the ClientMock.UpdateServicePassword")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateServicePassword.funcUpdateServicePassword != nil {
		return mmUpdateServicePassword.funcUpdateServicePassword(ctx, serviceId, u)
	}
	mmUpdateServicePassword.t.Fatalf("Unexpected call to ClientMock.UpdateServicePassword. %v %v %v", ctx, serviceId, u)
	return
}

// UpdateServicePasswordAfterCounter returns a count of finished ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.afterUpdateServicePasswordCounter)
}

// UpdateServicePasswordBeforeCounter returns a count of ClientMock.UpdateServicePassword invocations
func (mmUpdateServicePassword *ClientMock) UpdateServicePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateServicePassword.beforeUpdateServicePasswordCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateServicePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateServicePassword *mClientMockUpdateServicePassword) Calls() []*ClientMockUpdateServicePasswordParams {
	mmUpdateServicePassword.mutex.RLock()

	argCopy := make([]*ClientMockUpdateServicePasswordParams, len(mmUpdateServicePassword.callArgs))
	copy(argCopy, mmUpdateServicePassword.callArgs)

	mmUpdateServicePassword.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateServicePasswordDone returns true if the count of the UpdateServicePassword invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateServicePasswordDone() bool {
	if m.UpdateServicePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateServicePasswordMock.invocationsDone()
}

// MinimockUpdateServicePasswordInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateServicePasswordInspect() {
	for _, e := range m.UpdateServicePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword with params: %#v", *e.params)
		}
	}

	afterUpdateServicePasswordCounter := mm_atomic.LoadUint64(&m.afterUpdateServicePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateServicePasswordMock.defaultExpectation != nil && afterUpdateServicePasswordCounter < 1 {
		if m.UpdateServicePasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.UpdateServicePassword")
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateServicePassword with params: %#v", *m.UpdateServicePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateServicePassword != nil && afterUpdateServicePasswordCounter < 1 {
		m.t.Error("Expected call to ClientMock.UpdateServicePassword")
	}

	if !m.UpdateServicePasswordMock.invocationsDone() && afterUpdateServicePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateServicePassword but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateServicePasswordMock.expectedInvocations), afterUpdateServicePasswordCounter)
	}
}

type mClientMockWaitForServiceState struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWaitForServiceStateExpectation
	expectations       []*ClientMockWaitForServiceStateExpectation

	callArgs []*ClientMockWaitForServiceStateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ClientMockWaitForServiceStateExpectation specifies expectation struct of the Client.WaitForServiceState
type ClientMockWaitForServiceStateExpectation struct {
	mock      *ClientMock
	params    *ClientMockWaitForServiceStateParams
	paramPtrs *ClientMockWaitForServiceStateParamPtrs
	results   *ClientMockWaitForServiceStateResults
	Counter   uint64
}

// ClientMockWaitForServiceStateParams contains parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParams struct {
	ctx            context.Context
	serviceId      string
	stateChecker   func(string) bool
	maxWaitSeconds int
}

// ClientMockWaitForServiceStateParamPtrs contains pointers to parameters of the Client.WaitForServiceState
type ClientMockWaitForServiceStateParamPtrs struct {
	ctx            *context.Context
	serviceId      *string
	stateChecker   *func(string) bool
	maxWaitSeconds *int
}

// ClientMockWaitForServiceStateResults contains results of the Client.WaitForServiceState
type ClientMockWaitForServiceStateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWaitForServiceState *mClientMockWaitForServiceState) Optional() *mClientMockWaitForServiceState {
	mmWaitForServiceState.optional = true
	return mmWaitForServiceState
}

// Expect sets up expected params for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Expect(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by ExpectParams functions")
	}

	mmWaitForServiceState.defaultExpectation.params = &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}
	for _, e := range mmWaitForServiceState.expectations {
		if minimock.Equal(e.params, mmWaitForServiceState.defaultExpectation.params) {
			mmWaitForServiceState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitForServiceState.defaultExpectation.params)
		}
	}

	return mmWaitForServiceState
}

// ExpectCtxParam1 sets up expected param ctx for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectCtxParam1(ctx context.Context) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.ctx = &ctx

	return mmWaitForServiceState
}

// ExpectServiceIdParam2 sets up expected param serviceId for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectServiceIdParam2(serviceId string) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.serviceId = &serviceId

	return mmWaitForServiceState
}

// ExpectStateCheckerParam3 sets up expected param stateChecker for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectStateCheckerParam3(stateChecker func(string) bool) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.stateChecker = &stateChecker

	return mmWaitForServiceState
}

// ExpectMaxWaitSecondsParam4 sets up expected param maxWaitSeconds for Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) ExpectMaxWaitSecondsParam4(maxWaitSeconds int) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{}
	}

	if mmWaitForServiceState.defaultExpectation.params != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Expect")
	}

	if mmWaitForServiceState.defaultExpectation.paramPtrs == nil {
		mmWaitForServiceState.defaultExpectation.paramPtrs = &ClientMockWaitForServiceStateParamPtrs{}
	}
	mmWaitForServiceState.defaultExpectation.paramPtrs.maxWaitSeconds = &maxWaitSeconds

	return mmWaitForServiceState
}

// Inspect accepts an inspector function that has same arguments as the Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Inspect(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int)) *mClientMockWaitForServiceState {
	if mmWaitForServiceState.mock.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("Inspect function is already set for ClientMock.WaitForServiceState")
	}

	mmWaitForServiceState.mock.inspectFuncWaitForServiceState = f

	return mmWaitForServiceState
}

// Return sets up results that will be returned by Client.WaitForServiceState
func (mmWaitForServiceState *mClientMockWaitForServiceState) Return(err error) *ClientMock {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	if mmWaitForServiceState.defaultExpectation == nil {
		mmWaitForServiceState.defaultExpectation = &ClientMockWaitForServiceStateExpectation{mock: mmWaitForServiceState.mock}
	}
	mmWaitForServiceState.defaultExpectation.results = &ClientMockWaitForServiceStateResults{err}
	return mmWaitForServiceState.mock
}

// Set uses given function f to mock the Client.WaitForServiceState method
func (mmWaitForServiceState *mClientMockWaitForServiceState) Set(f func(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error)) *ClientMock {
	if mmWaitForServiceState.defaultExpectation != nil {
		mmWaitForServiceState.mock.t.Fatalf("Default expectation is already set for the Client.WaitForServiceState method")
	}

	if len(mmWaitForServiceState.expectations) > 0 {
		mmWaitForServiceState.mock.t.Fatalf("Some expectations are already set for the Client.WaitForServiceState method")
	}

	mmWaitForServiceState.mock.funcWaitForServiceState = f
	return mmWaitForServiceState.mock
}

// When sets expectation for the Client.WaitForServiceState which will trigger the result defined by the following
// Then helper
func (mmWaitForServiceState *mClientMockWaitForServiceState) When(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) *ClientMockWaitForServiceStateExpectation {
	if mmWaitForServiceState.mock.funcWaitForServiceState != nil {
		mmWaitForServiceState.mock.t.Fatalf("ClientMock.WaitForServiceState mock is already set by Set")
	}

	expectation := &ClientMockWaitForServiceStateExpectation{
		mock:   mmWaitForServiceState.mock,
		params: &ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds},
	}
	mmWaitForServiceState.expectations = append(mmWaitForServiceState.expectations, expectation)
	return expectation
}

// Then sets up Client.WaitForServiceState return parameters for the expectation previously defined by the When method
func (e *ClientMockWaitForServiceStateExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockWaitForServiceStateResults{err}
	return e.mock
}

// Times sets number of times Client.WaitForServiceState should be invoked
func (mmWaitForServiceState *mClientMockWaitForServiceState) Times(n uint64) *mClientMockWaitForServiceState {
	if n == 0 {
		mmWaitForServiceState.mock.t.Fatalf("Times of ClientMock.WaitForServiceState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWaitForServiceState.expectedInvocations, n)
	return mmWaitForServiceState
}

func (mmWaitForServiceState *mClientMockWaitForServiceState) invocationsDone() bool {
	if len(mmWaitForServiceState.expectations) == 0 && mmWaitForServiceState.defaultExpectation == nil && mmWaitForServiceState.mock.funcWaitForServiceState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.mock.afterWaitForServiceStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWaitForServiceState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WaitForServiceState implements Client
func (mmWaitForServiceState *ClientMock) WaitForServiceState(ctx context.Context, serviceId string, stateChecker func(string) bool, maxWaitSeconds int) (err error) {
	mm_atomic.AddUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter, 1)

	if mmWaitForServiceState.inspectFuncWaitForServiceState != nil {
		mmWaitForServiceState.inspectFuncWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}

	mm_params := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

	// Record call args
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Lock()
	mmWaitForServiceState.WaitForServiceStateMock.callArgs = append(mmWaitForServiceState.WaitForServiceStateMock.callArgs, &mm_params)
	mmWaitForServiceState.WaitForServiceStateMock.mutex.Unlock()

	for _, e := range mmWaitForServiceState.WaitForServiceStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.params
		mm_want_ptrs := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWaitForServiceStateParams{ctx, serviceId, stateChecker, maxWaitSeconds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.serviceId != nil && !minimock.Equal(*mm_want_ptrs.serviceId, mm_got.serviceId) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter serviceId, want: %#v, got: %#v%s\n", *mm_want_ptrs.serviceId, mm_got.serviceId, minimock.Diff(*mm_want_ptrs.serviceId, mm_got.serviceId))
			}

			if mm_want_ptrs.stateChecker != nil && !minimock.Equal(*mm_want_ptrs.stateChecker, mm_got.stateChecker) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter stateChecker, want: %#v, got: %#v%s\n", *mm_want_ptrs.stateChecker, mm_got.stateChecker, minimock.Diff(*mm_want_ptrs.stateChecker, mm_got.stateChecker))
			}

			if mm_want_ptrs.maxWaitSeconds != nil && !minimock.Equal(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds) {
				mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameter maxWaitSeconds, want: %#v, got: %#v%s\n", *mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds, minimock.Diff(*mm_want_ptrs.maxWaitSeconds, mm_got.maxWaitSeconds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitForServiceState.t.Errorf("ClientMock.WaitForServiceState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitForServiceState.WaitForServiceStateMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitForServiceState.t.Fatal("No results are set for the ClientMock.WaitForServiceState")
		}
		return (*mm_results).err
	}
	if mmWaitForServiceState.funcWaitForServiceState != nil {
		return mmWaitForServiceState.funcWaitForServiceState(ctx, serviceId, stateChecker, maxWaitSeconds)
	}
	mmWaitForServiceState.t.Fatalf("Unexpected call to ClientMock.WaitForServiceState. %v %v %v %v", ctx, serviceId, stateChecker, maxWaitSeconds)
	return
}

// WaitForServiceStateAfterCounter returns a count of finished ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.afterWaitForServiceStateCounter)
}

// WaitForServiceStateBeforeCounter returns a count of ClientMock.WaitForServiceState invocations
func (mmWaitForServiceState *ClientMock) WaitForServiceStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitForServiceState.beforeWaitForServiceStateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WaitForServiceState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitForServiceState *mClientMockWaitForServiceState) Calls() []*ClientMockWaitForServiceStateParams {
	mmWaitForServiceState.mutex.RLock()

	argCopy := make([]*ClientMockWaitForServiceStateParams, len(mmWaitForServiceState.callArgs))
	copy(argCopy, mmWaitForServiceState.callArgs)

	mmWaitForServiceState.mutex.RUnlock()

	return argCopy
}

// MinimockWaitForServiceStateDone returns true if the count of the WaitForServiceState invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWaitForServiceStateDone() bool {
	if m.WaitForServiceStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WaitForServiceStateMock.invocationsDone()
}

// MinimockWaitForServiceStateInspect logs each unmet expectation
func (m *ClientMock) MinimockWaitForServiceStateInspect() {
	for _, e := range m.WaitForServiceStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState with params: %#v", *e.params)
		}
	}

	afterWaitForServiceStateCounter := mm_atomic.LoadUint64(&m.afterWaitForServiceStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WaitForServiceStateMock.defaultExpectation != nil && afterWaitForServiceStateCounter < 1 {
		if m.WaitForServiceStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.WaitForServiceState")
		} else {
			m.t.Errorf("Expected call to ClientMock.WaitForServiceState with params: %#v", *m.WaitForServiceStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitForServiceState != nil && afterWaitForServiceStateCounter < 1 {
		m.t.Error("Expected call to ClientMock.WaitForServiceState")
	}

	if !m.WaitForServiceStateMock.invocationsDone() && afterWaitForServiceStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WaitForServiceState but found %d calls",
			mm_atomic.LoadUint64(&m.WaitForServiceStateMock.expectedInvocations), afterWaitForServiceStateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateServiceInspect()

			m.MinimockDeleteServiceInspect()

			m.MinimockGetBackupConfigurationInspect()

			m.MinimockGetOrgPrivateEndpointConfigInspect()

			m.MinimockGetOrganizationPrivateEndpointsInspect()

			m.MinimockGetServiceInspect()

			m.MinimockUpdateBackupConfigurationInspect()

			m.MinimockUpdateOrganizationPrivateEndpointsInspect()

			m.MinimockUpdateReplicaScalingInspect()

			m.MinimockUpdateServiceInspect()

			m.MinimockUpdateServicePasswordInspect()

			m.MinimockWaitForServiceStateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateServiceDone() &&
		m.MinimockDeleteServiceDone() &&
		m.MinimockGetBackupConfigurationDone() &&
		m.MinimockGetOrgPrivateEndpointConfigDone() &&
		m.MinimockGetOrganizationPrivateEndpointsDone() &&
		m.MinimockGetServiceDone() &&
		m.MinimockUpdateBackupConfigurationDone() &&
		m.MinimockUpdateOrganizationPrivateEndpointsDone() &&
		m.MinimockUpdateReplicaScalingDone() &&
		m.MinimockUpdateServiceDone() &&
		m.MinimockUpdateServicePasswordDone() &&
		m.MinimockWaitForServiceStateDone()
}
