package resource

import (
	"context"
	"fmt"

	"github.com/ClickHouse/terraform-provider-clickhouse/pkg/internal/api"
	"github.com/ClickHouse/terraform-provider-clickhouse/pkg/resource/models"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

var (
	_ resource.Resource               = &ClickPipeResource{}
	_ resource.ResourceWithModifyPlan = &ClickPipeResource{}
	_ resource.ResourceWithConfigure  = &ClickPipeResource{}
)

type ClickPipeResource struct {
	client api.Client
}

func NewClickPipeResource() resource.Resource {
	return &ClickPipeResource{}
}

func (c *ClickPipeResource) Configure(_ context.Context, request resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if request.ProviderData == nil {
		return
	}

	c.client = request.ProviderData.(api.Client)
}

func (c *ClickPipeResource) Metadata(_ context.Context, request resource.MetadataRequest, response *resource.MetadataResponse) {
	response.TypeName = request.ProviderTypeName + "_clickpipe"
}

func (c *ClickPipeResource) Schema(_ context.Context, _ resource.SchemaRequest, response *resource.SchemaResponse) {
	response.Schema = schema.Schema{
		Description: "The ClickPipe resource allows you to create and manage ClickPipes data ingestion in ClickHouse Cloud.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "The ID of the ClickPipe. Generated by the ClickHouse Cloud.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"service_id": schema.StringAttribute{
				Description: "The ID of the service to which the ClickPipe belongs.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"name": schema.StringAttribute{
				Description: "The name of the ClickPipe.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"description": schema.StringAttribute{
				Description: "The description of the ClickPipe.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"scaling": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"replicas": schema.Int64Attribute{
						Description: "The number of desired replicas for the ClickPipe. Default is 1. The maximum value is 10.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.Int64{
							int64validator.Between(1, 10),
						},
					},
				},
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"state": schema.StringAttribute{
				MarkdownDescription: "The state of the ClickPipe. (`Running`, `Stopped`). Default is `Running`. Whenever the pipe state changes, the Terraform provider will try to ensure the actual state matches the planned value. If pipe is `Failed` and plan is `Running`, the provider will try to resume the pipe. If plan is `Stopped`, the provider will try to stop the pipe. If the pipe is `InternalError`, no action will be taken.",
				Optional:            true,
				Default:             stringdefault.StaticString(api.ClickPipeRunningState),
				Computed:            true,
				Validators: []validator.String{
					stringvalidator.OneOf(api.ClickPipeRunningState, api.ClickPipeStoppedState),
				},
			},
			"source": schema.SingleNestedAttribute{
				Description: "The data source for the ClickPipe.",
				Attributes: map[string]schema.Attribute{
					"kafka": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"type": schema.StringAttribute{
								MarkdownDescription: "The type of the Kafka source. (`kafka`, `msk`, `confluent`). Default is `kafka`.",
								Computed:            true,
								Optional:            true,
								Default:             stringdefault.StaticString(api.ClickPipeKafkaSourceType),
							},
							"brokers": schema.StringAttribute{
								Description: "The list of Kafka bootstrap brokers. (comma separated)",
								Required:    true,
							},
							"topics": schema.StringAttribute{
								Description: "The list of Kafka topics. (comma separated)",
								Required:    true,
							},
							"consumer_group": schema.StringAttribute{
								MarkdownDescription: "The Kafka consumer group. Default is `clickpipes-<ID>`.",
								Computed:            true,
								Optional:            true,
							},
							"authentication": schema.StringAttribute{
								MarkdownDescription: "The authentication method for the Kafka source. (`PLAIN`, `SCRAM-SHA-256`, `SCRAM-SHA-512`). Default is `PLAIN`.",
								Computed:            true,
								Optional:            true,
								Default:             stringdefault.StaticString("PLAIN"),
								Validators: []validator.String{
									stringvalidator.OneOf(
										api.ClickPipeKafkaAuthenticationPlain,
										api.ClickPipeKafkaAuthenticationScramSha256,
										api.ClickPipeKafkaAuthenticationScramSha512,
									),
								},
							},
							"credentials": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"username": schema.StringAttribute{
										Description: "The username for the Kafka source.",
										Required:    true,
										Sensitive:   true,
									},
									"password": schema.StringAttribute{
										Description: "The password for the Kafka source.",
										Required:    true,
										Sensitive:   true,
									},
								},
								Required: true,
							},
						},
					},
					"schema": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"format": schema.StringAttribute{
								Required:            true,
								MarkdownDescription: "The format of the schema. (`JSONEachRow`, `Avro`)",
								Validators: []validator.String{
									stringvalidator.OneOf(api.ClickPipeJSONEachRowFormat, api.ClickPipesAvroFormat),
								},
							},
						},
					},
				},
				Required: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"destination": schema.SingleNestedAttribute{
				Description: "The destination for the ClickPipe.",
				Attributes: map[string]schema.Attribute{
					"database": schema.StringAttribute{
						MarkdownDescription: "The name of the ClickHouse database. Default is `default`.",
						Default:             stringdefault.StaticString("default"),
						Computed:            true,
						Optional:            true,
					},
					"table": schema.StringAttribute{
						Description: "The name of the ClickHouse table.",
						Required:    true,
					},
					"managed_table": schema.BoolAttribute{
						MarkdownDescription: "Whether the table is managed by ClickHouse Cloud. If `false`, the table must exist in the database. Default is `true`.",
						Default:             booldefault.StaticBool(true),
						Computed:            true,
						Optional:            true,
					},
					"columns": schema.ListNestedAttribute{
						Description: "The list of columns for the ClickHouse table.",
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Description: "The name of the column.",
									Required:    true,
								},
								"type": schema.StringAttribute{
									Description: "The type of the column.",
									Required:    true,
								},
							},
						},
						Required: true,
					},
				},
				Required: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"field_mappings": schema.ListNestedAttribute{
				Description: "Field mapping between source and destination table.",
				Optional:    true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"source_field": schema.StringAttribute{
							Description: "The name of the source field.",
							Required:    true,
						},
						"destination_field": schema.StringAttribute{
							Description: "The name of the column in destination table.",
							Required:    true,
						},
					},
				},
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (c *ClickPipeResource) ModifyPlan(ctx context.Context, request resource.ModifyPlanRequest, response *resource.ModifyPlanResponse) {
	if request.Plan.Raw.IsNull() {
		// If the entire plan is null, the resource is planned for destruction.
		return
	}

	var plan, state, config models.ClickPipeResourceModel
	diags := request.Plan.Get(ctx, &plan)
	response.Diagnostics.Append(diags...)
	if !request.State.Raw.IsNull() {
		diags = request.State.Get(ctx, &state)
		response.Diagnostics.Append(diags...)
	}
	if response.Diagnostics.HasError() {
		return
	}

	if !request.Config.Raw.IsNull() {
		diags = request.Config.Get(ctx, &config)
		response.Diagnostics.Append(diags...)
	}
	if response.Diagnostics.HasError() {
		return
	}

	if !request.State.Raw.IsNull() {
		if !plan.ServiceID.IsNull() && plan.ServiceID != state.ServiceID {
			response.Diagnostics.AddAttributeError(
				path.Root("service_id"),
				"Invalid Update",
				"ClickPipe cannot be moved between services. Please delete and recreate the ClickPipe.",
			)
		}
	}
}

func (c *ClickPipeResource) Create(ctx context.Context, request resource.CreateRequest, response *resource.CreateResponse) {
	var plan models.ClickPipeResourceModel
	diags := request.Plan.Get(ctx, &plan)
	response.Diagnostics.Append(diags...)
	if response.Diagnostics.HasError() {
		return
	}

	clickPipe := api.ClickPipe{
		Name:        plan.Name.ValueString(),
		Description: plan.Description.ValueString(),
		ServiceID:   plan.ServiceID.ValueString(),
	}

	if !plan.Scaling.IsNull() {
		replicasModel := models.ClickPipeScalingModel{}
		response.Diagnostics.Append(plan.Scaling.As(ctx, &replicasModel, basetypes.ObjectAsOptions{})...)

		clickPipe.Scaling = &api.ClickPipeScaling{
			Replicas: replicasModel.Replicas.ValueInt64(),
		}
	}

	sourceModel := models.ClickPipeSourceModel{}
	schemaModel := models.ClickPipesSourceSchemaModel{}
	response.Diagnostics.Append(plan.Source.As(ctx, &sourceModel, basetypes.ObjectAsOptions{})...)
	response.Diagnostics.Append(sourceModel.Schema.As(ctx, &schemaModel, basetypes.ObjectAsOptions{})...)

	clickPipe.Source = api.ClickPipeSource{
		Schema: api.ClickPipeSourceSchema{
			Format: schemaModel.Format.ValueString(),
		},
	}

	if !sourceModel.Kafka.IsNull() {
		kafkaModel := models.ClickPipeKafkaSourceModel{}
		credentialsModel := models.ClickPipeSourceCredentialsModel{}
		response.Diagnostics.Append(sourceModel.Kafka.As(ctx, &kafkaModel, basetypes.ObjectAsOptions{})...)
		response.Diagnostics.Append(kafkaModel.Credentials.As(ctx, &credentialsModel, basetypes.ObjectAsOptions{})...)
		clickPipe.Source.Kafka = &api.ClickPipeKafkaSource{
			Type:           kafkaModel.Type.ValueString(),
			Brokers:        kafkaModel.Brokers.ValueString(),
			Topics:         kafkaModel.Topics.ValueString(),
			ConsumerGroup:  kafkaModel.ConsumerGroup.ValueString(),
			Authentication: kafkaModel.Authentication.ValueString(),
			Credentials: api.ClickPipeSourceCredentials{
				Username: credentialsModel.Username.ValueString(),
				Password: credentialsModel.Password.ValueString(),
			},
		}
	}

	destinationModel := models.ClickPipeDestinationModel{}
	response.Diagnostics.Append(plan.Destination.As(ctx, &destinationModel, basetypes.ObjectAsOptions{})...)
	destinationColumnsModels := make([]models.ClickPipeDestinationColumnModel, len(destinationModel.Columns.Elements()))
	response.Diagnostics.Append(destinationModel.Columns.ElementsAs(ctx, &destinationColumnsModels, false)...)

	clickPipe.Destination = api.ClickPipeDestination{
		Database:     destinationModel.Database.ValueString(),
		Table:        destinationModel.Table.ValueString(),
		ManagedTable: destinationModel.ManagedTable.ValueBool(),
		Columns:      make([]api.ClickPipeDestinationColumn, len(destinationColumnsModels)),
	}
	for i, columnModel := range destinationColumnsModels {
		clickPipe.Destination.Columns[i] = api.ClickPipeDestinationColumn{
			Name: columnModel.Name.ValueString(),
			Type: columnModel.Type.ValueString(),
		}
	}

	fieldMappingsModels := make([]models.ClickPipeFieldMappingModel, len(plan.FieldMappings.Elements()))
	response.Diagnostics.Append(plan.FieldMappings.ElementsAs(ctx, &fieldMappingsModels, false)...)
	clickPipe.FieldMappings = make([]api.ClickPipeFieldMapping, len(fieldMappingsModels))
	for i, fieldMappingModel := range fieldMappingsModels {
		clickPipe.FieldMappings[i] = api.ClickPipeFieldMapping{
			SourceField:      fieldMappingModel.SourceField.ValueString(),
			DestinationField: fieldMappingModel.DestinationField.ValueString(),
		}
	}

	createdClickPipe, err := c.client.CreateClickPipe(ctx, clickPipe.ServiceID, clickPipe)
	if err != nil {
		response.Diagnostics.AddError(
			"Error Creating ClickPipe",
			"Could not create ClickPipe, unexpected error: "+err.Error(),
		)
		return
	}

	if _, err := c.client.WaitForClickPipeState(ctx, createdClickPipe.ServiceID, createdClickPipe.ID, func(state string) bool {
		return state == plan.State.String()
	}, 60); err != nil {
		response.Diagnostics.AddError(
			"Error retrieving ClickPipe state",
			"Could not retrieve ClickPipe state, unexpected error: "+err.Error(),
		)
		return
	}

	plan.ID = types.StringValue(createdClickPipe.ID)

	if err := c.syncClickPipeState(ctx, &plan); err != nil {
		response.Diagnostics.AddError(
			"Error reading ClickPipe",
			"Could not read ClickPipe, unexpected error: "+err.Error(),
		)
		return
	}

	diags = response.State.Set(ctx, plan)
	response.Diagnostics.Append(diags...)
}

func (c *ClickPipeResource) syncClickPipeState(ctx context.Context, state *models.ClickPipeResourceModel) error {
	if state.ID.IsNull() {
		return fmt.Errorf("ClickPipe ID is required to sync state")
	}

	clickPipe, err := c.client.GetClickPipe(ctx, state.ServiceID.ValueString(), state.ID.ValueString())
	if api.IsNotFound(err) {
		// ClickPipe does not exist, deleted outside Terraform
		state.ID = types.StringNull()
		return nil
	} else if err != nil {
		return err
	}

	state.Name = types.StringValue(clickPipe.Name)
	state.Description = types.StringValue(clickPipe.Description)
	state.State = types.StringValue(clickPipe.State)

	if clickPipe.Scaling != nil {
		state.Scaling = models.ClickPipeScalingModel{
			Replicas: types.Int64Value(clickPipe.Scaling.Replicas),
		}.ObjectValue()
	}

	// todo: implement

	return nil
}

func (c *ClickPipeResource) Read(ctx context.Context, request resource.ReadRequest, response *resource.ReadResponse) {
	var state models.ClickPipeResourceModel
	diags := request.State.Get(ctx, &state)
	response.Diagnostics.Append(diags...)
	if response.Diagnostics.HasError() {
		return
	}

	if err := c.syncClickPipeState(ctx, &state); err != nil {
		response.Diagnostics.AddError(
			"Error Reading ClickPipe",
			"Could not read ClickPipe, unexpected error: "+err.Error(),
		)
		return
	}

	if state.ID.IsNull() {
		// ClickPipe does not exist, removed outside Terraform
		// todo: validate
		response.State.RemoveResource(ctx)
		return
	}

	diags = response.State.Set(ctx, state)
	response.Diagnostics.Append(diags...)
}

func (c *ClickPipeResource) Update(ctx context.Context, req resource.UpdateRequest, response *resource.UpdateResponse) {
	var plan, state models.ClickPipeResourceModel
	diags := req.Plan.Get(ctx, &plan)
	response.Diagnostics.Append(diags...)
	diags = req.State.Get(ctx, &state)
	response.Diagnostics.Append(diags...)

	if response.Diagnostics.HasError() {
		return
	}

	// todo: scale, state change

	response.Diagnostics.AddError(
		"Error Updating ClickPipe",
		"ClickPipe is immutable. Please delete and recreate the ClickPipe.",
	)
	return
}

func (c *ClickPipeResource) Delete(ctx context.Context, request resource.DeleteRequest, response *resource.DeleteResponse) {
	var state models.ClickPipeResourceModel
	diags := request.State.Get(ctx, &state)
	response.Diagnostics.Append(diags...)
	if response.Diagnostics.HasError() {
		return
	}

	if err := c.client.DeleteClickPipe(ctx, state.ServiceID.ValueString(), state.ID.ValueString()); err != nil {
		response.Diagnostics.AddError(
			"Error Deleting ClickPipe",
			"Could not delete ClickPipe, unexpected error: "+err.Error(),
		)
	}
}
